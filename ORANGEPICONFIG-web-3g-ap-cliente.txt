sudo tee /etc/update-motd.d/10-orangepi-header >/dev/null <<'EOF'
#!/bin/bash
#
# Copyright (c) Authors: https://www.armbian.com/authors
#
# This file is licensed under the terms of the GNU General Public
# License version 2. This program is licensed "as is" without any
# warranty of any kind, whether express or implied.

# DO NOT EDIT THIS FILE but add config options to /etc/default/orangepi-motd
# any changes will be lost on board support package update

THIS_SCRIPT="header"
MOTD_DISABLE=""

[[ -f /etc/default/orangepi-motd ]] && . /etc/default/orangepi-motd

for f in $MOTD_DISABLE; do
	[[ $f == $THIS_SCRIPT ]] && exit 0
done

. /etc/os-release
. /etc/orangepi-release

KERNELID=$(uname -r)
TERM=linux toilet -f standard -F metal $(echo 'Mirako.org')
echo -e "Welcome to \e[0;91mOrange Pi ${VERSION} ${DISTRIBUTION_CODENAME^}\x1B[0m with $([[ $BRANCH == edge ]] && echo -e "\e[0;91mbleeding\x1B[0m edge " )\e[0;91mLinux $KERNELID\x1B[0m\n \e[0;97m by SantoCyber\x1B[0m\n"

EOF

figlet "Mirako.ORG"
figlet "SantoCyber"




sudo apt update
sudo apt install -y hostapd dnsmasq ppp usb-modeswitch wpasupplicant iptables-persistent python3-flask python3-systemd traceroute tcpdump





echo 'net.ipv4.ip_forward=1' | sudo tee /etc/sysctl.d/99-iptables.conf
sudo sysctl -p /etc/sysctl.d/99-iptables.conf






sudo tee /etc/hostapd/hostapd.conf >/dev/null <<'EOF'
# /etc/hostapd/hostapd.conf
interface=wlan0
driver=nl80211
ssid=MirakoAP
country_code=BR
ieee80211d=1

# 2.4 GHz
hw_mode=g
channel=6
wmm_enabled=1
ieee80211n=1
# (opcional) algumas placas precisam disso para estabilidade:
# ht_capab=[SHORT-GI-20][SHORT-GI-40]

# WPA2-PSK CCMP
auth_algs=1
ignore_broadcast_ssid=0
wpa=2
wpa_key_mgmt=WPA-PSK
rsn_pairwise=CCMP
wpa_pairwise=CCMP
wpa_passphrase=12345678

# interface de controle (útil para debug)
ctrl_interface=/var/run/hostapd
logger_syslog=-1
logger_syslog_level=2


EOF



sudo tee /etc/default/hostapd >/dev/null <<'EOF' 
DAEMON_CONF="/etc/hostapd/hostapd.conf"
EOF


sudo tee /etc/dnsmasq.d/mirako.conf >/dev/null <<'EOF' 
interface=wlan0,end0        # serve DHCP nas interfaces LAN/AP
dhcp-range=192.168.7.50,192.168.7.240,12h
domain=mirako.local
dhcp-option=3,192.168.7.1   # gateway padrão (endereço da Pi)
dhcp-option=6,8.8.8.8,8.8.4.4  # servidores DNS
log-queries
log-dhcp
EOF


sudo systemctl disable --now hostapd dnsmasq
sudo systemctl mask hostapd dnsmasq

sudo systemctl disable --now wpa_supplicant@wlan0.service
sudo systemctl disable --now NetworkManager.service



# crie/garanta diretório de chats
sudo mkdir -p /etc/chatscripts

# (re)crie o chat de CONEXÃO

sudo install -d /etc/chatscripts

sudo tee /etc/chatscripts/3g.chat >/dev/null <<'EOF'
ABORT   'BUSY'
ABORT   'NO CARRIER'
ABORT   'NO DIALTONE'
ABORT   'NO ANSWER'
ABORT   'ERROR'
ABORT   'SIM PIN'
REPORT  CONNECT
TIMEOUT 30
''        AT
OK        ATE0
OK        AT+CFUN=1
OK        AT+CREG?
OK        AT+CGDCONT=1,"IP","zap.vivo.com.br"
OK        ATD*99#
CONNECT   \c
EOF

# chat de DESCONEXÃO
sudo tee /etc/chatscripts/3g-disconnect.chat >/dev/null <<'EOF'
'' '+++'
'' 'ATH'
'' 'ATZ'
EOF

# permissões: leitura suficiente (chat só precisa ler)
sudo chmod 644 /etc/chatscripts/3g.chat /etc/chatscripts/3g-disconnect.chat

# peers do pppd
sudo mkdir -p /etc/ppp/peers
sudo tee /etc/ppp/peers/3g >/dev/null <<'EOF'
/dev/ttyUSB2 115200
connect "/usr/sbin/chat -v -f /etc/chatscripts/3g.chat"
crtscts
modem
noauth
defaultroute
replacedefaultroute
usepeerdns
persist
holdoff 5
maxfail 0
noipdefault
noipv6
lcp-echo-interval 5
lcp-echo-failure 6

EOF




sudo tee /usr/local/bin/profiles.sh >/dev/null <<'EOF'
#!/usr/bin/env bash
set -Eeuo pipefail

# ===== Config =====
SSID="MirakoAP"
PASS="12345678"
CHANNEL=6
COUNTRY="BR"

WLAN_IF="wlan0"
LAN_IF="end0"     # sua WAN cabeada
PPP_IF="ppp0"
PPP_PEER="3g"

# Gateways padrão (pode sobrescrever via ambiente)
AP_GW="${AP_GW:-192.168.0.1}"
# PPP_GW não é necessário em PPP (rota p2p); deixe o pppd gerir

log(){ echo "[profiles] $*"; }
log "PATH=$PATH"
command -v create_ap || log "ERRO: create_ap não encontrado no PATH"
have(){ command -v "$1" >/dev/null 2>&1; }
T(){ timeout -k 5 "${2:-25}"s bash -lc "$1"; }

# ---------- helpers de rede ----------
ensure_ip_forward(){ sysctl -w net.ipv4.ip_forward=1 >/dev/null 2>&1 || true; }

ensure_nat(){
  local WAN="$1"
  command -v iptables >/dev/null 2>&1 || return 0

  # Liga roteamento
  sysctl -w net.ipv4.ip_forward=1 >/dev/null 2>&1 || true

  # Aceita forward (caso policy esteja DROP em algum momento)
  iptables -C FORWARD -j ACCEPT 2>/dev/null || iptables -A FORWARD -j ACCEPT

  # Regras de forward estadoful WLAN<->WAN
  iptables -C FORWARD -i "$WAN"  -o "$WLAN_IF" -m state --state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null \
    || iptables -A FORWARD -i "$WAN"  -o "$WLAN_IF" -m state --state RELATED,ESTABLISHED -j ACCEPT
  iptables -C FORWARD -i "$WLAN_IF" -o "$WAN" -j ACCEPT 2>/dev/null \
    || iptables -A FORWARD -i "$WLAN_IF" -o "$WAN" -j ACCEPT

  # Limpa MASQUERADE antigos do NAT (evita duplicatas quando WAN muda)
  iptables -t nat -S POSTROUTING | awk '/MASQUERADE/ {print $0}' | \
    sed -n 's/^-A/ -D/p' | while read -r del; do iptables -t nat $del 2>/dev/null || true; done

  # MASQUERADE na WAN atual
  iptables -t nat -A POSTROUTING -o "$WAN" -j MASQUERADE 2>/dev/null || true
}


pick_ppp_iface(){
  # Se já existe e tem IPv4, ok
  if ip -4 addr show dev "$PPP_IF" 2>/dev/null | grep -q 'inet '; then return 0; fi
  # tenta ppp0
  if ip -4 addr show dev ppp0 2>/dev/null | grep -q 'inet '; then PPP_IF="ppp0"; export PPP_IF; return 0; fi
  # procura qualquer pppX
  for d in /sys/class/net/ppp*; do
    [ -e "$d" ] || continue
    dev="$(basename "$d")"
    if ip -4 addr show dev "$dev" 2>/dev/null | grep -q 'inet '; then PPP_IF="$dev"; export PPP_IF; return 0; fi
  done
  return 1
}

stop_conflict(){
  systemctl stop create_ap 2>/dev/null || true
  systemctl stop hostapd dnsmasq 2>/dev/null || true
  systemctl stop "wpa_supplicant@${WLAN_IF}.service" 2>/dev/null || true
  systemctl stop NetworkManager 2>/dev/null || true

  pkill -f "wpa_supplicant.*${WLAN_IF}" 2>/dev/null || true
  pkill -f "hostapd.*${WLAN_IF}"        2>/dev/null || true
  pkill dnsmasq 2>/dev/null || true

  rfkill unblock all || true
  ip link set "$WLAN_IF" down || true
  ip addr flush dev "$WLAN_IF" || true
  ip link set "$WLAN_IF" up || true
}

create_ap_daemon(){
  local WAN="$1"

  # Tenta parar instância anterior do create_ap (se houver)
  create_ap --stop "$WLAN_IF" 2>/dev/null || true

  # Se não tiver WAN definida, sobe AP nativo (hostapd/dnsmasq)
  if [ -z "$WAN" ]; then
    echo "[profiles] WAN vazia — usando AP nativo (hostapd/dnsmasq)"
    start_ap_native
    return
  fi

  # Se existir create_ap, tenta em modo daemon; se falhar, cai pro nativo
  if command -v create_ap >/dev/null 2>&1; then
    if ! create_ap --daemon --no-virt --ieee80211n --freq-band 2.4 \
                   -c "$CHANNEL" --country "$COUNTRY" \
                   "$WLAN_IF" "$WAN" "$SSID" "$PASS"; then
      echo "[profiles] create_ap falhou — caindo para AP nativo (hostapd/dnsmasq)"
      start_ap_native
    fi
  else
    echo "[profiles] create_ap não encontrado — usando AP nativo (hostapd/dnsmasq)"
    start_ap_native
  fi
}


has_ppp_ipv4(){ ip -4 addr show dev "$PPP_IF" 2>/dev/null | grep -q 'inet '; }

ensure_ppp_up(){
  if has_ppp_ipv4; then
    log "PPP já está com IPv4 em ${PPP_IF}"
    return 0
  fi
  pkill -x pppd 2>/dev/null || true
  rm -f /var/lock/LCK..ttyUSB* 2>/dev/null || true

  if have pppd && [ -f "/etc/ppp/peers/${PPP_PEER}" ]; then
    log "Discando: pppd call ${PPP_PEER}"
    T "pppd call ${PPP_PEER}" 30 || true
  elif have pon; then
    log "Discando: pon ${PPP_PEER}"
    T "pon ${PPP_PEER}" 30 || true
  else
    log "ERRO: nem pppd nem pon encontrados."
    return 1
  fi

  for i in {1..60}; do
    if pick_ppp_iface && has_ppp_ipv4; then
      log "PPP ativo com IPv4 em ${PPP_IF}"
      return 0
    fi
    sleep 1
  done

  log "PPP não obteve IPv4 a tempo, últimos logs ppp/chat:"
  journalctl -b -n 60 --no-pager | grep -iE 'ppp|chat' || true
  return 1
}

start_ppp(){
  pkill -x pppd 2>/dev/null || true
  rm -f /var/lock/LCK..ttyUSB* 2>/dev/null || true
  if have pppd && [ -f "/etc/ppp/peers/${PPP_PEER}" ]; then
    log "Iniciando PPP via: pppd call ${PPP_PEER}"
    T "pppd call ${PPP_PEER}" 30 || true
  elif have pon; then
    log "Iniciando PPP via: pon ${PPP_PEER}"
    T "pon ${PPP_PEER}" 30 || true
  else
    log "ERRO: nem pppd nem pon encontrados."
    return 1
  fi
}

renew_dhcp(){
  have dhclient || return 0
  T "dhclient -r $1" 8  || true
  T "dhclient $1"   20 || true
}



# retorna 0 se a interface tem "carrier" (cabo/link) ativo
iface_has_carrier(){
  local IF="$1"
  [ -r "/sys/class/net/$IF/carrier" ] && [ "$(cat /sys/class/net/$IF/carrier 2>/dev/null)" = "1" ]
}

# lista as LANs reais: $LAN_IF + quaisquer enx* (USB/Ethernet)
lan_real_ifaces(){
  local L=()
  [ -d "/sys/class/net/$LAN_IF" ] && L+=("$LAN_IF")
  for i in /sys/class/net/enx*; do
    [ -e "$i" ] || continue
    L+=("$(basename "$i")")
  done
  printf '%s\n' "${L[@]}" | sort -u
}

# Sobe a IF, pega DHCP se houver link, e remove default dessa IF
bring_up_with_dhcp_no_default(){
  local IF="$1"
  ip link set "$IF" up || true
  if iface_has_carrier "$IF"; then
    have dhclient && { T "dhclient -r ${IF}" 6 || true; T "dhclient ${IF}" 25 || true; }
    # remove qualquer default direta nessa IF (não queremos roubar a rota)
    ip -4 route del default dev "$IF" 2>/dev/null || true

    # (opcional) manter uma default de *reserva* com métrica alta, se souber o GW
    local GW
    GW="$(awk '/option routers/{for(i=3;i<=NF;i++){gsub(/[,;]*/,"",$i); printf "%s ",$i}} END{print ""}' \
          /var/lib/dhcp/dhclient.${IF}.leases 2>/dev/null | awk '{print $NF}')"
    if [ -n "$GW" ]; then
      ip route replace default via "$GW" dev "$IF" metric 400 2>/dev/null || true
    fi
  fi
}

# Mantém a default preferida via uma IF (métrica baixa)
prefer_default_via_dev(){
  local IF="$1"
  local GW
  GW="$(awk '/option routers/{for(i=3;i<=NF;i++){gsub(/[,;]*/,"",$i); printf "%s ",$i}} END{print ""}' \
        /var/lib/dhcp/dhclient.${IF}.leases 2>/dev/null | awk '{print $NF}')"
  ip -4 route del default 2>/dev/null || true
  if [ -n "$GW" ]; then
    ip route add default via "$GW" dev "$IF" metric 50 2>/dev/null || \
    ip route replace default via "$GW" dev "$IF" metric 50
  else
    ip route add default dev "$IF" metric 50 2>/dev/null || \
    ip route replace default dev "$IF" metric 50
  fi
}


# Sobe interface com DHCP e remove/penaliza a rota default dessa IF
up_iface_dhcp_no_default(){
  local IF="$1"
  ip link set "$IF" up || true
  if have dhclient; then
    T "dhclient -r ${IF}" 6 || true
    T "dhclient ${IF}" 25 || true
  fi
  # Remove rota default direta nessa IF (caso o servidor DHCP tenha empurrado)
  ip -4 route del default dev "$IF" 2>/dev/null || true

  # (OPCIONAL) manter uma default “de reserva” com métrica alta
  # Tenta extrair o GW do último lease do dhclient
  local GW
  GW="$(awk '/option routers/{for(i=3;i<=NF;i++){gsub(/[,;]*/,"",$i); printf "%s ",$i}} END{print ""}' \
        /var/lib/dhcp/dhclient.${IF}.leases 2>/dev/null | awk '{print $NF}')"
  if [ -n "$GW" ]; then
    ip route replace default via "$GW" dev "$IF" metric 400 2>/dev/null || true
  fi
}

# Garante que a rota default preferida continue por uma IF (com métrica baixa)
prefer_default_via_dev(){
  local IF="$1"
  # Se houver GW aprendido pelo DHCP dessa IF, use-o; senão, fica default dev
  local GW
  GW="$(awk '/option routers/{for(i=3;i<=NF;i++){gsub(/[,;]*/,"",$i); printf "%s ",$i}} END{print ""}' \
        /var/lib/dhcp/dhclient.${IF}.leases 2>/dev/null | awk '{print $NF}')"

  # Zera defaults zumbis
  ip -4 route del default 2>/dev/null || true

  if [ -n "$GW" ]; then
    ip route add default via "$GW" dev "$IF" metric 50 2>/dev/null || \
    ip route replace default via "$GW" dev "$IF" metric 50
  else
    ip route add default dev "$IF" metric 50 2>/dev/null || \
    ip route replace default dev "$IF" metric 50
  fi
}




# === Adições para fallback e checagem de conectividade ===
PPP_CONNECT_CHECK_HOST="${PPP_CONNECT_CHECK_HOST:-8.8.8.8}"

start_ap_native(){
  # Para serviços conflitantes
  systemctl unmask hostapd dnsmasq >/dev/null 2>&1 || true
  systemctl stop create_ap hostapd dnsmasq >/dev/null 2>&1 || true

  rfkill unblock all || true
  ip link set "$WLAN_IF" down || true
  ip addr flush dev "$WLAN_IF" || true
  ip addr add 192.168.7.1/24 dev "$WLAN_IF" || true
  ip link set "$WLAN_IF" up || true

  # Sobe DHCP e AP
  systemctl enable --now dnsmasq >/dev/null 2>&1 || true
  systemctl enable --now hostapd >/dev/null 2>&1 || true

  # Confere se realmente está em AP; se não, tenta de novo suave
  sleep 1
  if ! iw dev "$WLAN_IF" info 2>/dev/null | grep -q "type AP"; then
    logger -t profiles "hostapd/dnsmasq ativos, mas iface não reporta AP — rearmando"
    systemctl restart hostapd dnsmasq || true
  fi
}


start_ap_wan(){
  local WAN_IF="$1"
  stop_conflict
  ensure_ip_forward

  # Se informaram WAN, aplica NAT/forward
  if [ -n "$WAN_IF" ]; then ensure_nat "$WAN_IF"; fi

  if command -v create_ap >/dev/null 2>&1; then
    create_ap --stop "$WLAN_IF" >/dev/null 2>&1 || true
    if [ -n "$WAN_IF" ]; then
      if create_ap --daemon --no-virt --ieee80211n --freq-band 2.4 \
                   -c "$CHANNEL" --country "$COUNTRY" \
                   "$WLAN_IF" "$WAN_IF" "$SSID" "$PASS"; then
        sleep 1
        if ! iw dev "$WLAN_IF" info 2>/dev/null | grep -q "type AP"; then
          echo "[profiles] create_ap subiu, mas interface não está em AP; fallback nativo."
          start_ap_native
        fi
      else
        echo "[profiles] create_ap falhou; fallback nativo."
        start_ap_native
      fi
    else
      # Sem WAN: AP local (c/ hostapd/dnsmasq)
      start_ap_native
    fi
  else
    # Sem create_ap: AP nativo; se houve WAN, mantém NAT/rota abaixo
    start_ap_native
  fi

  # Se tiver WAN com IP, força default via WAN (para caso de AP com internet)
  if [ -n "$WAN_IF" ]; then
    if ip -4 addr show dev "$WAN_IF" | grep -q 'inet '; then
      ip route replace default dev "$WAN_IF" || true
    fi
  fi
}

ppp_keep_ap_loop(){
  # AP primeiro, sem depender do PPP
  start_ap_wan ""   # AP nativo sem WAN (hostapd/dnsmasq)
  echo "[profiles] AP ativo (sem WAN). Iniciando watchdog PPP…"

  while :; do
    # se já tem IPv4 no PPP, apenas garante NAT/rota e checa conectividade
    if ip -4 addr show dev "$PPP_IF" 2>/dev/null | grep -q 'inet '; then
      ip route replace default dev "$PPP_IF" 2>/dev/null || true
      ensure_nat "$PPP_IF"
      # teste rápido
      if ping -I "$PPP_IF" -c1 -W3 1.1.1.1 >/dev/null 2>&1; then
        sleep 8
        continue
      fi
    fi

    # tenta discar
    pkill -x pppd 2>/dev/null || true
    rm -f /var/lock/LCK..ttyUSB* 2>/dev/null || true
    echo "[profiles] Discando: pppd call ${PPP_PEER}"
    if timeout 35s bash -lc "pppd call ${PPP_PEER}"; then
      # aguarda IPv4
      for i in {1..25}; do
        if ip -4 addr show dev "$PPP_IF" 2>/dev/null | grep -q 'inet '; then
          echo "[profiles] PPP ativo — comutando NAT/rota para ${PPP_IF}"
          ip route replace default dev "$PPP_IF" 2>/dev/null || true
          ensure_nat "$PPP_IF"
          break
        fi
        sleep 1
      done
    else
      echo "[profiles] pppd não conectou. Nova tentativa em 6s (AP permanece ativo)."
      sleep 6
    fi
  done
}



ppp_has_connectivity(){
  # Interface com IPv4 + consegue pingar um destino rápido
  has_ppp_ipv4 || return 1
  ping -I "$PPP_IF" -c2 -W3 "$PPP_CONNECT_CHECK_HOST" >/dev/null 2>&1
}

usage(){ echo "Uso: $0 {ap|3g|client-wifi|client-lan|ap-stop}"; exit 1; }
[ $# -ge 1 ] || usage
PROFILE="$1"

case "$PROFILE" in
  ap)
    log "== Roteador AP (WAN=${LAN_IF} → AP em ${WLAN_IF}) =="
    stop_conflict

    ip link set "$LAN_IF" up || true
    renew_dhcp "$LAN_IF"

    # rota padrão e NAT via LAN
    ensure_ip_forward
    ip route replace default via "$AP_GW" dev "$LAN_IF" || ip route replace default dev "$LAN_IF"
    ensure_nat "$LAN_IF"

    create_ap_daemon "$LAN_IF"
    log "OK: AP+NAT via ${LAN_IF} (GW=${AP_GW})"
  ;;

3g|ppp|ppp3g)
    log "== Perfil: Roteador 3G/4G (WAN=${PPP_IF} → AP em ${WLAN_IF}) =="
    stop_conflict

    # mate qualquer DHCP/rota herdada da LAN/WLAN
    pkill -f "dhclient.*${LAN_IF}" 2>/dev/null || true
    ip route del default dev "${LAN_IF}" 2>/dev/null || true
    ip route del default dev "${WLAN_IF}" 2>/dev/null || true

    # disca e aguarda IPv4 no PPP
    if ensure_ppp_up && pick_ppp_iface; then
      ensure_ip_forward

      # force a default via PPP (e apague defaults zumbis)
      ip route del default 2>/dev/null || true
      ip route add default dev "$PPP_IF" 2>/dev/null || ip route replace default dev "$PPP_IF"

      ensure_nat "$PPP_IF"
      start_ap_wan "$PPP_IF"

      # (opcional) teste de reachability sem derrubar o modo
      if ! ping -I "$PPP_IF" -c2 -W3 1.1.1.1 >/dev/null 2>&1 && \
         ! ping -I "$PPP_IF" -c2 -W3 8.8.8.8  >/dev/null 2>&1; then
        log "AVISO: PPP tem IP mas sem resposta ICMP (pode ser bloqueio da operadora)."
      fi

      log "OK: AP+NAT via ${PPP_IF} (default via PPP)"
    else
      log "FALLBACK: PPP não subiu — mudando para perfil AP"
      exec "$0" ap
    fi
  ;;

  client-wifi|wifi-client|sta)
    log "== Cliente Wi-Fi (WAN=${WLAN_IF}) =="
    # derruba qualquer AP e limpa restos
    create_ap --stop "$WLAN_IF" 2>/dev/null || true
    systemctl stop hostapd dnsmasq 2>/dev/null || true

    # wpa_supplicant gerencia o STA
    systemctl start "wpa_supplicant@${WLAN_IF}.service" 2>/dev/null || true
    ip link set "$WLAN_IF" up || true
    have wpa_cli && {
      wpa_cli -i "$WLAN_IF" reconfigure >/dev/null 2>&1 || true
      wpa_cli -i "$WLAN_IF" reassociate >/dev/null 2>&1 || true
    }

    # DHCP na wlan0 e rota preferida por ela
    have dhclient && { T "dhclient -r ${WLAN_IF}" 8 || true; T "dhclient ${WLAN_IF}" 30 || true; }
    prefer_default_via_dev "$WLAN_IF"

    # >>> MANTER end0 (e quaisquer enx*) UP com IP, mas sem tomar a default <<<
    for IF in $(lan_real_ifaces); do
      [ "$IF" = "$WLAN_IF" ] && continue
      bring_up_with_dhcp_no_default "$IF"
    done

    log "OK: STA no Wi-Fi (default via ${WLAN_IF}); LAN(s) ativa(s) com IP (sem default)."
  ;;


  client-lan|lan-client)
    log "== Cliente LAN (WAN=${LAN_IF}; Wi-Fi livre p/ scan) =="
    create_ap --stop "$WLAN_IF" 2>/dev/null || true
    systemctl stop hostapd dnsmasq 2>/dev/null || true

    ip link set "$LAN_IF" up || true
    renew_dhcp "$LAN_IF"

    systemctl start NetworkManager 2>/dev/null || true
    systemctl restart "wpa_supplicant@${WLAN_IF}.service" 2>/dev/null || true
    ip link set "$WLAN_IF" up || true
    ip addr flush dev "$WLAN_IF" || true

    log "OK: WAN pela ${LAN_IF}; Wi-Fi em managed p/ scan"
  ;;

  ap-stop)
    log "Parando AP"
    create_ap --stop "$WLAN_IF" 2>/dev/null || true
    log "OK"
  ;;

  *)
    usage
  ;;
esac



EOF

sudo chmod +x /usr/local/bin/profiles.sh










mkdir /opt/mirako_web

sudo tee /opt/mirako_web/web_config.py >/dev/null <<'EOF'
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from flask import Flask, render_template_string, request, redirect, url_for, flash
import subprocess, os, re, time, shutil, glob, math , threading, signal


app = Flask(__name__)
app.secret_key = os.environ.get("MIRAKO_SECRET", "devkey")

# ======== Configs ========
WLAN_IF = os.environ.get("WLAN_IF", "wlan0")
LAN_IF  = os.environ.get("LAN_IF",  "end0")
PPP_IF  = os.environ.get("PPP_IF",  "ppp0")
PPP_PEER = os.environ.get("PPP_PEER", "3g")
PROFILES_SCRIPT = os.environ.get("PROFILES_SCRIPT", "/usr/local/bin/profiles.sh")



# ======== paths (tentativa via which e fallback) ========
def find_bin(name, fallbacks):
    p = shutil.which(name)
    if p: return p
    for fb in fallbacks:
        if os.path.exists(fb) and os.access(fb, os.X_OK):
            return fb
    return name  # deixa pro PATH da unit
PPPD_BIN    = find_bin("pppd",   ["/usr/sbin/pppd","/sbin/pppd","/usr/bin/pppd"])
IP_BIN       = find_bin("ip",      ["/usr/sbin/ip","/sbin/ip","/usr/bin/ip"])
IW_BIN       = find_bin("iw",      ["/usr/sbin/iw","/sbin/iw","/usr/bin/iw"])
IWLIST_BIN   = find_bin("iwlist",  ["/usr/sbin/iwlist","/sbin/iwlist","/usr/bin/iwlist"])
WPA_CLI_BIN  = find_bin("wpa_cli", ["/usr/sbin/wpa_cli","/sbin/wpa_cli","/usr/bin/wpa_cli"])
RESOLVECTL_BIN = find_bin("resolvectl", ["/usr/bin/resolvectl","/usr/sbin/resolvectl","/bin/resolvectl"])
PON_BIN      = find_bin("pon",     ["/usr/bin/pon","/sbin/pon"])
POFF_BIN     = find_bin("poff",    ["/usr/bin/poff","/sbin/poff"])



# ======== Terminal ao vivo ========
LOG_DIR = "/var/log/mirako"
os.makedirs(LOG_DIR, exist_ok=True)
TERM_LOG = os.path.join(LOG_DIR, "terminal.log")
RUN = {"proc": None, "pgid": None}
RUN_LOCK = threading.Lock()




# SSID/PASS padrão para modo AP (mantém em sincronia com profiles.sh)
SSID = os.environ.get("SSID") or os.environ.get("AP_SSID") or "MirakoAP"
PASS = os.environ.get("PASS") or os.environ.get("AP_PASS") or "12345678"


RUN_AS_ROOT = (os.geteuid() == 0)

# ======== helpers ========

def _write_line(text):
    try:
        with open(TERM_LOG, "a", encoding="utf-8", errors="ignore") as f:
            f.write(text)
            if not text.endswith("\n"):
                f.write("\n")
    except Exception:
        pass

def _pump_stdout(proc):
    # lê stdout do processo e joga no log
    try:
        for line in iter(proc.stdout.readline, ""):
            _write_line(line.rstrip("\n"))
    except Exception as e:
        _write_line(f"[pump] erro: {e}")
    finally:
        code = proc.wait()
        _write_line(f"\n[processo finalizado] exit={code}")

def start_command(cmd):
    raw = cmd.strip()

    with RUN_LOCK:
        # se já existe, para antes
        if RUN["proc"] is not None and RUN["proc"].poll() is None:
            try:
                os.killpg(RUN["pgid"], signal.SIGINT)
            except Exception:
                try:
                    RUN["proc"].terminate()
                except Exception:
                    pass
        # zera log e registra comando
        with open(TERM_LOG, "w", encoding="utf-8") as f:
            f.write(f"# {time.strftime('%Y-%m-%d %H:%M:%S')} — exec: {raw}\n")

        # inicia processo em novo grupo para poder enviar SIGINT
        proc = subprocess.Popen(
            raw,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1,
            preexec_fn=os.setsid
        )
        RUN["proc"] = proc
        RUN["pgid"] = os.getpgid(proc.pid)

        t = threading.Thread(target=_pump_stdout, args=(proc,), daemon=True)
        t.start()



def stop_command():
    with RUN_LOCK:
        if RUN["proc"] is not None and RUN["proc"].poll() is None:
            try:
                os.killpg(RUN["pgid"], signal.SIGINT)
                _write_line("[SIGINT enviado]")
            except Exception as e:
                _write_line(f"[erro SIGINT] {e}")
                try:
                    RUN["proc"].terminate()
                except Exception:
                    pass

def clear_log():
    try:
        with open(TERM_LOG, "w", encoding="utf-8") as f:
            f.write("")
    except Exception:
        pass

def read_log_tail(max_bytes=120_000):
    try:
        with open(TERM_LOG, "rb") as f:
            f.seek(0, os.SEEK_END)
            size = f.tell()
            off = max(0, size - max_bytes)
            f.seek(off, os.SEEK_SET)
            data = f.read().decode("utf-8", errors="ignore")
            return data
    except Exception:
        return "(sem saída ainda)"


def shell_run(cmd, timeout=12):
    try:
        p = subprocess.run(["bash","-lc", cmd], capture_output=True, text=True, timeout=timeout)
        out = (p.stdout or "") + (("\n"+p.stderr) if p.stderr else "")
        with open(TERM_LOG, "w", encoding="utf-8", errors="ignore") as f:
            f.write(f"$ {cmd}\n{out}")
        return p.returncode, out
    except Exception as e:
        msg = f"erro: {type(e).__name__}: {e}"
        with open(TERM_LOG, "w", encoding="utf-8", errors="ignore") as f:
            f.write(f"$ {cmd}\n{msg}")
        return 1, msg

def read_last_term():
    try:
        with open(TERM_LOG,"r",encoding="utf-8",errors="ignore") as f:
            return f.read()
    except:
        return "(ainda sem comandos)"



def run(cmd, timeout=10):
    try:
        out = subprocess.check_output(cmd, stderr=subprocess.STDOUT, text=True, timeout=timeout)
        return 0, out.strip()
    except subprocess.CalledProcessError as e:
        return e.returncode, (e.output or "").strip()
    except Exception as e:
        return 1, f"{type(e).__name__}: {e}"

def human_bytes(n):
    try: n=float(n)
    except: return str(n)
    units=["B","KB","MB","GB","TB"]; i=0
    while n>=1024 and i < len(units)-1:
        n/=1024.0; i+=1
    return f"{n:.1f} {units[i]}"

# -------- IP / DNS / Interfaces --------
def ensure_iface_up(dev):
    base=f"/sys/class/net/{dev}"
    if not os.path.exists(base): return
    try:
        state=open(os.path.join(base,"operstate")).read().strip().lower()
    except:
        state="unknown"
    if state != "up":
        run([IP_BIN,"link","set","dev",dev,"up"])

def get_ipv4_list(dev):
    rc, out = run([IP_BIN,"-4","addr","show","dev",dev])
    if rc!=0: return "-"
    ips=[]
    for line in out.splitlines():
        line=line.strip()
        if line.startswith("inet "):
            parts=line.split()
            if len(parts)>=2:
                ips.append(parts[1])
    return ", ".join(ips) if ips else "-"

def default_route():
    rc, out = run([IP_BIN,"-4","route","show","default"])
    return out if rc==0 and out else "<sem rota>"

def routes():
    rc, out = run([IP_BIN,"-4","route"])
    return out if rc==0 else f"(erro ip route rc={rc})"

def dns_info():
    # usa resolvectl se existir; senão, resolv.conf
    if os.path.exists(RESOLVECTL_BIN):
        rc, out = run([RESOLVECTL_BIN,"status"], timeout=5)
        if rc==0 and out: return out
    try:
        with open("/etc/resolv.conf","r",encoding="utf-8",errors="ignore") as f:
            return f.read()
    except Exception as e:
        return f"# erro ao ler resolv.conf: {e}"

# -------- DHCP leases (dnsmasq) --------
def read_dnsmasq_leases():
    # caminhos comuns do dnsmasq em Debian
    paths = ["/var/lib/misc/dnsmasq.leases", "/var/lib/dnsmasq/dnsmasq.leases"]
    for path in paths:
        if os.path.exists(path):
            leases=[]
            raw=""
            try:
                raw = open(path, "r", encoding="utf-8", errors="ignore").read()
                for line in raw.splitlines():
                    parts = line.split()
                    # Formato: <expiry> <mac> <ip> <hostname> <client_id>
                    if len(parts) >= 5:
                        expiry, mac, ip, hostname, client_id = parts[:5]
                        try:
                            expi = int(expiry)
                            when = ("infinito" if expi == 0 else time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(expi)))
                        except:
                            when = expiry
                        leases.append({
                            "expiry": when,
                            "mac": mac,
                            "ip": ip,
                            "hostname": hostname if hostname != "*" else "",
                            "client_id": client_id
                        })
            except Exception as e:
                raw = f"(erro ao ler {path}: {e})"
            return leases, raw, path
    return [], "(arquivo de leases não encontrado)", None

# -------- Sistema (CPU temp, CPU %, Mem, Disco) --------
def cpu_temp_c():
    temps=[]; best=None
    for path in glob.glob("/sys/class/thermal/thermal_zone*/temp"):
        try:
            t=int(open(path).read().strip())
            c=t/1000.0 if t>1000 else float(t)
            ttype_path = path.replace("/temp","/type")
            ttype = open(ttype_path).read().strip().lower() if os.path.exists(ttype_path) else ""
            if "cpu" in ttype or "soc" in ttype: best=c
            temps.append(c)
        except: pass
    if best is not None: return best
    if temps: return sum(temps)/len(temps)
    try:
        c=int(open("/sys/class/thermal/thermal_zone0/temp").read().strip())/1000.0
        return c
    except: return None

def cpu_usage_pct(sample_sec=0.2):
    def read():
        with open("/proc/stat","r") as f:
            for line in f:
                if line.startswith("cpu "):
                    parts=line.split()
                    vals=list(map(int, parts[1:]))
                    idle=vals[3] + (vals[4] if len(vals)>4 else 0)
                    total=sum(vals)
                    return idle, total
        return 0,1
    idle1,total1=read(); time.sleep(sample_sec); idle2,total2=read()
    dtotal=total2-total1; didle=idle2-idle1
    if dtotal<=0: return 0.0
    busy = 100.0*(1.0 - (didle/dtotal))
    if busy<0: busy=0.0
    if busy>100*os.cpu_count(): busy=100*os.cpu_count()
    return busy

def mem_stats():
    info={}
    with open("/proc/meminfo","r") as f:
        for line in f:
            k,v = line.split(":",1)
            info[k.strip()] = v.strip()
    def kB(name):
        val=info.get(name,"0").split()[0]
        return int(val)
    total=kB("MemTotal")*1024
    avail=kB("MemAvailable")*1024
    used=total-avail
    pct= (used/total*100.0) if total>0 else 0.0
    return dict(total=total, used=used, avail=avail, pct=pct)

def disk_stats(path="/"):
    du = shutil.disk_usage(path)
    used=du.total-du.free
    pct = used/du.total*100.0 if du.total else 0.0
    return dict(total=du.total, used=used, free=du.free, pct=pct)

# -------- Processos --------
def processes_top(n=20):
    rc, out = run(["ps","-eo","pid,comm,%cpu,%mem","--sort=-%cpu"])
    procs=[]
    if rc==0 and out:
        lines=out.splitlines()
        for line in lines[1:][:n]:
            parts=line.split(None,3)
            if len(parts)==4:
                pid,comm,pcpu,pmem = parts
                procs.append(dict(pid=pid, comm=comm, pcpu=pcpu, pmem=pmem))
    return procs

# -------- Rede (estatísticas) --------
def net_stats_for(dev):
    base=f"/sys/class/net/{dev}"
    if not os.path.exists(base):
        return dict(dev=dev, state="DOWN", ipv4="-", rx="-", tx="-")
    try:
        state=open(os.path.join(base,"operstate")).read().strip().upper()
    except:
        state="?"
    def read_num(p):
        try: return int(open(p).read().strip())
        except: return 0
    rx=read_num(os.path.join(base,"statistics/rx_bytes"))
    tx=read_num(os.path.join(base,"statistics/tx_bytes"))
    return dict(dev=dev, state=state, ipv4=get_ipv4_list(dev),
                rx=human_bytes(rx), tx=human_bytes(tx))

# -------- Wi-Fi --------

def estimate_distance_m(rssi_dbm, freq_mhz):
    """
    Estimativa grosseira via FSPL (free-space). Não é precisa em indoor/multipath.
    d(m) ≈ 10 ^ ((27.55 - 20*log10(f_MHz) + |RSSI|) / 20)
    """
    try:
        return round(10 ** ((27.55 - (20*math.log10(float(freq_mhz))) + abs(float(rssi_dbm))) / 20), 1)
    except Exception:
        return None

def iw_info():
    rc, out = run([IW_BIN, "dev", WLAN_IF, "info"])
    info = {"type":"-", "channel":"-", "freq_mhz":None, "txpower_dbm":"-"}
    if rc==0 and out:
        for ln in out.splitlines():
            s = ln.strip()
            if s.startswith("type "):
                info["type"] = s.split(" ",1)[1].strip()
            elif "channel" in s and "(" in s and "MHz" in s:
                # ex: channel 6 (2437 MHz)
                try:
                    parts = s.split()
                    info["channel"] = parts[1]
                    mhz = s.split("(")[1].split("MHz")[0].strip()
                    info["freq_mhz"] = float(mhz)
                except: pass
            elif s.startswith("txpower "):
                # ex: txpower 20.00 dBm
                try:
                    val = s.split()[1]
                    info["txpower_dbm"] = f"{float(val):.1f} dBm"
                except: pass
    return info

def iw_link():
    """
    STA: retorna SSID/BSSID, RSSI, bitrates, RX/TX acumulados.
    AP: 'Not connected' -> usamos 'station dump' p/ contar clientes.
    """
    rc, out = run([IW_BIN, "dev", WLAN_IF, "link"])
    d = {"connected": False, "ssid":"-", "bssid":"-", "signal_dbm":None,
         "rx_bitrate":"-", "tx_bitrate":"-", "rx":"-", "tx":"-", "clients":0}
    if rc==0 and out:
        if "Not connected." in out:
            # em modo AP contamos estações
            d["connected"] = True
            d["ssid"] = get_ap_ssid()     # ⇐ usar descoberta automática
            rc2, st = run([IW_BIN, "dev", WLAN_IF, "station", "dump"])
            if rc2==0 and st:
                # conta estações conectadas e pega RSSI médio do primeiro, se houver
                clients = 0
                rssi = None
                for ln in st.splitlines():
                    s = ln.strip().lower()
                    if s.startswith("station "):
                        clients += 1
                    if s.startswith("signal:"):
                        try:
                            rssi = float(s.split()[1])  # dBm
                        except: pass
                d["clients"] = clients
                if rssi is not None:
                    d["signal_dbm"] = rssi
            return d
        else:
            d["connected"] = True
            for ln in out.splitlines():
                s = ln.strip()
                if s.startswith("SSID:"):
                    d["ssid"] = s.split(":",1)[1].strip()
                elif s.startswith("Connected to "):
                    d["bssid"] = s.split()[2].strip()
                elif s.startswith("signal:"):
                    try:
                        d["signal_dbm"] = float(s.split()[1])
                    except: pass
                elif s.startswith("rx bitrate:"):
                    d["rx_bitrate"] = s.split(":",1)[1].strip()
                elif s.startswith("tx bitrate:"):
                    d["tx_bitrate"] = s.split(":",1)[1].strip()
                elif s.startswith("RX:"):
                    d["rx"] = s.split(":",1)[1].strip()
                elif s.startswith("TX:"):
                    d["tx"] = s.split(":",1)[1].strip()
    return d
    
    

def get_ap_ssid():
    """
    Tenta descobrir o SSID do AP atual:
    1) Lendo os arquivos temporários do create_ap (hostapd.conf).
    2) Tentando via 'iw dev <if> info' (alguns drivers mostram 'ssid ...').
    3) Cai para o SSID default configurado neste app.
    """
    # 1) create_ap costuma gerar hostapd.conf temporário em /tmp
    for path in glob.glob("/tmp/create_ap*.conf"):
        try:
            txt = open(path, "r", encoding="utf-8", errors="ignore").read()
            m = re.search(r'^\s*ssid\s*=\s*(.+)$', txt, re.M)
            if m:
                return m.group(1).strip()
        except Exception:
            pass

    # 2) alguns drivers mostram ssid em 'iw dev wlan0 info'
    rc, out = run([IW_BIN, "dev", WLAN_IF, "info"])
    if rc == 0 and out:
        for ln in out.splitlines():
            s = ln.strip()
            # ex.: "ssid MirakoAP"
            if s.lower().startswith("ssid "):
                return s.split(None, 1)[1].strip()

    # 3) fallback: variável deste app
    return SSID

    

def iface_byte_counters(dev):
    base=f"/sys/class/net/{dev}/statistics"
    try:
        rx1=int(open(os.path.join(base,"rx_bytes")).read().strip())
        tx1=int(open(os.path.join(base,"tx_bytes")).read().strip())
        time.sleep(0.25)
        rx2=int(open(os.path.join(base,"rx_bytes")).read().strip())
        tx2=int(open(os.path.join(base,"tx_bytes")).read().strip())
        rx_bps=(rx2-rx1)*8*4  # 0.25s -> *4 p/ bps
        tx_bps=(tx2-tx1)*8*4
        return (rx2, tx2, rx_bps, tx_bps)
    except:
        return (0,0,0,0)

def wifi_status_details():
    st = wpa_status()  # já existe no seu código
    ii = iw_info()
    lk = iw_link()
    rxB, txB, rxbps, txbps = iface_byte_counters(WLAN_IF)

    # Monta estrutura para o template
    mode = ii.get("type","-").upper()
    state = st.get("wpa_state","-")
    channel = ii.get("channel","-")
    freq_mhz = ii.get("freq_mhz")
    rssi = lk.get("signal_dbm")
    dist_m = estimate_distance_m(rssi, freq_mhz) if (rssi is not None and freq_mhz) else None

    return {
        "mode": mode, "state": state,
        "ssid": lk.get("ssid","-"),
        "bssid": lk.get("bssid","-"),
        "channel": channel,
        "freq_mhz": (f"{freq_mhz:.0f} MHz" if freq_mhz else "-"),
        "txpower": ii.get("txpower_dbm","-"),
        "rssi": (f"{rssi:.0f} dBm" if rssi is not None else "-"),
        "tx_bitrate": lk.get("tx_bitrate","-"),
        "rx_bitrate": lk.get("rx_bitrate","-"),
        "rx_bytes": human_bytes(rxB),
        "tx_bytes": human_bytes(txB),
        "rx_bps": (f"{rxbps/1e6:.2f} Mbit/s" if rxbps>0 else "0"),
        "tx_bps": (f"{txbps/1e6:.2f} Mbit/s" if txbps>0 else "0"),
        "clients": lk.get("clients",0),
        "distance_m": (f"~{dist_m} m" if dist_m else "-"),
    }

# === tcpdump curto (para UI) ===

def wpa_status():
    rc, out = run([WPA_CLI_BIN,"-i",WLAN_IF,"status"])
    d = {}
    if rc==0:
        for line in out.splitlines():
            if "=" in line:
                k,v = line.split("=",1); d[k]=v
    return d

def wifi_scan():
    ensure_iface_up(WLAN_IF)
    # tenta iw scan
    rc, out = run([IW_BIN,"dev",WLAN_IF,"scan"])
    if rc==0 and out:
        bss=None; nets=[]
        for line in out.splitlines():
            s=line.strip()
            if s.startswith("BSS "):
                if bss: nets.append(bss)
                bss={"ssid":"", "signal":"","freq":"","security":"?"}
            elif s.startswith("SSID:"):
                if bss is None: bss={}
                bss["ssid"]=s[5:].strip()
            elif s.startswith("freq:"):
                if bss is None: bss={}
                bss["freq"]=s[5:].strip()
            elif s.startswith("signal:"):
                if bss is None: bss={}
                bss["signal"]=s[7:].strip()
            elif s.startswith("RSN:") or s.startswith("WPA:"):
                if bss is None: bss={}
                bss["security"]="WPA/WPA2"
        if bss: nets.append(bss)
        nets=[n for n in nets if n.get("ssid")]
        uniq={}
        for n in nets:
            ssid=n["ssid"]
            if ssid not in uniq or (n.get("signal","") > uniq[ssid].get("signal","")):
                uniq[ssid]=n
        return list(uniq.values()), None
    # fallback iwlist
    rc2, out2 = run([IWLIST_BIN, WLAN_IF, "scan"])
    if rc2==0 and out2:
        blocks = out2.split("Cell ")
        nets=[]
        for b in blocks:
            ssid = re.search(r'ESSID:"(.*)"', b)
            qual = re.search(r"Signal level=(-?\d+)", b) or re.search(r"Quality=([0-9/]+)", b)
            freq = re.search(r"Frequency:([0-9\.]+)", b)
            enc  = "Open" if "Encryption key:off" in b else "WPA/WPA2"
            if ssid:
                nets.append({"ssid":ssid.group(1), "signal": (qual.group(1) if qual else "?"),
                             "freq": (freq.group(1) if freq else "?"), "security": enc})
        return nets, None
    return [], f"iw rc={rc} out={out} | iwlist rc={rc2} out={out2}"

def wifi_connect(ssid, psk=None):
    # garante wpa_supplicant@wlan0
    rc_svc, _ = run(["systemctl","is-active",f"wpa_supplicant@{WLAN_IF}.service"])
    if rc_svc != 0:
        return False, "wpa_supplicant não está ativo (use o perfil Cliente Wi-Fi)."

    # cria/seleciona rede
    rc, out = run([WPA_CLI_BIN,"-i",WLAN_IF,"list_networks"])
    existing_id=None
    if rc==0 and out:
        for line in out.splitlines():
            parts=line.split("\t")
            if len(parts)>=2 and parts[1]==ssid:
                existing_id=parts[0]; break
    if existing_id is None:
        rc, out = run([WPA_CLI_BIN,"-i",WLAN_IF,"add_network"])
        if rc!=0: return False, f"add_network falhou: {out}"
        existing_id = out.strip()

    rc1, out1 = run([WPA_CLI_BIN,"-i",WLAN_IF,"set_network",existing_id,"ssid", f"\"{ssid}\""])
    if rc1!=0: return False, f"set ssid falhou: {out1}"
    if psk and psk.strip():
        rc2, out2 = run([WPA_CLI_BIN,"-i",WLAN_IF,"set_network",existing_id,"psk", f"\"{psk}\""])
    else:
        rc2, out2 = run([WPA_CLI_BIN,"-i",WLAN_IF,"set_network",existing_id,"key_mgmt","NONE"])
    if rc2!=0: return False, f"config segurança falhou: {out2}"

    rc3, out3 = run([WPA_CLI_BIN,"-i",WLAN_IF,"enable_network",existing_id])
    rc4, out4 = run([WPA_CLI_BIN,"-i",WLAN_IF,"select_network",existing_id])
    run([WPA_CLI_BIN,"-i",WLAN_IF,"save_config"])
    run([WPA_CLI_BIN,"-i",WLAN_IF,"reassociate"])
    if not (rc3==0 and rc4==0):
        return False, ("; ".join([out3,out4])).strip()

    # espera associação
    deadline = time.time() + 30
    last_state = ""
    while time.time() < deadline:
        st = wpa_status()
        last_state = st.get("wpa_state","")
        if last_state == "COMPLETED":
            break
        time.sleep(1)
    if last_state != "COMPLETED":
        return False, f"associação não completou (estado={last_state or 'desconhecido'})"

    # DHCP
    run(["dhclient","-r",WLAN_IF])
    rc_dh, out_dh = run(["dhclient",WLAN_IF], timeout=25)

    ip = get_ipv4_list(WLAN_IF)
    if ip == "-" or rc_dh != 0:
        return False, f"associou, mas sem IP (dhclient rc={rc_dh}) {out_dh}"

    # DNS + rota default com gateway a partir do lease
    routers, dns = parse_dhclient_lease(WLAN_IF)
    if routers:
        ensure_default_via(routers[0], WLAN_IF)
    if dns:
        apply_dns(dns)

    return True, f"conectado com IP {ip}; GW={routers[0] if routers else '?'}; DNS={', '.join(dns) if dns else '?'}"


def wifi_disconnect():
    rc, out = run([WPA_CLI_BIN,"-i",WLAN_IF,"disconnect"])
    return (rc==0, out)

def profile_set(profile):
    return run([PROFILES_SCRIPT, profile], timeout=90)

def modem_connect():
    # mata pppd antigo, limpa locks
    run(["pkill","-x","pppd"])
    run(["rm","-f","/var/lock/LCK..ttyUSB*"])
    # dispara pppd call 3g (daemoniza)
    try:
        p = subprocess.Popen([PPPD_BIN, "call", PPP_PEER],
                             stdout=subprocess.DEVNULL,
                             stderr=subprocess.STDOUT)
    except Exception as e:
        return False, f"erro ao iniciar pppd: {e}"

    # espera até 20s pelo ppp0 subir
    deadline = time.time() + 20
    up = False
    while time.time() < deadline:
        rc, _ = run([IP_BIN,"link","show",PPP_IF])
        if rc == 0:
            up = True
            break
        time.sleep(1.0)

    if up:
        return True, "pppd call enviado e ppp0 ativo"
    else:
        # coleta logs breves do pppd/chat pra mostrar na UI
        rc1, j1 = run(["journalctl","-b","-n","50","--no-pager"])
        last = []
        if rc1 == 0 and j1:
            for ln in j1.splitlines():
                if ("pppd" in ln.lower()) or ("chat" in ln.lower()):
                    last.append(ln)
        msg = "ppp0 não subiu. "
        if last:
            msg += "Logs recentes: " + ("\n".join(last[-8:]))
        else:
            msg += "Sem logs do pppd/chat."
        return False, msg

def modem_disconnect():
    rc, out = run([POFF_BIN, PPP_PEER], timeout=20)
    msg = (out or "").strip()
    if rc != 0 and ("No pppd is running" in msg or "None stopped" in msg):
        return True, "pppd já estava parado"
    if rc != 0:
        run(["pkill","-x","pppd"])
        run(["rm","-f","/var/lock/LCK..ttyUSB*"])
        return True, "pppd finalizado"
    return True, msg or "poff enviado"


# -------- dmesg --------
def get_dmesg():
    # tenta com -T (timestamps legíveis); se não suportar, cai para sem -T
    rc, out = run(["dmesg", "-T"], timeout=10)
    if rc == 0 and out: 
        return out
    rc2, out2 = run(["dmesg"], timeout=10)
    return out2 if rc2 == 0 else f"(falha ao obter dmesg: rc={rc} / rc2={rc2})"

# ======== Template ========
TEMPLATE = """
<!doctype html>
<html lang="pt-br" data-bs-theme="dark">
  <head>
    <meta charset="utf-8">
    <title>Mirako — Orange Pi Router</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
      pre{white-space:pre-wrap;word-wrap:break-word}
      .ssid-row{cursor:pointer}
      .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,'Liberation Mono',monospace}
      .scroll{max-height:50vh; overflow:auto}
    </style>
  </head>
  <body class="bg-body text-body">
    <nav class="navbar navbar-expand-lg bg-dark border-bottom border-secondary mb-4">
      <div class="container">
        <span class="navbar-brand">Mirako Router</span>
        <span class="navbar-text small">Orange Pi Zero 3 — Debian 12</span>
      </div>
    </nav>

    <div class="container">
      {% with messages = get_flashed_messages() %}
        {% if messages %}
          {% for msg in messages %}
            <div class="alert alert-info alert-dismissible fade show" role="alert">
              {{ msg }} <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Fechar"></button>
            </div>
          {% endfor %}
        {% endif %}
      {% endwith %}

      <div class="row g-3">
        <!-- Perfis -->
        <div class="col-12 col-lg-4">
          <div class="card h-100">
            <div class="card-header">Perfis de operação</div>
            <div class="card-body">
  <form method="post" action="{{ url_for('setprofile') }}" class="d-grid gap-2">
  <button class="btn btn-primary" name="profile" value="ap">Roteador AP (WAN={{LAN_IF}} → AP em {{WLAN_IF}})</button>
  <button class="btn btn-primary" name="profile" value="3g">Roteador 3G PPP (WAN={{PPP_IF}} → AP/LAN)</button>
  <button class="btn btn-primary" name="profile" value="client-wifi">Cliente Wi-Fi (WAN={{WLAN_IF}} → LAN {{LAN_IF}})</button>
  <button class="btn btn-secondary" name="profile" value="client-lan">Cliente LAN (WAN={{LAN_IF}}; Wi-Fi liberado p/ scan)</button>
</form>

            </div>
          </div>
        </div>

        <!-- Wi-Fi -->
         <!-- Wi-Fi -->
        <div class="col-12 col-lg-8">
          <div class="card h-100">
            <div class="card-header d-flex justify-content-between align-items-center">
              <span>Wi‑Fi ({{WLAN_IF}})</span>
              <div class="d-flex gap-2">
                <form method="post" action="{{ url_for('wifi_scan_route') }}"><button class="btn btn-sm btn-outline-light">Escanear redes</button></form>
              </div>
            </div>
            <div class="card-body">
              <!-- STATUS DETALHADO -->
              <div class="row g-3">
                <div class="col-sm-4">
                  <div class="small text-secondary">Modo / Estado</div>
                  <div class="fs-6">{{ wifi.mode }} / {{ wifi.state }}</div>
                </div>
                <div class="col-sm-4">
                  <div class="small text-secondary">SSID / BSSID</div>
                  <div class="fs-6 mono">{{ wifi.ssid }}<br><span class="small">{{ wifi.bssid }}</span></div>
                </div>
                <div class="col-sm-4">
                  <div class="small text-secondary">Canal / Freq / TX pwr</div>
                  <div class="fs-6">{{ wifi.channel }} / {{ wifi.freq_mhz }} / {{ wifi.txpower }}</div>
                </div>

                <div class="col-sm-3">
                  <div class="small text-secondary">RSSI</div>
                  <div class="fs-6">{{ wifi.rssi }}</div>
                </div>
                <div class="col-sm-3">
                  <div class="small text-secondary">Distância (estim.)</div>
                  <div class="fs-6">{{ wifi.distance_m }}</div>
                </div>
                <div class="col-sm-3">
                  <div class="small text-secondary">Bitrate TX / RX</div>
                  <div class="fs-6">{{ wifi.tx_bitrate }} / {{ wifi.rx_bitrate }}</div>
                </div>
                <div class="col-sm-3">
                  <div class="small text-secondary">Clientes (se AP)</div>
                  <div class="fs-6">{{ wifi.clients }}</div>
                </div>

                <div class="col-sm-6">
                  <div class="small text-secondary">Tráfego (bytes)</div>
                  <div class="fs-6">TX: {{ wifi.tx_bytes }} — RX: {{ wifi.rx_bytes }}</div>
                </div>
                <div class="col-sm-6">
                  <div class="small text-secondary">Taxa instantânea</div>
                  <div class="fs-6">TX: {{ wifi.tx_bps }} — RX: {{ wifi.rx_bps }}</div>
                </div>
              </div>

              <hr>
              <!-- Form de conexão STA -->
              <form class="row gy-2 gx-2 align-items-end" method="post" action="{{ url_for('wifi_connect_route') }}">
                <div class="col-sm-5"><label class="form-label">SSID</label><input type="text" class="form-control" name="ssid" id="ssidField" required></div>
                <div class="col-sm-5"><label class="form-label">Senha (vazio = rede aberta)</label><input type="password" class="form-control" name="psk" autocomplete="off"></div>
                <div class="col-sm-2 d-grid"><button class="btn btn-success">Conectar</button></div>
              </form>
              <form method="post" action="{{ url_for('wifi_disconnect_route') }}" class="mt-2"><button class="btn btn-outline-warning btn-sm">Desconectar Wi‑Fi</button></form>

              {% if scan %}
              <hr>
              <div class="table-responsive">
                <table class="table table-sm table-hover align-middle">
                  <thead><tr><th>SSID</th><th>Signal</th><th>Freq</th><th>Segurança</th></tr></thead>
                  <tbody>
                  {% for n in scan %}
                    <tr class="ssid-row" data-ssid="{{ n.ssid|e }}" onclick="document.getElementById('ssidField').value=this.dataset.ssid;">
                      <td class="mono">{{n.ssid}}</td><td>{{n.signal}}</td><td>{{n.freq}}</td><td>{{n.security}}</td>
                    </tr>
                  {% endfor %}
                  </tbody>
                </table>
              </div>
              {% elif scan_dbg %}
                <div class="alert alert-secondary mt-3"><small>{{ scan_dbg }}</small></div>
              {% endif %}
            </div>
          </div>
        </div>


        <!-- Modem 3G -->
        <div class="col-12 col-lg-4">
          <div class="card h-100">
            <div class="card-header">Modem 3G/PPP ({{PPP_IF}})</div>
            <div class="card-body">
              <div class="d-grid gap-2">
<form method="post" action="{{ url_for('modem_connect_route') }}">
  <button class="btn btn-success">Conectar modem (pppd call {{PPP_PEER}})</button>
</form>

                <form method="post" action="{{ url_for('modem_disconnect_route') }}"><button class="btn btn-outline-warning">Desconectar modem (poff {{PPP_PEER}})</button></form>
              </div>
              <hr>
              <div class="small text-secondary">IPv4 ({{PPP_IF}})</div>
              <pre class="mono">{{ ppp_ipv4 }}</pre>
            </div>
          </div>
        </div>

        <!-- SISTEMA -->
        <div class="col-12 col-lg-8">
          <div class="card h-100">
            <div class="card-header">Sistema</div>
            <div class="card-body">
              <div class="row g-3">
                <div class="col-md-3"><div class="small text-secondary">Temp CPU</div><div class="fs-5">{{ cpu_temp }}</div></div>
                <div class="col-md-3"><div class="small text-secondary">Uso CPU</div><div class="fs-5">{{ cpu_pct }}%</div></div>
                <div class="col-md-3"><div class="small text-secondary">Memória</div><div class="fs-6">{{ mem_used }} / {{ mem_total }} ({{ mem_pct }}%)</div></div>
                <div class="col-md-3"><div class="small text-secondary">Disco (/)</div><div class="fs-6">{{ disk_used }} / {{ disk_total }} ({{ disk_pct }}%)</div></div>
              </div>
            </div>
          </div>
        </div>

        <!-- REDE -->
        <div class="col-12">
          <div class="card h-100">
            <div class="card-header">Rede (estatísticas por interface)</div>
            <div class="card-body">
              <div class="table-responsive">
                <table class="table table-sm table-hover align-middle">
                  <thead><tr><th>Interface</th><th>Estado</th><th>IPv4</th><th>RX</th><th>TX</th></tr></thead>
                  <tbody>
                    {% for n in netlist %}
                      <tr><td class="mono">{{ n.dev }}</td><td>{{ n.state }}</td><td class="mono">{{ n.ipv4 }}</td><td>{{ n.rx }}</td><td>{{ n.tx }}</td></tr>
                    {% endfor %}
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>

        <!-- ROTAS & DNS & DHCP -->
        <div class="col-12">
          <div class="card h-100">
            <div class="card-header">Rotas & DNS & DHCP</div>
            <div class="card-body">
              <div class="row g-3">
                <div class="col-md-4">
                  <div class="small text-secondary">Rota padrão</div>
                  <pre class="mono">{{ def_route }}</pre>
                  <div class="small text-secondary mt-2">Rotas</div>
                  <pre class="mono">{{ all_routes }}</pre>
                </div>
                <div class="col-md-4">
                  <div class="small text-secondary">DNS</div>
                  <pre class="mono">{{ dns }}</pre>
                </div>
                <div class="col-md-4">
                  <div class="small text-secondary">DHCP Leases{% if leases_path %} ({{ leases_path }}){% endif %}</div>
                  {% if leases and leases|length>0 %}
                  <div class="table-responsive">
                    <table class="table table-sm table-hover align-middle">
                      <thead><tr><th>IP</th><th>Host</th><th>MAC</th><th>Expira</th></tr></thead>
                      <tbody>
                        {% for L in leases %}
                          <tr>
                            <td class="mono">{{ L.ip }}</td>
                            <td class="mono">{{ L.hostname or "-" }}</td>
                            <td class="mono">{{ L.mac }}</td>
                            <td class="mono">{{ L.expiry }}</td>
                          </tr>
                        {% endfor %}
                      </tbody>
                    </table>
                  </div>
                  {% else %}
                    <pre class="mono">Sem leases ou arquivo não encontrado.</pre>
                  {% endif %}
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- LOG: DMESG -->
<!-- TERMINAL AO VIVO -->
<div class="col-12" id="terminal_card">
  <div class="card">
    <div class="card-header d-flex justify-content-between align-items-center">
      <span>Terminal ao vivo</span>
      <div class="d-flex flex-wrap gap-2">
        <button type="button" class="btn btn-sm btn-outline-primary" onclick="prefill('dmesg -wT')">dmesg </button>
        <button type="button" class="btn btn-sm btn-outline-primary" onclick="prefill('top -b')">top</button>
        <button type="button" class="btn btn-sm btn-outline-info" onclick="prefill('tcpdump -i {{WLAN_IF}} -n -vv -s 120')">tcpdump ({{WLAN_IF}})</button>
        <button type="button" class="btn btn-sm btn-warning" onclick="stopCmd()">Ctrl+C</button>
        <button type="button" class="btn btn-sm btn-secondary" onclick="clearLog()">Limpar</button>
        <button type="button" class="btn btn-sm btn-danger" onclick="rebootConfirm()">Reiniciar</button>
      </div>
    </div>
    <div class="card-body">
      <!-- Terminal -->
      <div id="terminal_wrap" class="mono" style="background:#0b0d10;border:1px solid #222;border-radius:.25rem;padding:.5rem;height:50vh;overflow:auto;">
        <pre id="terminal_out" class="mono m-0" style="color:#d6d6d6;white-space:pre-wrap;"></pre>
      </div>

      <!-- Input embaixo -->
<!-- Input do terminal com botão ao lado -->
<div class="input-group mt-2">
  <span class="input-group-text" style="background:#151a1f;color:#9ad;">$</span>
  <input id="terminal_cmd" class="form-control" placeholder="Digite um comando e pressione Enter">
  <button class="btn btn-success" type="button" id="terminal_run_btn" title="Executar (Enter)">Enter</button>
</div>

      <div class="form-text">Dica: para usar o top ao vivo aqui, basta digitar <code>top</code> — eu ativo <code>-b</code> automaticamente.</div>
    </div>
  </div>
</div>




      </div><!-- row -->
      <div class="py-4"></div>
    </div><!-- container -->

<!-- tenta CDN -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-ENjdO4Dr2bkBIFxQpeoDGLVYI3GXx3E4p+3nZl5Mq9UOz1pENhb4u91WTrQF3R9F"
        crossorigin="anonymous"
        onerror="loadLocalBootstrap()"></script>

<!-- função fallback -->
<script>
function loadLocalBootstrap() {
  var s = document.createElement('script');
  s.src = '/static/js/bootstrap.bundle.min.js';
  document.head.appendChild(s);
  console.warn('Bootstrap CDN indisponível, carregando versão local...');
}
</script>


<script>
  // ===== ANSI → HTML =====
  // Conversão simples de sequências ANSI para spans coloridos.
  // Não é 100% completa, mas cobre as cores mais comuns.
  function ansiToHtml(text) {
    // escape HTML primeiro
    text = text
      .replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");

    // mapeamento básico de cores
    const colors = {
      30: 'color:#777;', 31: 'color:#ff6b6b;', 32: 'color:#9be564;', 33: 'color:#ffd166;',
      34: 'color:#6ab0ff;',35: 'color:#d785ff;', 36: 'color:#74d3ea;', 37: 'color:#eeeeee;',
      90: 'color:#999;',   91: 'color:#ff7b7b;', 92: 'color:#a8f07a;', 93: 'color:#ffe07a;',
      94: 'color:#7abaff;',95: 'color:#e19bff;', 96: 'color:#85e9ff;', 97: 'color:#ffffff;'
    };
    const bg = {
      40: 'background:#222;', 41: 'background:#5c1e1e;', 42: 'background:#294025;', 43: 'background:#4a3f1d;',
      44: 'background:#1c2e4a;',45:'background:#3a2143;',46:'background:#1f3f45;', 47: 'background:#444;',
      100:'background:#333;',101:'background:#6b2a2a;',102:'background:#35552e;',103:'background:#5a4d24;',
      104:'background:#253c66;',105:'background:#4a2d54;',106:'background:#28545b;',107:'background:#666;'
    };

    // substitui códigos SGR: \x1b[...m
    return text.replace(/\x1b\[(\d+(?:;\d+)*)m/g, (m, seq) => {
      const codes = seq.split(';').map(Number);
      if (codes.includes(0)) return '</span>'; // reset
      let style = '';
      codes.forEach(c => {
        if (c === 1) style += 'font-weight:bold;';
        else if (c === 3) style += 'font-style:italic;';
        else if (c === 4) style += 'text-decoration:underline;';
        else if (colors[c]) style += colors[c];
        else if (bg[c]) style += bg[c];
        else if (c === 39) style += 'color:inherit;';
        else if (c === 49) style += 'background:transparent;';
      });
      return `<span style="${style}">`;
    });
  }

  // ===== Terminal live =====
  let polling = null;
  let didInitialScroll = false;
  let userScrolledUp = false; // se o usuário rolar, não empurramos mais

  function prefill(cmd) {
    const el = document.getElementById('terminal_cmd');
    if (el) { el.value = cmd; el.focus(); }
    const anchor = document.getElementById('terminal_card') || el;
    if (anchor) anchor.scrollIntoView({behavior:'smooth', block:'center'});
  }

  async function pullLog() {
    try {
      const r = await fetch('/shell/log?ts=' + Date.now());
      const txt = await r.text();
      const out = document.getElementById('terminal_out');
      const wrap = document.getElementById('terminal_wrap');
      if (out && wrap) {
        // mantém posição se o usuário subiu; caso contrário, apenas na 1ª vez rola ao fim
        const atBottom = (wrap.scrollTop + wrap.clientHeight) >= (wrap.scrollHeight - 10);

        out.innerHTML = ansiToHtml(txt);

        if (!didInitialScroll) {
          wrap.scrollTop = wrap.scrollHeight;
          didInitialScroll = true; // só uma vez
        } else if (atBottom && !userScrolledUp) {
          // se o usuário estava no fim, deixamos no fim
          wrap.scrollTop = wrap.scrollHeight;
        }
      }
    } catch (e) { /* ignora */ }
  }

  function startPolling() {
    if (polling) clearInterval(polling);
    pullLog();
    polling = setInterval(pullLog, 900);
  }

  // Detectar rolagem manual: se o usuário rolar para cima, não empurra mais
  (function(){
    const wrap = document.getElementById('terminal_wrap');
    if (!wrap) return;
    wrap.addEventListener('scroll', () => {
      const nearBottom = (wrap.scrollTop + wrap.clientHeight) >= (wrap.scrollHeight - 10);
      userScrolledUp = !nearBottom;
    });
  })();

  async function runCmdFromInput() {
    const el = document.getElementById('terminal_cmd');
    const cmd = (el && el.value) ? el.value.trim() : '';
    if (!cmd) return;
    await fetch('/shell/run', {
      method: 'POST',
      headers: {'Content-Type':'application/x-www-form-urlencoded'},
      body: new URLSearchParams({cmd})
    });
    // após iniciar um novo comando, consideramos primeira rolagem novamente
    didInitialScroll = false;
    userScrolledUp = false;
    startPolling();
  }

  async function stopCmd() {
    await fetch('/shell/stop', {method:'POST'});
  }

  async function clearLog() {
    await fetch('/shell/clear', {method:'POST'});
    const out = document.getElementById('terminal_out');
    if (out) out.innerHTML = '';
    didInitialScroll = false;
    userScrolledUp = false;
  }

  async function rebootConfirm() {
    if (!confirm('Reiniciar agora?')) return;
    await fetch('/reboot', {method:'POST'});
    alert('Reiniciando...');
  }

  // Enter para executar
 (function(){
    const el = document.getElementById('terminal_cmd');
    if (!el) return;
    el.addEventListener('keydown', (ev) => {
      if (ev.key === 'Enter') {
        ev.preventDefault();
        runCmdFromInput();
      }
    });
  })();

  // Botão "Enter" chama o mesmo handler
  (function(){
    const btn = document.getElementById('terminal_run_btn');
    if (!btn) return;
    btn.addEventListener('click', (ev) => {
      ev.preventDefault();
      runCmdFromInput();
    });
  })();

  // Inicia polling (apenas para ver logs existentes, sem forçar rolagem depois)
  startPolling();
</script>


  </body>
</html>
"""

# ======== Rotas ========

@app.route("/", methods=["GET"])
def index():
    t = cpu_temp_c()
    cpu_pct = round(cpu_usage_pct(),1)
    mem = mem_stats()
    disk = disk_stats("/")
    netlist=[net_stats_for(i) for i in list_interfaces(include_virtual=True, include_lo=True)]
    leases, leases_raw, leases_path = read_dnsmasq_leases()
    dmesg_txt = get_dmesg()

    context = dict(
        WLAN_IF=WLAN_IF, LAN_IF=LAN_IF, PPP_IF=PPP_IF, PPP_PEER=PPP_PEER,
        scan=[], scan_dbg=None, wstatus=wpa_status(),
        wifi=wifi_status_details(),
        wlan_ipv4=get_ipv4_list(WLAN_IF), ppp_ipv4=get_ipv4_list(PPP_IF),
        def_route=default_route(), all_routes=routes(), dns=dns_info(),
        leases=leases, leases_path=leases_path,
        dmesg=dmesg_txt,
        last_term = read_last_term(),
        cpu_temp = (f"{t:.1f} °C" if t is not None else "-"),
        cpu_pct = cpu_pct,
        mem_used = human_bytes(mem["used"]), mem_total = human_bytes(mem["total"]), mem_pct = f"{mem['pct']:.1f}",
        disk_total = human_bytes(disk["total"]), disk_used  = human_bytes(disk["used"]), disk_pct = f"{disk['pct']:.1f}",
        procs = processes_top(20),
        netlist = netlist,

    )
    return render_template_string(TEMPLATE, **context)

@app.post("/wifi/scan")
def wifi_scan_route():
    nets, dbg = wifi_scan()
    t = cpu_temp_c()
    cpu_pct = round(cpu_usage_pct(),1)
    mem = mem_stats()
    disk = disk_stats("/")
    netlist=[net_stats_for(i) for i in list_interfaces(include_virtual=True, include_lo=True)]
    leases, leases_raw, leases_path = read_dnsmasq_leases()
    dmesg_txt = get_dmesg()
    context = dict(
        WLAN_IF=WLAN_IF, LAN_IF=LAN_IF, PPP_IF=PPP_IF, PPP_PEER=PPP_PEER,
        scan=nets, scan_dbg=dbg, wstatus=wpa_status(),
        wifi=wifi_status_details(),
        wlan_ipv4=get_ipv4_list(WLAN_IF), ppp_ipv4=get_ipv4_list(PPP_IF),
        def_route=default_route(), all_routes=routes(), dns=dns_info(),
        leases=leases, leases_path=leases_path,
        dmesg=dmesg_txt,
        cpu_temp = (f"{t:.1f} °C" if t is not None else "-"),
        cpu_pct = cpu_pct,
        mem_used = human_bytes(mem["used"]), mem_total = human_bytes(mem["total"]), mem_pct = f"{mem['pct']:.1f}",
        disk_total = human_bytes(disk["total"]), disk_used  = human_bytes(disk["used"]), disk_pct = f"{mem['pct']:.1f}",
        procs = processes_top(20),
        netlist = netlist,
    )
    return render_template_string(TEMPLATE, **context)


@app.post("/wifi/connect")
def wifi_connect_route():
    ssid = (request.form.get("ssid") or "").strip()
    psk  = (request.form.get("psk") or "").strip()
    if not ssid:
        flash("Informe um SSID.")
        return redirect(url_for("index"))
    ok, msg = wifi_connect(ssid, psk if psk else None)
    flash(("Conectado" if ok else "Falha") + f" ({msg})")
    return redirect(url_for("index"))

@app.post("/wifi/disconnect")
def wifi_disconnect_route():
    ok, msg = wifi_disconnect()
    flash(("Desconectado" if ok else "Falha") + f" ({msg})")
    return redirect(url_for("index"))

@app.post("/setprofile")
def setprofile():
    profile = request.form.get("profile","").strip()
    rc, out = profile_set(profile)
    # salva o último perfil se rodou (independente do rc)
    try:
        os.makedirs("/var/lib/mirako", exist_ok=True)
        with open("/var/lib/mirako/last_profile","w",encoding="utf-8") as f:
            f.write(profile.strip() or "ap")
            f.flush(); os.fsync(f.fileno())
            os.sync()
    except Exception as e:
        pass
    flash(out if out else ("ok" if rc==0 else "erro"))
    return redirect(url_for("index"))

@app.post("/modem/connect")
def modem_connect_route():
    ok, msg = modem_connect()
    flash(("pon enviado" if ok else "Falha") + f" ({msg})")
    return redirect(url_for("index"))

@app.post("/modem/disconnect")
def modem_disconnect_route():
    ok, msg = modem_disconnect()
    flash(("poff enviado" if ok else "Falha") + f" ({msg})")
    return redirect(url_for("index"))
    
    
    
@app.post("/term/run")
def term_run():
    cmd = (request.form.get("cmd") or "").strip()
    if not cmd:
        flash("Informe um comando.")
        return redirect(url_for("index"))
    rc, _ = shell_run(cmd)
    flash(f"Terminal: rc={rc}")
    return redirect(url_for("index"))
    
@app.post("/shell/run")
def shell_run():
    cmd = (request.form.get("cmd") or (request.json.get("cmd") if request.is_json else "") or "").strip()
    if not cmd:
        return {"ok": False, "err": "comando vazio"}, 400
    start_command(cmd)
    return {"ok": True}

@app.get("/shell/log")
def shell_log():
    return app.response_class(read_log_tail(), mimetype="text/plain; charset=utf-8")

@app.post("/shell/stop")
def shell_stop():
    stop_command()
    return {"ok": True}

@app.post("/shell/clear")
def shell_clear():
    clear_log()
    return {"ok": True}

@app.post("/reboot")
def shell_reboot():
    # reinicia a máquina
    try:
        subprocess.Popen(["/sbin/shutdown", "-r", "now"])
    except Exception:
        try:
            subprocess.Popen(["/sbin/reboot"])
        except Exception as e:
            return {"ok": False, "err": str(e)}, 500
    return {"ok": True}
    
# -------- Lista de interfaces dinâmicas --------
def list_interfaces(include_virtual=True, include_lo=True):
    """
    Retorna a lista de interfaces reais do sistema.
    - include_virtual=False oculta coisas como veth/docker/virbr/bridge.
    - include_lo=False oculta a loopback.
    Mantém tun/tap/ppp e enx/end/wlan, que costumam ser úteis.
    """
    try:
        names = sorted(os.listdir("/sys/class/net"))
    except Exception:
        names = []
    skip_prefix = ("veth", "br-", "docker", "virbr", "vmnet", "vnet", "zt")
    out = []
    for n in names:
        if not include_lo and n == "lo":
            continue
        if not include_virtual and n.startswith(skip_prefix):
            continue
        out.append(n)
    return out
    
def parse_dhclient_lease(iface):
    path = f"/var/lib/dhcp/dhclient.{iface}.leases"
    routers, dns = [], []
    try:
        import re
        if os.path.exists(path):
            txt = open(path, "r", encoding="utf-8", errors="ignore").read()
            # pega a ÚLTIMA ocorrência
            m_dns = re.findall(r'option\s+domain-name-servers\s+([^;]+);', txt)
            m_rtr = re.findall(r'option\s+routers\s+([^;]+);', txt)
            if m_dns:
                # separa por vírgula/espaço
                dns = [i.strip() for i in re.split(r'[,\s]+', m_dns[-1].strip()) if i.strip()]
            if m_rtr:
                routers = [i.strip() for i in re.split(r'[,\s]+', m_rtr[-1].strip()) if i.strip()]
    except Exception:
        pass
    return routers, dns

def apply_dns(nameservers):
    try:
        # se for symlink do NetworkManager, substitui por arquivo real
        if os.path.islink("/etc/resolv.conf"):
            os.unlink("/etc/resolv.conf")
        with open("/etc/resolv.conf","w",encoding="utf-8") as f:
            f.write("# Generated by Mirako client-wifi\n")
            for ns in nameservers:
                if ns:
                    f.write(f"nameserver {ns}\n")
        return True, "resolv.conf atualizado"
    except Exception as e:
        return False, f"erro ao escrever resolv.conf: {e}"

def ensure_default_via(gw, dev):
    # força a rota default a ter 'via <gw>'
    if gw:
        run([IP_BIN,"route","replace","default","via",gw,"dev",dev])
    
    


if __name__ == "__main__":
    # Rodando como root: sem sudo/sudoers e sem capabilities extras
    app.run(host="0.0.0.0", port=80)
EOF

sudo systemctl restart mirako-web






sudo tee /etc/wpa_supplicant/wpa_supplicant-wlan0.conf >/dev/null <<'EOF'
ctrl_interface=/var/run/wpa_supplicant
update_config=1
country=BR
ap_scan=1
# redes serão adicionadas pela sua UI via wpa_cli (save_config grava aqui)
EOF

sudo systemctl enable --now wpa_supplicant@wlan0.service






sudo tee /etc/systemd/system/mirako-web.service >/dev/null <<'EOF'
[Unit]
Description=Interface web de configuração do roteador
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
User=root
Group=root
WorkingDirectory=/opt/mirako_web
Environment=PYTHONUNBUFFERED=1
ExecStart=/usr/bin/python3 /opt/mirako_web/web_config.py
Restart=on-failure

[Install]
WantedBy=multi-user.target
EOF


sudo systemctl daemon-reload
sudo systemctl enable --now mirako-web.service


sudo systemctl restart mirako-web






sudo tee /usr/local/bin/mirako-autoboot.sh >/dev/null <<'EOF'
#!/usr/bin/env bash
set -Eeuo pipefail

PROFILE_FILE=/var/lib/mirako/last_profile
DEF=ap
want="$(cat "$PROFILE_FILE" 2>/dev/null || echo "$DEF")"

export WLAN_IF="${WLAN_IF:-wlan0}"
export LAN_IF="${LAN_IF:-end0}"
export PPP_IF="${PPP_IF:-ppp0}"
export PPP_PEER="${PPP_PEER:-3g}"
export PROFILES_SCRIPT="${PROFILES_SCRIPT:-/usr/local/bin/profiles.sh}"

log(){ echo "[autoboot] $*"; }

lan_has_link(){
  [ -r "/sys/class/net/$LAN_IF/carrier" ] && [ "$(cat /sys/class/net/$LAN_IF/carrier 2>/dev/null)" = "1" ]
}

ensure_wpa_running(){
  if ! systemctl is-active --quiet "wpa_supplicant@${WLAN_IF}.service"; then
    log "iniciando wpa_supplicant@${WLAN_IF}.service"
    systemctl start "wpa_supplicant@${WLAN_IF}.service" || true
  fi
}

wifi_state(){
  command -v wpa_cli >/dev/null 2>&1 || { echo "DOWN"; return; }
  wpa_cli -i "$WLAN_IF" status 2>/dev/null | sed -n 's/^wpa_state=//p'
}

wait_wifi_connected(){
  # Espera associação COMPLETED e IPv4 (tenta DHCP). Timeout padrão 75s.
  local timeout="${1:-75}"
  local end=$((SECONDS+timeout))
  local associated=0
  while [ $SECONDS -lt $end ]; do
    st="$(wifi_state)"
    if [ "$st" = "COMPLETED" ]; then
      associated=1
      wlan_has_ipv4 && return 0
      try_dhcp_wlan
      sleep 2
      wlan_has_ipv4 && return 0
    else
      sleep 1
    fi
  done
  # Se associou mas não pegou IP, ainda assim considere “meio-ok”
  [ "$associated" = "1" ]
}


ppp_connectivity(){
  ip -4 addr show dev "$PPP_IF" | grep -q 'inet ' || return 1
  ping -I "$PPP_IF" -c2 -W3 8.8.8.8 >/dev/null 2>&1
}

wlan_has_ipv4(){
  ip -4 addr show dev "$WLAN_IF" | grep -q 'inet '
}

try_dhcp_wlan(){
  command -v dhclient >/dev/null 2>&1 || return 0
  dhclient -r "$WLAN_IF" >/dev/null 2>&1 || true
  dhclient "$WLAN_IF" >/dev/null 2>&1 || true
}



case "$want" in
  ap)
    exec "$PROFILES_SCRIPT" ap
    ;;

  3g|ppp|ppp3g)
    if ppp_connectivity; then
      exec "$PROFILES_SCRIPT" 3g
    else
      exec "$PROFILES_SCRIPT" ap
    fi
    ;;

  client-lan|lan-client)
    if lan_has_link; then
      exec "$PROFILES_SCRIPT" client-lan
    else
      exec "$PROFILES_SCRIPT" ap
    fi
    ;;

  client-wifi|wifi-client|sta)
    ensure_wpa_running
    "$PROFILES_SCRIPT" client-wifi || true
    if wait_wifi_connected 75; then
      log "Wi-Fi conectado/associado (STA). Mantendo perfil client-wifi."
      exit 0
    else
      log "Wi-Fi não completou IPv4 em 75s."
      # Se pelo menos associou, mantemos STA (talvez cativo, DHCP lento, etc.)
      st="$(wifi_state)"
      if [ "$st" = "COMPLETED" ]; then
        log "Associação está OK (COMPLETED). Não farei fallback; mantendo client-wifi."
        exit 0
      fi
      log "Sem associação. Fallback -> AP."
      "$PROFILES_SCRIPT" ap || true
      exit 0
    fi
    ;;

  *)
    exec "$PROFILES_SCRIPT" ap
    ;;
esac
EOF

sudo chmod +x /usr/local/bin/mirako-autoboot.sh





sudo tee /etc/systemd/system/mirako-profile.service >/dev/null <<'UNIT'
[Unit]
Description=Aplicar perfil Mirako na inicialização (auto-seletor)
After=local-fs.target systemd-udev-settle.service network-online.target
Wants=network-online.target

[Service]
Type=oneshot
Environment=PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
Environment=WLAN_IF=wlan0
Environment=LAN_IF=end0
Environment=PPP_IF=ppp0
Environment=PPP_PEER=3g
Environment=PROFILES_SCRIPT=/usr/local/bin/profiles.sh
ExecStartPre=/bin/udevadm settle -t 20
ExecStart=/bin/bash -lc '/usr/local/bin/mirako-autoboot.sh'
Restart=on-failure
RestartSec=7s
TimeoutStartSec=180
StandardOutput=journal
StandardError=journal
StartLimitIntervalSec=0

[Install]
WantedBy=multi-user.target
UNIT

sudo systemctl daemon-reload
sudo systemctl restart mirako-profile.service





# ip-down: voltou a cair? vai pro AP
sudo tee /etc/ppp/ip-down.d/99-mirako >/dev/null <<'EOF'
#!/bin/sh
# Se o último perfil for 3G, não force AP: deixe o pppd redial (persist/maxfail=0)
LP="/var/lib/mirako/last_profile"
if [ -r "$LP" ]; then
  LAST="$(cat "$LP" 2>/dev/null)"
else
  LAST=""
fi

if [ "$LAST" = "3g" ] || [ "$LAST" = "ppp" ] || [ "$LAST" = "ppp3g" ]; then
  logger -t mirako "PPP caiu; mantendo perfil 3G para rediscagem automática (persist)."
  exit 0
fi

# Para outros perfis, ainda cai para AP como antes
logger -t mirako "PPP caiu; comutando para perfil AP (fallback)"
exec /usr/local/bin/profiles.sh ap
EOF
sudo chmod +x /etc/ppp/ip-down.d/99-mirako





sudo tee /usr/local/bin/mirako-ppp-keepalive.sh >/dev/null <<'EOF'
#!/usr/bin/env bash
set -Eeuo pipefail

PROFILE_FILE=/var/lib/mirako/last_profile
PROFILES_SCRIPT=${PROFILES_SCRIPT:-/usr/local/bin/profiles.sh}
PPP_IF=${PPP_IF:-ppp0}
CHECK_IP=${PPP_CONNECT_CHECK_HOST:-8.8.8.8}

log(){ echo "[ppp-keepalive] $*"; logger -t mirako-ppp-keepalive "$*"; }

ppp_has_ipv4(){ ip -4 addr show dev "$PPP_IF" 2>/dev/null | grep -q 'inet '; }
ppp_ok(){ ppp_has_ipv4 && ping -I "$PPP_IF" -c2 -W3 "$CHECK_IP" >/dev/null 2>&1; }

ensure_3g(){
  # Aplicar perfil 3G (ele mesmo configura NAT+AP)
  "$PROFILES_SCRIPT" 3g || true
}

while :; do
  WANT="$(cat "$PROFILE_FILE" 2>/dev/null || echo '')"
  if [[ "$WANT" != "3g" && "$WANT" != "ppp" && "$WANT" != "ppp3g" ]]; then
    log "last_profile='$WANT' não é 3G. Aguardando 15s…"
    sleep 15
    continue
  fi

  # Garantir 3G+AP ativo
  ensure_3g
  # Espera curta para ppp subir
  for i in {1..20}; do
    if ppp_has_ipv4; then break; fi
    sleep 1
  done

  if ppp_ok; then
    log "PPP ok (conectividade via $PPP_IF). Monitorando…"
    # monitora em janelas, se falhar tenta reerguer
    for j in {1..60}; do
      if ! ppp_ok; then
        log "Conectividade perdida — tentando reerguer perfil 3G…"
        break
      fi
      sleep 5
    done
  else
    log "PPP sem conectividade; reerguendo perfil 3G…"
  fi

  # Pequena espera antes do próximo ciclo
  sleep 3
done
EOF
sudo chmod +x /usr/local/bin/mirako-ppp-keepalive.sh







sudo tee /etc/systemd/system/mirako-ppp-keepalive.service >/dev/null <<'UNIT'
[Unit]
Description=Mirako PPP keep-alive (auto-redial 3G + AP)
After=network-online.target mirako-profile.service
Wants=network-online.target

[Service]
Type=simple
Environment=WLAN_IF=wlan0
Environment=LAN_IF=end0
Environment=PPP_IF=ppp0
Environment=PPP_PEER=3g
Environment=PROFILES_SCRIPT=/usr/local/bin/profiles.sh
ExecStart=/usr/local/bin/mirako-ppp-keepalive.sh
Restart=always
RestartSec=5s
# garante que o processo tenha /bin:/usr/bin:/sbin:/usr/sbin
Environment=PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

[Install]
WantedBy=multi-user.target
UNIT

sudo systemctl daemon-reload
sudo systemctl enable --now mirako-ppp-keepalive.service












sudo tee /etc/ppp/ip-up.d/00-mirako-dns >/dev/null <<'SH'
#!/bin/sh
# Usa os DNS aprendidos pelo pppd (usepeerdns)
if [ -r /etc/ppp/resolv.conf ]; then
  # se for symlink, substitui por arquivo real
  [ -L /etc/resolv.conf ] && rm -f /etc/resolv.conf
  cp -f /etc/ppp/resolv.conf /etc/resolv.conf
fi
exit 0
SH
sudo chmod +x /etc/ppp/ip-up.d/00-mirako-dns



sudo tee /etc/sysctl.d/98-mirako-rpf.conf >/dev/null <<'SYS'
net.ipv4.conf.all.rp_filter=0
net.ipv4.conf.default.rp_filter=0
net.ipv4.conf.ppp0.rp_filter=0
SYS
sudo sysctl --system













sudo journalctl -u mirako-web -f








sudo apt install samba
sudo mkdir -p /home/public
sudo chown nobody:nogroup /home/public    # Debian/Ubuntu; em CentOS pode ser nobody:nobody
sudo chmod 0777 /home/public
sudo chmod -R 0777 /home/public
sudo ufw allow samba




sudo tee /etc/samba/smb.conf >/dev/null <<'EOF'
[global]
   workgroup = WORKGROUP
   server string = MirakoSamba Server
   netbios name = MIRAKOSERVER
   security = user
   map to guest = Bad User
   log file = /var/log/samba/%m.log
   max log size = 50

   # Importante para aparecer na rede
   server role = standalone server
   local master = yes
   preferred master = yes
   os level = 255
   wins support = yes
   name resolve order = bcast host lmhosts wins

[Public]
   comment = Pasta pública - acesso guest
   path = /home/public
   browseable = yes
   guest ok = yes
   read only = no
   writable = yes
   public = yes
   force user = nobody
   create mask = 0777
   directory mask = 0777
   printable = no
EOF

















