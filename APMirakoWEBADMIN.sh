sudo tee /etc/update-motd.d/10-orangepi-header >/dev/null <<'EOF'
#!/bin/bash
#
# Copyright (c) Authors: https://www.armbian.com/authors
#
# This file is licensed under the terms of the GNU General Public
# License version 2. This program is licensed "as is" without any
# warranty of any kind, whether express or implied.

# DO NOT EDIT THIS FILE but add config options to /etc/default/orangepi-motd
# any changes will be lost on board support package update

THIS_SCRIPT="header"
MOTD_DISABLE=""

[[ -f /etc/default/orangepi-motd ]] && . /etc/default/orangepi-motd

for f in $MOTD_DISABLE; do
	[[ $f == $THIS_SCRIPT ]] && exit 0
done

. /etc/os-release
. /etc/orangepi-release

KERNELID=$(uname -r)
TERM=linux toilet -f standard -F metal $(echo 'Mirako.org')
echo -e "Welcome to \e[0;91mOrange Pi ${VERSION} ${DISTRIBUTION_CODENAME^}\x1B[0m with $([[ $BRANCH == edge ]] && echo -e "\e[0;91mbleeding\x1B[0m edge " )\e[0;91mLinux $KERNELID\x1B[0m\n \e[0;97m by SantoCyber\x1B[0m\n"

EOF

figlet "Mirako.ORG"
figlet "SantoCyber"



sudo tee /etc/hostname >/dev/null <<'EOF'
MirakoAPbySantoCyber
EOF






sudo apt update
sudo apt install -y hostapd dnsmasq ppp usb-modeswitch wpasupplicant iptables-persistent python3-flask python3-systemd traceroute tcpdump isc-dhcp-client iptables pppoeconf rfkill nftables python3-pip zram-tools busybox udhcpc udhcpd watchdog zram-tools nginx


sudo apt-get update
sudo apt-get install -y build-essential cmake git libjson-c-dev libwebsockets-dev
git clone https://github.com/tsl0922/ttyd.git
cd ttyd && mkdir build && cd build
cmake ..
make
sudo make install


sudo tee /etc/systemd/system/ttyd.service >/dev/null <<'EOF'
[Unit]
Description=ttyd web terminal
After=network.target

[Service]
ExecStart=/usr/local/bin/ttyd -p 7681 -i 0.0.0.0 -c admin:qazwsx -W bash -t fontSize=16
Restart=always
User=root
WorkingDirectory=/root

[Install]
WantedBy=multi-user.target
EOF


sudo systemctl daemon-reload
sudo systemctl enable --now ttyd
sudo systemctl restart ttyd









sudo sysctl --system
sudo tee /etc/sysctl.d/99-mirako.conf >/dev/null <<'CFG'
net.ipv4.ip_forward=1
net.ipv4.conf.all.rp_filter=0
net.ipv4.conf.default.rp_filter=0
net.ipv4.conf.ppp0.rp_filter=0
CFG
sudo sysctl --system


sudo netfilter-persistent save || sudo sh -c 'iptables-save > /etc/iptables/rules.v4'


iw dev wlan0 set power_save off 2>/dev/null || iwconfig wlan0 power off 2>/dev/null



sudo mkdir -p /etc/wpa_supplicant
sudo tee /etc/wpa_supplicant/wpa_supplicant-wlan0.conf >/dev/null <<'EOF'
ctrl_interface=/var/run/wpa_supplicant
update_config=1
country=BR
EOF
sudo systemctl enable wpa_supplicant@wlan0.service


sudo tee /etc/systemd/system/mirako-wpa@.service >/dev/null <<'EOF'
[Unit]
Description=WPA supplicant for %i
After=network.target

[Service]
ExecStart=/usr/sbin/wpa_supplicant -i %i -c /etc/wpa_supplicant/wpa_supplicant-%i.conf -D nl80211
Restart=always
RestartSec=3
EOF

systemctl disable mirako-wpa@wlan0.service






# pare e desabilite tudo; masque para não voltar no boot
sudo systemctl disable --now NetworkManager || true
sudo systemctl disable --now "wpa_supplicant@wlan0.service" wpa_supplicant || true
sudo systemctl disable --now hostapd dnsmasq || true

# use o backend nft (padrão em Debian modernos)
sudo update-alternatives --set iptables /usr/sbin/iptables-nft || true

# evite que serviços “do sistema” façam concorrência com os seus
sudo systemctl disable --now hostapd dnsmasq wpa_supplicant 2>/dev/null || true

sudo systemctl mask NetworkManager || true
sudo systemctl mask "wpa_supplicant@.service" wpa_supplicant hostapd dnsmasq || true



# crie/garanta diretório de chats
sudo mkdir -p /etc/chatscripts

# (re)crie o chat de CONEXÃO

sudo install -d /etc/chatscripts

sudo tee /etc/chatscripts/3g.chat >/dev/null <<'EOF'
ABORT   'BUSY'
ABORT   'NO CARRIER'
ABORT   'NO DIALTONE'
ABORT   'NO ANSWER'
ABORT   'ERROR'
ABORT   'SIM PIN'
REPORT  CONNECT
TIMEOUT 45
''        AT
OK        ATE0
OK        ATZ
OK        AT+CFUN=1
OK        AT+CGDCONT=1,"IP","zap.vivo.com.br"
OK        ATD*99#
CONNECT   \d\c
EOF


# chat de DESCONEXÃO
sudo tee /etc/chatscripts/3g-disconnect.chat >/dev/null <<'EOF'
'' '+++'
'' 'ATH'
'' 'ATZ'
EOF

# permissões: leitura suficiente (chat só precisa ler)
sudo chmod 644 /etc/chatscripts/3g.chat /etc/chatscripts/3g-disconnect.chat

# peers do pppd
sudo mkdir -p /etc/ppp/peers
sudo tee /etc/ppp/peers/3g >/dev/null <<'EOF'
/dev/ttyUSB2 115200
connect "/usr/sbin/chat -v -f /etc/chatscripts/3g.chat"
crtscts
modem
lock
debug
noauth
defaultroute
replacedefaultroute
usepeerdns
persist
holdoff 5
maxfail 0
noipdefault
noipv6
lcp-echo-interval 5
lcp-echo-failure 6
connect-delay 1000


EOF



# PPP UP hook
sudo tee /etc/ppp/ip-up.d/99-mirako >/dev/null <<'EOF'
#!/bin/sh
# args: interface tty speed localIP remoteIP ipparam
/usr/local/bin/profiles.sh ppp-up
exit 0
EOF
sudo chmod +x /etc/ppp/ip-up.d/99-mirako

# PPP DOWN hook
sudo tee /etc/ppp/ip-down.d/99-mirako >/dev/null <<'EOF'
#!/bin/sh
/usr/local/bin/profiles.sh ppp-down
exit 0
EOF
sudo chmod +x /etc/ppp/ip-down.d/99-mirako


sudo tee /etc/ppp/ip-up.d/10-mirako-dns >/dev/null <<'SH'
#!/bin/sh
# Mirako: usa DNS estático ao subir o PPP (independe de DNS1/DNS2)
set -eu
# Se for symlink (resolvconf/systemd-resolved), remova pra controlar manualmente
[ -L /etc/resolv.conf ] && rm -f /etc/resolv.conf
cat >/etc/resolv.conf <<EOF
# Mirako static DNS (PPP up)
nameserver 1.1.1.1
nameserver 8.8.8.8
EOF
exit 0
SH
sudo chmod +x /etc/ppp/ip-up.d/10-mirako-dns

sudo tee /etc/ppp/ip-down.d/10-mirako-dns >/dev/null <<'SH'
#!/bin/sh
# Mirako: mantém DNS estático quando o PPP desce
set -eu
[ -L /etc/resolv.conf ] && rm -f /etc/resolv.conf
cat >/etc/resolv.conf <<EOF
# Mirako static DNS (PPP down)
nameserver 1.1.1.1
nameserver 8.8.8.8
EOF
exit 0
SH
sudo chmod +x /etc/ppp/ip-down.d/10-mirako-dns


sudo rm -f /etc/resolv.conf
printf "# Mirako static DNS (manual)\nnameserver 1.1.1.1\nnameserver 8.8.8.8\n" | sudo tee /etc/resolv.conf >/dev/null







sudo mkdir -p /opt/mirako_web 



sudo tee /opt/mirako_web/users.ini >/dev/null <<'EOF'
[users]
admin = qazwsx
EOF

sudo chmod 600 /opt/mirako_web/users.ini 
sudo chown root:root /opt/mirako_web/users.ini




sudo tee /opt/mirako_web/web_config.py >/dev/null <<'EOF'
#!/usr/bin/env python3
# coding: utf-8
"""
Mirako router configuration web application — versão compatível com profiles.sh
- UI sem Bootstrap (CSS embutido)
- Status do sistema a cada 15s via /status.json
- Lista Wi-Fi (scan + redes do wpa_supplicant)
- Card Perfis com SELECT + descrição e integração com /usr/local/bin/profiles.sh
- Terminal ao vivo
- Modem/PPP
- Gerenciador de arquivos em /root
- Lista de serviços systemd

Compatibilidade com profiles.sh (no-systemd):
- Wi-Fi connect tenta iniciar wpa_supplicant -B se o serviço systemd não estiver ativo.
- Perfis são aplicados via PROFILES_SCRIPT (default /usr/local/bin/profiles.sh).
"""

from __future__ import annotations

import os
import re
import time
import glob
import shutil
import subprocess
import threading
import signal
import configparser
import json
import uuid
from typing import Any, List, Tuple, Dict


from flask import (
    Flask,
    render_template_string,
    request,
    redirect,
    url_for,
    flash,
    jsonify,
    send_from_directory,
    abort,
    make_response,
)




app = Flask(__name__)
app.secret_key = os.environ.get("MIRAKO_SECRET", "devkey")

# ========================== Config em runtime ==========================



WIFI_SCAN_CACHE = "/var/lib/mirako/wifi_scan.json"
WLAN_IF = os.environ.get("WLAN_IF", "wlan0")
LAN_IF = os.environ.get("LAN_IF", "end0")
PPP_IF = os.environ.get("PPP_IF", "ppp0")
PPP_PEER = os.environ.get("PPP_PEER", "3g")
PROFILES_SCRIPT = os.environ.get("PROFILES_SCRIPT", "/usr/local/bin/profiles.sh")
AUTO_DIAL_FILE = "/var/lib/mirako/auto_dial_enabled"
SSID = os.environ.get("SSID") or os.environ.get("AP_SSID") or "MirakoAP"
PASS = os.environ.get("PASS") or os.environ.get("AP_PASS") or "12345678"

def find_bin(name: str, fallbacks: List[str]) -> str:
    p = shutil.which(name)
    if p:
        return p
    for fb in fallbacks:
        if os.path.exists(fb) and os.access(fb, os.X_OK):
            return fb
    return name

PPPD_BIN = find_bin("pppd", ["/usr/sbin/pppd", "/sbin/pppd", "/usr/bin/pppd"])
IP_BIN = find_bin("ip", ["/usr/sbin/ip", "/sbin/ip", "/usr/bin/ip"])
IW_BIN = find_bin("iw", ["/usr/sbin/iw", "/sbin/iw", "/usr/bin/iw"])
IWLIST_BIN = find_bin("iwlist", ["/usr/sbin/iwlist", "/sbin/iwlist", "/usr/bin/iwlist"])
WPA_CLI_BIN = find_bin("wpa_cli", ["/usr/sbin/wpa_cli", "/sbin/wpa_cli", "/usr/bin/wpa_cli"])
WPA_SUPP_BIN = find_bin("wpa_supplicant", ["/usr/sbin/wpa_supplicant", "/sbin/wpa_supplicant", "/usr/bin/wpa_supplicant"])
RESOLVECTL_BIN = find_bin("resolvectl", ["/usr/bin/resolvectl", "/usr/sbin/resolvectl", "/bin/resolvectl"])

AUTH_INI = "/opt/mirako_web/users.ini"

WPA_SUPP_CONF_CAND = [
    f"/etc/wpa_supplicant/wpa_supplicant-{WLAN_IF}.conf",
    "/etc/wpa_supplicant/wpa_supplicant.conf",
]





ACTIVE_PROFILE_FILE = "/var/lib/mirako/active_profile"
LAST_PROFILE_FILE   = "/var/lib/mirako/last_profile"

def get_active_profile() -> str:
    try:
        with open(ACTIVE_PROFILE_FILE, "r", encoding="utf-8") as f:
            return f.read().strip() or "ap"
    except Exception:
        return "ap"



# ========================== WIFI_SAVED_DB==========================


WIFI_SAVED_DB = "/etc/mirako/wifi_saved.json"

def _wifi_db_load() -> List[Dict[str, Any]]:
    try:
        if not os.path.exists(WIFI_SAVED_DB):
            return []
        with open(WIFI_SAVED_DB, "r", encoding="utf-8") as f:
            data = json.load(f)
        items = data.get("items", [])
        if not isinstance(items, list):
            return []
        # normaliza
        out: List[Dict[str, Any]] = []
        for it in items:
            if not isinstance(it, dict):
                continue
            ssid = str(it.get("ssid", "")).strip()
            if not ssid:
                continue
            out.append({
                "id": str(it.get("id", "")).strip() or str(uuid.uuid4()),
                "ssid": ssid,
                "psk": str(it.get("psk", "") or ""),
                "ts": float(it.get("ts", time.time())),
            })
        out.sort(key=lambda x: x["ssid"].lower())
        return out
    except Exception:
        return []

def _wifi_db_write(items: List[Dict[str, Any]]) -> None:
    os.makedirs(os.path.dirname(WIFI_SAVED_DB), exist_ok=True)
    tmp = WIFI_SAVED_DB + ".tmp"
    payload = {"items": items, "ts": time.time()}
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(payload, f, ensure_ascii=False, indent=2)
        f.flush()
        os.fsync(f.fileno())
    os.chmod(tmp, 0o600)
    os.replace(tmp, WIFI_SAVED_DB)

def wifi_saved_list() -> List[Dict[str, Any]]:
    return _wifi_db_load()

def wifi_saved_get(item_id: str) -> Dict[str, Any] | None:
    item_id = (item_id or "").strip()
    if not item_id:
        return None
    for it in _wifi_db_load():
        if it.get("id") == item_id:
            return it
    return None

def wifi_saved_upsert(item_id: str, ssid: str, psk: str) -> None:
    item_id = (item_id or "").strip()
    ssid = (ssid or "").strip()
    psk = (psk or "")

    if not ssid:
        raise ValueError("SSID vazio")

    items = _wifi_db_load()

    # update por id (se existir)
    if item_id:
        for it in items:
            if it.get("id") == item_id:
                it["ssid"] = ssid
                if psk != "":
                    it["psk"] = psk
                it["ts"] = time.time()
                _wifi_db_write(items)
                return

    # senão: upsert por SSID
    for it in items:
        if it.get("ssid") == ssid:
            if psk != "":
                it["psk"] = psk
            it["ts"] = time.time()
            _wifi_db_write(items)
            return

    items.append({
        "id": str(uuid.uuid4()),
        "ssid": ssid,
        "psk": psk,
        "ts": time.time(),
    })
    items.sort(key=lambda x: x["ssid"].lower())
    _wifi_db_write(items)

def wifi_saved_delete(item_id: str) -> None:
    item_id = (item_id or "").strip()
    if not item_id:
        return
    items = [it for it in _wifi_db_load() if it.get("id") != item_id]
    _wifi_db_write(items)

def connect_wifi_guarded(ssid: str, psk: str) -> Tuple[bool, str]:
    ssid = (ssid or "").strip()
    psk = (psk or "").strip()

    if not ssid:
        return False, "SSID vazio"

    # 1) salva wifi.env
    try:
        os.makedirs("/etc/mirako", exist_ok=True)
        with open("/etc/mirako/wifi.env", "w", encoding="utf-8") as f:
            f.write(f'WIFI_SSID="{ssid}"\n')
            f.write(f'WIFI_PSK="{psk}"\n')
        os.chmod("/etc/mirako/wifi.env", 0o600)
    except Exception as e:
        return False, f"falha ao salvar credenciais: {e}"

    # 2) aplica client-wifi
    rc, out = profile_set("client-wifi")

    # ✅ se o profiles.sh falhou, ele mesmo já colocou AP fallback
    if rc != 0:
        return False, (
            "❌ Não foi possível conectar ao Wi-Fi.<br>"
            "✅ O sistema entrou em <b>AP fallback</b> automaticamente para não perder acesso.<br>"
            f"<small class='mono'>{(out or '').strip()}</small>"
        )

    # 3) valida por alguns segundos (quando rc==0, geralmente já tem IP)
    deadline = time.time() + 20
    while time.time() < deadline:
        last_active = (get_active_profile() or "").strip()
        last_ip = get_ipv4_list(WLAN_IF).strip()
        if last_active == "client-wifi" and last_ip and last_ip != "-":
            return True, f"✅ Conectado ao Wi-Fi <b>{ssid}</b><br>IP em {WLAN_IF}: <span class='mono'>{last_ip}</span>"
        time.sleep(2)

    # se demorou demais, não destrói last_profile — só informa
    return False, (
        "⚠️ Perfil aplicado, mas ainda sem IP no wlan0.<br>"
        "Verifique DHCP/roteamento.<br>"
        f"<small class='mono'>active={get_active_profile()} ip={get_ipv4_list(WLAN_IF)}</small>"
    )




# ========================== ap_fallback_until ==========================


FALLBACK_UNTIL_FILE = "/var/lib/mirako/ap_fallback_until"

def ap_fallback_remaining_sec() -> int:
    try:
        until = int(open(FALLBACK_UNTIL_FILE, "r").read().strip())
        return max(0, until - int(time.time()))
    except Exception:
        return 0

def force_ap_now(reason: str = "") -> None:
    run([PROFILES_SCRIPT, "ap"], timeout=180)
    try:
        write_last_profile("ap")
    except Exception:
        pass





# ========================== Terminal ao vivo ==========================
LOG_DIR = "/var/log/mirako"
os.makedirs(LOG_DIR, exist_ok=True)
TERM_LOG = os.path.join(LOG_DIR, "terminal.log")
RUN: Dict[str, Any] = {"proc": None, "pgid": None}
RUN_LOCK = threading.Lock()

def _write_line(text: str) -> None:
    try:
        with open(TERM_LOG, "a", encoding="utf-8", errors="ignore") as f:
            f.write(text)
            if not text.endswith("\n"):
                f.write("\n")
    except Exception:
        pass

def _pump_stdout(proc: subprocess.Popen) -> None:
    try:
        for line in iter(proc.stdout.readline, ""):
            _write_line(line.rstrip("\n"))
    except Exception as e:
        _write_line(f"[pump] erro: {e}")
    finally:
        code = proc.wait()
        _write_line(f"\n[processo finalizado] exit={code}")

def start_command(cmd: str) -> None:
    raw = cmd.strip()
    if not raw:
        return
    with RUN_LOCK:
        if RUN["proc"] is not None and RUN["proc"].poll() is None:
            try:
                os.killpg(RUN["pgid"], signal.SIGINT)
            except Exception:
                try:
                    RUN["proc"].terminate()
                except Exception:
                    pass
        try:
            with open(TERM_LOG, "w", encoding="utf-8", errors="ignore") as f:
                f.write(f"# {time.strftime('%Y-%m-%d %H:%M:%S')} — exec: {raw}\n")
        except Exception:
            pass
        proc = subprocess.Popen(
            raw,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1,
            preexec_fn=os.setsid,
        )
        RUN["proc"] = proc
        RUN["pgid"] = os.getpgid(proc.pid)
        t = threading.Thread(target=_pump_stdout, args=(proc,), daemon=True)
        t.start()

def stop_command() -> None:
    with RUN_LOCK:
        if RUN["proc"] is not None and RUN["proc"].poll() is None:
            try:
                os.killpg(RUN["pgid"], signal.SIGINT)
                _write_line("[SIGINT enviado]")
            except Exception as e:
                _write_line(f"[erro SIGINT] {e}")
                try:
                    RUN["proc"].terminate()
                except Exception:
                    pass

def clear_log() -> None:
    try:
        with open(TERM_LOG, "w", encoding="utf-8") as f:
            f.write("")
    except Exception:
        pass

def read_log_tail(max_bytes: int = 120_000) -> str:
    try:
        with open(TERM_LOG, "rb") as f:
            f.seek(0, os.SEEK_END)
            size = f.tell()
            off = max(0, size - max_bytes)
            f.seek(off, os.SEEK_SET)
            data = f.read().decode("utf-8", errors="ignore")
            return data
    except Exception:
        return "(sem saída ainda)"

# ========================== Helpers genéricos ==========================


def write_last_profile(profile: str) -> None:
    os.makedirs("/var/lib/mirako", exist_ok=True)
    with open(LAST_PROFILE_FILE, "w", encoding="utf-8") as f:
        f.write(profile.strip() + "\n")
        f.flush()
        os.fsync(f.fileno())
    os.sync()


def run(cmd: List[str], timeout: int = 10) -> Tuple[int, str]:
    try:
        out = subprocess.check_output(
            cmd, stderr=subprocess.STDOUT, text=True, timeout=timeout
        )
        return 0, out.strip()
    except subprocess.CalledProcessError as e:
        return e.returncode, (e.output or "").strip()
    except Exception as e:
        return 1, f"{type(e).__name__}: {e}"

def human_bytes(n: float) -> str:
    try:
        n = float(n)
    except Exception:
        return str(n)
    units = ["B", "KB", "MB", "GB", "TB"]
    i = 0
    while n >= 1024 and i < len(units) - 1:
        n /= 1024.0
        i += 1
    return f"{n:.1f} {units[i]}"

# ========================== Rede ==========================
def ensure_iface_up(dev: str) -> None:
    base = f"/sys/class/net/{dev}"
    if not os.path.exists(base):
        return
    try:
        state = open(os.path.join(base, "operstate")).read().strip().lower()
    except Exception:
        state = "unknown"
    if state != "up":
        run([IP_BIN, "link", "set", "dev", dev, "up"])

def get_ipv4_list(dev: str) -> str:
    rc, out = run([IP_BIN, "-4", "addr", "show", "dev", dev])
    if rc != 0:
        return "-"
    ips: List[str] = []
    for line in out.splitlines():
        s = line.strip()
        if s.startswith("inet "):
            parts = s.split()
            if len(parts) >= 2:
                ips.append(parts[1])
    return ", ".join(ips) if ips else "-"

def default_route() -> str:
    rc, out = run([IP_BIN, "-4", "route", "show", "default"])
    return out if rc == 0 and out else "<sem rota>"

def routes() -> str:
    rc, out = run([IP_BIN, "-4", "route"])
    return out if rc == 0 else f"(erro ip route rc={rc})"

def dns_info() -> str:
    if os.path.exists(RESOLVECTL_BIN):
        rc, out = run([RESOLVECTL_BIN, "status"], timeout=5)
        if rc == 0 and out:
            return out
    try:
        with open("/etc/resolv.conf", "r", encoding="utf-8", errors="ignore") as f:
            return f.read()
    except Exception as e:
        return f"# erro ao ler resolv.conf: {e}"

def read_dnsmasq_leases() -> Tuple[List[dict], str, str | None]:
    paths = ["/var/lib/misc/dnsmasq.leases", "/var/lib/dnsmasq/dnsmasq.leases"]
    for path in paths:
        if os.path.exists(path):
            leases: List[dict] = []
            raw = ""
            try:
                raw = open(path, "r", encoding="utf-8", errors="ignore").read()
                for line in raw.splitlines():
                    parts = line.split()
                    if len(parts) >= 5:
                        expiry, mac, ip, hostname, client_id = parts[:5]
                        try:
                            expi = int(expiry)
                            when = (
                                "infinito"
                                if expi == 0
                                else time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(expi))
                            )
                        except Exception:
                            when = expiry
                        leases.append(
                            {
                                "expiry": when,
                                "mac": mac,
                                "ip": ip,
                                "hostname": hostname if hostname != "*" else "",
                                "client_id": client_id,
                            }
                        )
            except Exception as e:
                raw = f"(erro ao ler {path}: {e})"
            return leases, raw, path
    return [], "(arquivo de leases não encontrado)", None

# ========================== Estado do sistema ==========================
def cpu_temp_c() -> float | None:
    temps: List[float] = []
    best: float | None = None
    for path in glob.glob("/sys/class/thermal/thermal_zone*/temp"):
        try:
            t = int(open(path).read().strip())
            c = t / 1000.0 if t > 1000 else float(t)
            ttype_path = path.replace("/temp", "/type")
            ttype = open(ttype_path).read().strip().lower() if os.path.exists(ttype_path) else ""
            if "cpu" in ttype or "soc" in ttype:
                best = c
            temps.append(c)
        except Exception:
            pass
    if best is not None:
        return best
    if temps:
        return sum(temps) / len(temps)
    try:
        c = int(open("/sys/class/thermal/thermal_zone0/temp").read().strip()) / 1000.0
        return c
    except Exception:
        return None

def cpu_usage_pct(sample_sec: float = 0.2) -> float:
    def read_cpu() -> Tuple[int, int]:
        with open("/proc/stat", "r") as f:
            for line in f:
                if line.startswith("cpu "):
                    parts = line.split()
                    vals = list(map(int, parts[1:]))
                    idle = vals[3] + (vals[4] if len(vals) > 4 else 0)
                    total = sum(vals)
                    return idle, total
        return 0, 1
    idle1, total1 = read_cpu()
    time.sleep(sample_sec)
    idle2, total2 = read_cpu()
    dtotal = total2 - total1
    didle = idle2 - idle1
    if dtotal <= 0:
        return 0.0
    busy = 100.0 * (1.0 - (didle / dtotal))
    if busy < 0:
        busy = 0.0
    max_pct = 100 * (os.cpu_count() or 1)
    return busy if busy <= max_pct else max_pct

def uptime_str() -> str:
    try:
        up_seconds = float(open("/proc/uptime").read().split()[0])
        days = int(up_seconds // 86400)
        hrs  = int((up_seconds % 86400) // 3600)
        mins = int((up_seconds % 3600) // 60)
        if days > 0:
            return f"{days}d {hrs}h {mins}m"
        return f"{hrs}h {mins}m"
    except Exception:
        return "-"
    

def mem_stats() -> Dict[str, float]:
    info: Dict[str, str] = {}
    with open("/proc/meminfo", "r") as f:
        for line in f:
            k, v = line.split(":", 1)
            info[k.strip()] = v.strip()
    def kB(name: str) -> int:
        val = info.get(name, "0").split()[0]
        return int(val)
    total = kB("MemTotal") * 1024
    avail = kB("MemAvailable") * 1024
    used = total - avail
    pct = (used / total * 100.0) if total > 0 else 0.0
    return dict(total=total, used=used, avail=avail, pct=pct)

def disk_stats(path: str = "/") -> Dict[str, float]:
    du = shutil.disk_usage(path)
    used = du.total - du.free
    pct = used / du.total * 100.0 if du.total else 0.0
    return dict(total=du.total, used=used, free=du.free, pct=pct)

def processes_top(n: int = 20) -> List[dict]:
    rc, out = run(["ps", "-eo", "pid,comm,%cpu,%mem", "--sort=-%cpu"])
    procs: List[dict] = []
    if rc == 0 and out:
        lines = out.splitlines()
        for line in lines[1 : 1 + n]:
            parts = line.split(None, 4)
            if len(parts) >= 4:
                pid, comm, pcpu, pmem = parts[:4]
                procs.append(dict(pid=pid, comm=comm, pcpu=pcpu, pmem=pmem))
    return procs

def net_stats_for(dev: str) -> dict:
    base = f"/sys/class/net/{dev}"
    if not os.path.exists(base):
        return dict(dev=dev, state="DOWN", ipv4="-", rx="-", tx="-")
    try:
        state = open(os.path.join(base, "operstate")).read().strip().upper()
    except Exception:
        state = "?"
    def read_num(p: str) -> int:
        try:
            return int(open(p).read().strip())
        except Exception:
            return 0
    rx = read_num(os.path.join(base, "statistics/rx_bytes"))
    tx = read_num(os.path.join(base, "statistics/tx_bytes"))
    return dict(
        dev=dev,
        state=state,
        ipv4=get_ipv4_list(dev),
        rx=human_bytes(rx),
        tx=human_bytes(tx),
    )

# ========================== Wi-Fi ==========================
def iw_info() -> dict:
    rc, out = run([IW_BIN, "dev", WLAN_IF, "info"])
    info: Dict[str, Any] = {"type": "-", "channel": "-", "freq_mhz": None, "txpower_dbm": "-"}
    if rc == 0 and out:
        for ln in out.splitlines():
            s = ln.strip()
            if s.startswith("type "):
                info["type"] = s.split(" ", 1)[1].strip()
            elif "channel" in s and "(" in s and "MHz" in s:
                try:
                    parts = s.split()
                    info["channel"] = parts[1]
                    mhz = s.split("(")[1].split("MHz")[0].strip()
                    info["freq_mhz"] = float(mhz)
                except Exception:
                    pass
            elif s.startswith("txpower "):
                try:
                    val = s.split()[1]
                    info["txpower_dbm"] = f"{float(val):.1f} dBm"
                except Exception:
                    pass
    return info

def get_ap_ssid() -> str:
    # prioridade: /etc/mirako/ap.env (fonte real do profiles.sh)
    try:
        if os.path.exists("/etc/mirako/ap.env"):
            txt = open("/etc/mirako/ap.env","r",encoding="utf-8",errors="ignore").read()
            m = re.search(r'^\s*AP_SSID\s*=\s*"?([^"\n]+)"?\s*$', txt, re.M)
            if m:
                return m.group(1).strip()
    except Exception:
        pass
    return SSID


def iw_link() -> dict:
    # Descobre tipo real (AP vs managed) para não “inventar conexão”
    ii = iw_info()  # já existe no seu código
    iftype = str(ii.get("type", "")).strip().lower()

    rc, out = run([IW_BIN, "dev", WLAN_IF, "link"])
    d: Dict[str, Any] = {
        "connected": False,
        "ssid": "-",
        "bssid": "-",
        "signal_dbm": None,
        "rx_bitrate": "-",
        "tx_bitrate": "-",
        "rx": "-",
        "tx": "-",
        "clients": 0,
    }

    if rc != 0 or not out:
        return d

    # 1) Caso "Not connected."
    if "Not connected." in out:
        # Só é "conectado" se a interface estiver em modo AP
        if iftype == "ap":
            d["connected"] = True
            d["ssid"] = get_ap_ssid()

            # Conta clientes e pega um RSSI (se houver)
            rc2, st = run([IW_BIN, "dev", WLAN_IF, "station", "dump"])
            if rc2 == 0 and st:
                clients = 0
                best_rssi = None
                for ln in st.splitlines():
                    s = ln.strip()
                    if s.lower().startswith("station "):
                        clients += 1
                    # 'signal: -47 [-47] dBm' ou 'signal: -47.00 dBm'
                    if s.lower().startswith("signal:"):
                        try:
                            val = float(s.split()[1])
                            if best_rssi is None or val > best_rssi:
                                best_rssi = val  # pega o “melhor” (mais perto de 0)
                        except Exception:
                            pass

                d["clients"] = clients
                if best_rssi is not None:
                    d["signal_dbm"] = best_rssi
        # Se não for AP, realmente não está conectado (managed idle)
        return d

    # 2) Caso associado (modo cliente)
    d["connected"] = True
    for ln in out.splitlines():
        s = ln.strip()

        if s.startswith("SSID:"):
            d["ssid"] = s.split(":", 1)[1].strip()

        elif s.startswith("Connected to "):
            # Ex: "Connected to aa:bb:cc:dd:ee:ff (on wlan0)"
            parts = s.split()
            if len(parts) >= 3:
                d["bssid"] = parts[2].strip()

        elif s.startswith("signal:"):
            # Ex: "signal: -47 dBm" ou "signal: -47.00 dBm"
            try:
                d["signal_dbm"] = float(s.split()[1])
            except Exception:
                pass

        elif s.startswith("rx bitrate:"):
            d["rx_bitrate"] = s.split(":", 1)[1].strip()

        elif s.startswith("tx bitrate:"):
            d["tx_bitrate"] = s.split(":", 1)[1].strip()

        elif s.startswith("RX:"):
            d["rx"] = s.split(":", 1)[1].strip()

        elif s.startswith("TX:"):
            d["tx"] = s.split(":", 1)[1].strip()

    return d


def iface_byte_counters(dev: str) -> Tuple[int, int, int, int]:
    base = f"/sys/class/net/{dev}/statistics"
    try:
        rx1 = int(open(os.path.join(base, "rx_bytes")).read().strip())
        tx1 = int(open(os.path.join(base, "tx_bytes")).read().strip())
        time.sleep(0.25)
        rx2 = int(open(os.path.join(base, "rx_bytes")).read().strip())
        tx2 = int(open(os.path.join(base, "tx_bytes")).read().strip())
        rx_bps = (rx2 - rx1) * 8 * 4
        tx_bps = (tx2 - tx1) * 8 * 4
        return (rx2, tx2, rx_bps, tx_bps)
    except Exception:
        return (0, 0, 0, 0)

def wpa_status() -> dict:
    rc, out = run([WPA_CLI_BIN, "-i", WLAN_IF, "status"])
    d: Dict[str, Any] = {}
    if rc == 0:
        for line in out.splitlines():
            if "=" in line:
                k, v = line.split("=", 1)
                d[k] = v
    return d

def wifi_status_details() -> dict:
    st = wpa_status()
    ii = iw_info()
    lk = iw_link()
    rxB, txB, rxbps, txbps = iface_byte_counters(WLAN_IF)
    mode = ii.get("type", "-").upper()
    state = st.get("wpa_state", "-")
    channel = ii.get("channel", "-")
    freq_mhz = ii.get("freq_mhz")
    rssi = lk.get("signal_dbm")
    dist_m = None
    try:
        import math
        if (rssi is not None) and freq_mhz:
            dist_m = round(10 ** ((27.55 - (20 * math.log10(float(freq_mhz))) + abs(float(rssi))) / 20), 1)
    except Exception:
        pass
    return {
        "mode": mode,
        "state": state,
        "ssid": lk.get("ssid", "-"),
        "bssid": lk.get("bssid", "-"),
        "channel": channel,
        "freq_mhz": f"{freq_mhz:.0f} MHz" if freq_mhz else "-",
        "txpower": ii.get("txpower_dbm", "-"),
        "rssi": f"{rssi:.0f} dBm" if rssi is not None else "-",
        "tx_bitrate": lk.get("tx_bitrate", "-"),
        "rx_bitrate": lk.get("rx_bitrate", "-"),
        "rx_bytes": human_bytes(rxB),
        "tx_bytes": human_bytes(txB),
        "rx_bps": f"{rxbps/1e6:.2f} Mbit/s" if rxbps > 0 else "0",
        "tx_bps": f"{txbps/1e6:.2f} Mbit/s" if txbps > 0 else "0",
        "clients": lk.get("clients", 0),
        "distance_m": f"~{dist_m} m" if dist_m else "-",
    }





def get_cached_wifi_scan() -> Tuple[List[dict], str | None]:
    """
    Lê o último scan salvo pelo profiles.sh
    Retorna (nets, debug_msg)
    """
    if not os.path.exists(WIFI_SCAN_CACHE):
        return [], "Nenhum scan Wi-Fi disponível (AP ainda não foi iniciado)."

    try:
        with open(WIFI_SCAN_CACHE, "r", encoding="utf-8") as f:
            data = json.load(f)

        nets = data.get("nets", [])
        ts = data.get("ts")

        if ts:
            when = time.strftime("%d/%m %H:%M:%S", time.localtime(ts))
            dbg = f"Scan automático antes do AP — {when}"
        else:
            dbg = "Scan automático antes do AP"

        return nets, dbg

    except Exception as e:
        return [], f"Erro ao ler cache de scan: {e}"


def get_saved_networks() -> List[Dict[str, str]]:
    rc, out = run([WPA_CLI_BIN, "-i", WLAN_IF, "list_networks"])
    nets: List[Dict[str, str]] = []
    if rc == 0 and out:
        lines = out.splitlines()[1:]
        for line in lines:
            parts = line.split("\t")
            if len(parts) >= 4:
                nets.append(
                    {"id": parts[0].strip(), "ssid": parts[1].strip(), "bssid": parts[2].strip(), "flags": parts[3].strip()}
                )
    return nets

def read_wpa_conf_networks() -> List[Dict[str, str]]:
    paths = [
        f"/etc/wpa_supplicant/wpa_supplicant-{WLAN_IF}.conf",
        "/etc/wpa_supplicant/wpa_supplicant.conf",
    ]
    items: List[Dict[str, str]] = []
    for path in paths:
        if not os.path.exists(path):
            continue
        try:
            txt = open(path, "r", encoding="utf-8", errors="ignore").read()
        except Exception:
            continue
        for block in re.findall(r'network=\{(.*?)\}', txt, flags=re.S | re.M):
            ssid_m = re.search(r'^\s*ssid\s*=\s*"(.*?)"\s*$', block, flags=re.M)
            psk_m  = re.search(r'^\s*psk\s*=\s*"(.*?)"\s*$', block, flags=re.M)
            keymgmt_m = re.search(r'^\s*key_mgmt\s*=\s*(.*?)\s*$', block, flags=re.M)
            prio_m = re.search(r'^\s*priority\s*=\s*(\d+)\s*$', block, flags=re.M)
            items.append({
                "ssid": ssid_m.group(1) if ssid_m else "(sem ssid)",
                "psk": ("(oculta)" if psk_m else ("OPEN" if (keymgmt_m and keymgmt_m.group(1).strip().upper()=="NONE") else "(?)")),
                "key_mgmt": (keymgmt_m.group(1).strip() if keymgmt_m else "-"),
                "priority": (prio_m.group(1) if prio_m else "-"),
            })
    uniq: Dict[str, Dict[str, str]] = {}
    for n in items:
        k = n["ssid"]
        if k not in uniq:
            uniq[k] = n
        else:
            try:
                if int(n.get("priority","0")) > int(uniq[k].get("priority","0")):
                    uniq[k] = n
            except Exception:
                pass
    out = list(uniq.values())
    try:
        out.sort(key=lambda x: int(x.get("priority","0")), reverse=True)
    except Exception:
        pass
    return out

def wifi_connect(ssid: str, psk: str | None = None) -> Tuple[bool, str]:
    try:
        os.makedirs("/etc/mirako", exist_ok=True)
        with open("/etc/mirako/wifi.env", "w", encoding="utf-8") as f:
            f.write(f'WIFI_SSID="{ssid}"\n')
            f.write(f'WIFI_PSK="{(psk or "").strip()}"\n')
        os.chmod("/etc/mirako/wifi.env", 0o600)
    except Exception as e:
        return False, f"falha ao salvar credenciais: {e}"


    rc, out = profile_set("client-wifi")
    if rc != 0:
        return False, (out or "profiles.sh client-wifi falhou")

    time.sleep(2)
    ip = get_ipv4_list(WLAN_IF)
    return True, f"credenciais salvas; profile solicitado; IP wlan0={ip}"

def wifi_disconnect() -> Tuple[bool, str]:
    rc, out = run([PROFILES_SCRIPT, "stop"], timeout=60)
    return (rc == 0, out or "parado")


# ========================== Serviços & PPP ==========================
# ========================== Serviços & PPP ==========================

SERVICES_CACHE: Dict[str, Any] = {"ts": 0.0, "data": []}
SERVICES_TTL_SEC = 20  # cache para evitar martelar systemctl

def list_services_fast() -> List[dict]:
    """
    Versão rápida:
    - 2 chamadas ao systemctl (list-units + list-unit-files)
    - Sem loop de is-active por serviço (que é o que mata performance)
    """
    enabled_map: Dict[str, str] = {}

    rc1, out1 = run(
        ["systemctl", "list-unit-files", "--type=service", "--no-pager", "--no-legend"],
        timeout=6,
    )
    if rc1 == 0 and out1:
        for line in out1.splitlines():
            parts = line.split()
            if len(parts) >= 2:
                enabled_map[parts[0]] = parts[1]  # enabled/disabled/masked/static/...

    services: List[dict] = []
    rc2, out2 = run(
        ["systemctl", "list-units", "--type=service", "--all", "--no-pager", "--no-legend"],
        timeout=6,
    )
    if rc2 != 0 or not out2:
        return services

    for line in out2.splitlines():
        line = line.strip()
        if not line:
            continue

        # tenta manter colunas separadas (UNIT LOAD ACTIVE SUB DESCRIPTION)
        parts = line.split(None, 5)
        if len(parts) < 4:
            continue

        # ✅ remove marcadores do systemctl (ex: "●")
        if parts[0] in ("●", "○", "•", "*"):
            parts = parts[1:]
            if len(parts) < 4:
                continue

        name, load, active, sub = parts[:4]
        enabled_state = enabled_map.get(name, "")
        enabled = enabled_state.startswith("enabled")

        services.append({
            "name": name,
            "active": (active == "active"),
            "enabled": enabled,
            "enabled_state": enabled_state or "-",
        })

    services.sort(key=lambda x: x["name"])
    return services


@app.get("/services.json")
def services_json():
    now = time.time()
    try:
        if (now - float(SERVICES_CACHE.get("ts", 0.0))) < SERVICES_TTL_SEC:
            return jsonify({"services": SERVICES_CACHE.get("data", []), "cached": True})

        data = list_services_fast()
        SERVICES_CACHE["ts"] = now
        SERVICES_CACHE["data"] = data
        return jsonify({"services": data, "cached": False})
    except Exception as e:
        return jsonify({"services": [], "err": str(e)}), 500


def service_action(service: str, action: str) -> Tuple[bool, str]:
    valid = {"start","stop","restart","enable","disable"}
    if action not in valid:
        return False, f"ação inválida: {action}"
    cmd = ["systemctl", action, service] if action in {"start","stop","restart"} else ["systemctl", action, service]
    rc, out = run(cmd, timeout=20)
    return (rc == 0, out)

def parse_dhclient_lease(iface: str) -> Tuple[List[str], List[str]]:
    path = f"/var/lib/dhcp/dhclient.{iface}.leases"
    routers: List[str] = []
    dns: List[str] = []
    try:
        if os.path.exists(path):
            txt = open(path, "r", encoding="utf-8", errors="ignore").read()
            m_dns = re.findall(r"option\s+domain-name-servers\s+([^;]+);", txt)
            m_rtr = re.findall(r"option\s+routers\s+([^;]+);", txt)
            if m_dns:
                dns = [i.strip() for i in re.split(r"[,\s]+", m_dns[-1].strip()) if i.strip()]
            if m_rtr:
                routers = [i.strip() for i in re.split(r"[,\s]+", m_rtr[-1].strip()) if i.strip()]
    except Exception:
        pass
    return routers, dns

def apply_dns(nameservers: List[str]) -> Tuple[bool, str]:
    try:
        if os.path.islink("/etc/resolv.conf"):
            os.unlink("/etc/resolv.conf")
        with open("/etc/resolv.conf", "w", encoding="utf-8") as f:
            f.write("# Generated by Mirako client-wifi\n")
            for ns in nameservers:
                if ns:
                    f.write(f"nameserver {ns}\n")
        return True, "resolv.conf atualizado"
    except Exception as e:
        return False, f"erro ao escrever resolv.conf: {e}"

def is_auto_dial_enabled() -> bool:
    try:
        return os.path.exists(AUTO_DIAL_FILE)
    except Exception:
        return False

def set_auto_dial(enabled: bool) -> None:
    try:
        if enabled:
            os.makedirs(os.path.dirname(AUTO_DIAL_FILE), exist_ok=True)
            with open(AUTO_DIAL_FILE, "w") as f:
                f.write("1")
            # start imediato
            run(["systemctl", "start", "mirako-autodial.service"], timeout=10)
        else:
            if os.path.exists(AUTO_DIAL_FILE):
                os.remove(AUTO_DIAL_FILE)
            # stop imediato
            run(["systemctl", "stop", "mirako-autodial.service"], timeout=10)
    except Exception:
        pass


def ensure_default_via(gw: str, dev: str) -> None:
    if not gw:
        return
    run([IP_BIN, "route", "replace", "default", "via", gw, "dev", dev])

def list_interfaces(include_virtual: bool = True, include_lo: bool = True) -> List[str]:
    try:
        names = sorted(os.listdir("/sys/class/net"))
    except Exception:
        names = []
    skip_prefix = ("veth", "br-", "docker", "virbr", "vnet", "vmnet", "vnet", "zt")
    out: List[str] = []
    for n in names:
        if not include_lo and n == "lo":
            continue
        if not include_virtual and n.startswith(skip_prefix):
            continue
        out.append(n)
    return out

def profile_set(profile: str) -> Tuple[int, str]:
    return run([PROFILES_SCRIPT, profile], timeout=180)

def modem_connect() -> Tuple[bool, str]:
    run(["pkill", "-x", "pppd"])
    run(["rm", "-f", "/var/lock/LCK..ttyUSB*"])
    try:
        subprocess.Popen([PPPD_BIN, "call", PPP_PEER], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
    except Exception as e:
        return False, f"erro ao iniciar pppd: {e}"
    deadline = time.time() + 20
    up = False
    while time.time() < deadline:
        rc, _ = run([IP_BIN, "link", "show", PPP_IF])
        if rc == 0:
            up = True
            break
        time.sleep(1.0)
    if up:
        return True, "pppd call enviado e ppp0 ativo"
    rc1, j1 = run(["journalctl", "-b", "-n", "50", "--no-pager"])
    last: List[str] = []
    if rc1 == 0 and j1:
        for ln in j1.splitlines():
            if ("pppd" in ln.lower()) or ("chat" in ln.lower()):
                last.append(ln)
    msg = "ppp0 não subiu. "
    if last:
        msg += "Logs recentes: " + ("\n".join(last[-8:]))
    else:
        msg += "Sem logs do pppd/chat."
    return False, msg

def modem_disconnect() -> Tuple[bool, str]:
    rc, out = run(["poff", PPP_PEER], timeout=20)
    msg = (out or "").strip()
    if rc != 0 and ("No pppd is running" in msg or "None stopped" in msg):
        return True, "pppd já estava parado"
    if rc != 0:
        run(["pkill", "-x", "pppd"])
        run(["rm", "-f", "/var/lock/LCK..ttyUSB*"])
        return True, "pppd finalizado"
    return True, msg or "poff enviado"

def get_last_profile() -> str:
    path = "/var/lib/mirako/last_profile"
    try:
        with open(path, "r", encoding="utf-8") as f:
            return f.read().strip() or "ap"
    except Exception:
        return "ap"

# ========================== Template ==========================
TEMPLATE = """
<!doctype html>
<html lang="pt-br">
<head>
<meta charset="utf-8">
<title>Mirako — Orange Pi Router</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  :root{
    --bg:#0b0d10; --panel:#12161b; --muted:#9aa4b2; --text:#e6e6e6; --acc:#25a0ff;
    --ok:#2ea043; --ok-b:#1f4726;
    --warn:#e0b84f; --warn-b:#4a3f1d;
    --pri:#2563eb; --pri-b:#1e3a8a;
    --danger:#ef4444; --danger-b:#7f1d1d;
    --line:#1e252d;
    --radius: 10px;
    --shadow: 0 4px 12px rgba(0,0,0,0.15);
  }
  *{box-sizing:border-box}
  html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif}
  a{color:var(--acc);text-decoration:none} a:hover{text-decoration:underline}
  
.wrap{max-width:none;width:100%;margin:0 auto;padding:16px}

  .dashboard-grid, .main-grid, .network-section, .services-terminal-section{
  align-items: stretch;
}

.card{
  display:flex;
  flex-direction:column;
  min-height:0;
}

.card .bd{
  flex:1;
  min-height:0;
}

  .topbar{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:16px 20px;
    background:linear-gradient(135deg, #0f141a, #131a22);
    border:1px solid var(--line);
    border-radius:var(--radius);
    margin-bottom:20px;
    box-shadow: var(--shadow);
  }
  .brand{font-weight:700;font-size:1.25rem;color:var(--text)}
  .topbar .muted{font-size:0.9rem}
  
  /* Grid System */
  .dashboard-grid{
    display:grid;
    grid-template-columns:repeat(auto-fit, minmax(300px, 1fr));
    gap:20px;
    margin-bottom:20px;
  }
  
  .main-grid{
    display:grid;
    grid-template-columns:repeat(auto-fit, minmax(350px, 1fr));
    gap:20px;
    margin-bottom:20px;
  }
  
  .full-width{
    grid-column:1/-1;
  }
  
  /* Nova estrutura para redes, rotas e arquivos */
  .network-section {
    display: grid;
    grid-template-columns: 2fr 1fr;
    gap: 20px;
    margin-bottom: 20px;
  }
  
  .services-terminal-section {
    display: grid;
    grid-template-rows: auto auto;
    gap: 20px;
  }
  
  /* Card Styles */
  .card{
    background:var(--panel);
    border:1px solid var(--line);
    border-radius:var(--radius);
    box-shadow: var(--shadow);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    overflow:hidden;
  }
  
  .card:hover{
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0,0,0,0.2);
  }
  
  .card .hd{
    padding:14px 16px;
    border-bottom:1px solid var(--line);
    font-weight:600;
    display:flex;
    justify-content:space-between;
    align-items:center;
    background:rgba(15, 20, 26, 0.6);
  }
  
  .card .bd{
    padding:16px;
  }
  
  .card-section{
    margin-bottom:16px;
  }
  
  .card-section:last-child{
    margin-bottom:0;
  }
  
  .card-section-title{
    font-size:0.9rem;
    color:var(--muted);
    margin-bottom:8px;
    font-weight:500;
  }
  
  /* Status Grid */
  .status-grid{
    display:grid;
    grid-template-columns:repeat(3, 1fr);
    gap:12px;
  }
  
  .status-item{
    text-align:center;
    padding:12px;
    background:rgba(15, 20, 26, 0.4);
    border-radius:8px;
    border:1px solid var(--line);
  }
  
  .status-item .value{
    font-size:1.1rem;
    font-weight:600;
    margin:4px 0;
  }
  
  .status-item .label{
    font-size:0.85rem;
    color:var(--muted);
  }
  
  /* Data Grid */
  .data-grid{
    display:grid;
    grid-template-columns:repeat(auto-fit, minmax(200px, 1fr));
    gap:12px;
  }
  
  .data-item{
    padding:8px 0;
  }
  
  .data-item .label{
    font-size:0.85rem;
    color:var(--muted);
    margin-bottom:4px;
  }
  
  .data-item .value{
    font-size:0.95rem;
    font-weight:500;
  }
  
  /* Buttons */
  .btn{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    padding:10px 16px;
    border:1px solid var(--line);
    border-radius:8px;
    background:#16212c;
    color:var(--text);
    cursor:pointer;
    transition:all .15s ease-in-out;
    font-weight:500;
    gap:6px;
  }
  
  .btn:hover{
    filter:brightness(1.1);
    transform:translateY(-1px);
    box-shadow:0 4px 8px rgba(0,0,0,0.15);
  }
  
  .btn.small{
    padding:6px 10px;
    font-size:0.85rem;
  }
  
  .btn.ok{background:linear-gradient(135deg, var(--ok), #238636);border-color:var(--ok-b)}
  .btn.warn{background:linear-gradient(135deg, var(--warn), #b5892e);border-color:var(--warn-b);color:#1b1407}
  .btn.primary{background:linear-gradient(135deg, var(--pri), #1d4ed8);border-color:var(--pri-b)}
  .btn.danger{background:linear-gradient(135deg, var(--danger), #b91c1c);border-color:var(--danger-b)}
  .btn.outline{background:transparent;border-color:var(--line)}
  
  .btn-group{
    display:flex;
    gap:8px;
    flex-wrap:wrap;
  }
  
  /* Form Elements */
  .form-group{
    margin-bottom:16px;
  }
  
  .form-group:last-child{
    margin-bottom:0;
  }
  
  .form-label{
    display:block;
    margin-bottom:6px;
    font-weight:500;
    font-size:0.9rem;
  }
  
  input[type=text],input[type=password],input[type=file],select{
    width:100%;
    padding:10px 12px;
    border:1px solid var(--line);
    border-radius:8px;
    background:#0e141a;
    color:#e6e6e6;
    font-size:0.95rem;
    transition:border-color 0.2s ease;
  }
  
  input[type=text]:focus,input[type=password]:focus,select:focus{
    outline:none;
    border-color:var(--acc);
  }
  
  .checkbox-group{
    display:flex;
    align-items:center;
    gap:8px;
  }
  
  /* Tables */
  .table{
    width:100%;
    border-collapse:collapse;
    font-size:0.9rem;
  }
  
  .table th,.table td{
    border-bottom:1px solid var(--line);
    padding:10px 8px;
    vertical-align:middle;
  }
  
  .table th{
    text-align:left;
    color:var(--muted);
    font-weight:600;
    font-size:0.85rem;
  }
  
  .table tr:hover{
    background:#131a22;
  }
  
  .table-compact th, .table-compact td{
    padding:6px 8px;
  }
  
  /* Utility Classes */
  .muted{color:var(--muted)}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,'Liberation Mono',monospace}
  .text-center{text-align:center}
  .hidden{display:none}
  
  .pill{
    display:inline-block;
    padding:4px 10px;
    border-radius:999px;
    background:#10151b;
    border:1px solid var(--line);
    font-size:.85rem;
    font-weight:500;
  }
  
  .okpill{background:#102216;border-color:#194d2b;color:#4ade80}
  .warnpill{background:#241f10;border-color:#4a3f1d;color:#facc15}
  .dangerpill{background:#2a1515;border-color:#7f1d1d;color:#f87171}
  
  .flash{
    padding:12px 16px;
    border:1px solid var(--line);
    border-radius:8px;
    background:#0f141a;
    margin-bottom:16px;
    box-shadow:0 2px 8px rgba(0,0,0,0.1);
  }
  
  .desc{
    background:#0f141a;
    border:1px dashed var(--line);
    border-radius:8px;
    padding:12px;
    font-size:0.9rem;
    line-height:1.4;
  }
  
  .logbox{
    background:#0b0d10;
    border:1px solid var(--line);
    border-radius:8px;
    padding:12px;
    height:50vh;
    overflow:auto;
    color:#d6d6d6;
    font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,'Liberation Mono',monospace;
    font-size:0.9rem;
    line-height:1.4;
  }
  
  pre{white-space:pre-wrap;word-wrap:break-word;margin:0}
  
  .ssid-row{cursor:pointer}
  
  /* Responsive */
  @media (max-width: 1024px) {
    .network-section {
      grid-template-columns: 1fr;
    }
    
    .status-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }
  
  @media (max-width: 768px) {
    .dashboard-grid, .main-grid {
      grid-template-columns:1fr;
    }
    
    .status-grid, .data-grid {
      grid-template-columns:repeat(2, 1fr);
    }
    
    .btn-group {
      flex-direction:column;
    }
    
    .btn-group .btn {
      width:100%;
    }
  }
  
  @media (max-width: 480px) {
    .status-grid, .data-grid {
      grid-template-columns:1fr;
    }
    
    .topbar {
      flex-direction:column;
      gap:8px;
      text-align:center;
    }
  }
</style>
</head>
<body>
<!-- LOGIN OVERLAY (mínimo) -->
<style>
  .login-overlay{
    position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
    background:rgba(0,0,0,.55); backdrop-filter: blur(2px); z-index:9999;
  }
  .login-card{
    width:min(420px, 92vw);
    background:var(--panel);
    border:1px solid var(--line);
    border-radius:var(--radius);
    box-shadow: var(--shadow);
    padding:18px;
  }
  .login-card h2{margin:0 0 12px 0; font-size:1.15rem}
  .login-error{margin-top:10px; color:#f87171; font-size:.9rem}
  .wrap.blurred{ filter: blur(3px) saturate(.8); }
</style>

<div id="login_overlay" class="login-overlay" style="display:flex" role="dialog" aria-modal="true" aria-labelledby="login_title">
  <div class="login-card">
    <h2 id="login_title">Mirako Router</h2>
    <form id="login_form" autocomplete="on">
      <div class="form-group">
        <label class="form-label" for="login_user">Usuário</label>
        <input type="text" id="login_user" autocomplete="username" required>
      </div>
      <div class="form-group">
        <label class="form-label" for="login_pass">Senha</label>
        <input type="password" id="login_pass" autocomplete="current-password" required>
      </div>
      <div class="form-group checkbox-group">
        <input type="checkbox" id="login_show">
        <label for="login_show">Mostrar senha</label>
      </div>
      <button type="submit" class="btn ok" style="width:100%">Entrar</button>
      <div id="login_err" class="login-error" style="display:none"></div>
    </form>
  </div>
</div>



  <div class="wrap">
    <!-- Top Bar -->
    <div class="topbar">
      <div class="brand">Mirako Router</div>
      <div class="muted">Orange Pi — Debian</div>
    </div>

    <!-- Flash Messages -->
    {% with messages = get_flashed_messages() %}
      {% if messages %}
        {% for msg in messages %}
          <div class="flash">{{ msg|safe }}</div>
        {% endfor %}
      {% endif %}
    {% endwith %}

    <!-- Dashboard Grid -->
    <div class="dashboard-grid">
      <!-- Perfis Card -->
      <div class="card">
        <div class="hd">
          <span>Perfis de Rede</span>
          <form method="post" action="{{ url_for('profiles_status_route') }}">
            <button class="btn small outline" title="profiles.sh status">Status</button>
          </form>
        </div>
        <div class="bd">
<div class="card-section">
  <div class="card-section-title">Perfil Desejado (boot)</div>
  <div class="pill mono" id="desired_profile">{{ desired_profile }}</div>
</div>

<div class="card-section">
  <div class="card-section-title">Perfil Ativo (runtime)</div>
  <div class="pill mono" id="active_profile">{{ active_profile }}</div>
</div>

<div id="ap_fallback_banner" class="flash" style="display:{% if ap_fallback_rem>0 %}block{% else %}none{% endif %}; border-color:#4a3f1d;">
  <b>⚠️ AP fallback ativo</b>
  <div class="muted">Restam <span class="mono" id="ap_fallback_rem">{{ ap_fallback_rem }}</span>s</div>
</div>

          
          <div class="card-section">
            <div class="card-section-title">Selecionar Perfil</div>
            <form method="post" action="{{ url_for('setprofile') }}">
              <div class="form-group">
                <select name="profile" id="profile_select" required>
                  <option value="ap">ap — AP em wlan0; uplink/NAT por end0</option>
                  <option value="wifi-router">wifi-router — Cliente Wi-Fi + LAN</option>
                  <option value="client-wifi">client-wifi — wlan0 cliente; end0 cliente</option>
                  <option value="client-lan">client-lan — apenas end0 cliente</option>
                  <option value="3g">3g — AP em wlan0 via ppp0</option>
                  <option value="3g-client">3g-client — AP via ppp0; end0 cliente</option>
                </select>
              </div>
              
              <div class="btn-group">
                <button class="btn primary" title="Aplicar perfil">Aplicar</button>
              </div>
            </form>
          </div>
          
          <div class="card-section">
            <div class="card-section-title">Descrição</div>
            <div id="profile_desc" class="desc mono"></div>
          </div>
        </div>
      </div>

      <!-- Sistema Card -->
      <div class="card">
        <div class="hd">Status do Sistema</div>
        <div class="bd">
          <div class="status-grid">
            <div class="status-item">
              <div class="label">Temp CPU</div>
              <div class="value mono" id="sys_temp">{{ cpu_temp }}</div>
            </div>
            <div class="status-item">
              <div class="label">Uso CPU</div>
              <div class="value mono" id="sys_cpu">{{ cpu_pct }}%</div>
            </div>
            <div class="status-item">
              <div class="label">Memória</div>
              <div class="value mono" id="sys_mem">{{ mem_pct }}%</div>
              <div class="value mono" id="sys_mem_detail">{{ mem_used }} / {{ mem_total }}</div>
            </div>
            <div class="status-item">
              <div class="label">Disco (/)</div>
             <div class="value mono" id="sys_disk">{{ disk_pct }}%</div>
             <div class="value mono" id="sys_disk_detail">{{ disk_used }} / {{ disk_total }}</div>
            </div>
            <div class="status-item">
              <div class="label">Uptime</div>
              <div class="value mono" id="sys_uptime">{{ uptime }}</div>
            </div>
            <div class="status-item">
<div class="label">Processadores</div>
<div class="value mono" id="sys_cpus">{{ cpu_used }} / {{ cpu_count }}</div>


            </div>
          </div>
          


          
        </div>
      </div>

      <!-- Modem Card -->
      <div class="card">
        <div class="hd">Modem 3G/PPP ({{PPP_IF}})</div>
        <div class="bd">
          <div class="card-section">
            <div class="btn-group">
              <form method="post" action="{{ url_for('modem_connect_route') }}">
                <button class="btn ok">Conectar</button>
              </form>
              <form method="post" action="{{ url_for('modem_disconnect_route') }}">
                <button class="btn warn">Desconectar</button>
              </form>
            </div>
          </div>
          
          <div class="card-section">
            <form method="post" action="{{ url_for('modem_auto_dial_route') }}">
              <div class="checkbox-group">
                <input type="checkbox" id="autoDialToggle" name="auto_dial" value="1" {% if auto_dial_enabled %}checked{% endif %} onchange="this.form.submit()">
                <label for="autoDialToggle">Discagem automática (3G)</label>
              </div>
            </form>
          </div>
          
          <div class="card-section">
            <div class="card-section-title">IPv4 ({{PPP_IF}})</div>
            <pre class="mono" id="ppp_ipv4">{{ ppp_ipv4 }}</pre>
          </div>
        </div>
      </div>
    </div>

    <!-- Wi-Fi Card (full width) -->
    <div class="card full-width">
      <div class="hd">
        <span>Wi-Fi ({{WLAN_IF}})</span>

<button
  type="button"
  class="btn small warn"
  onclick="scanRebootConfirm()"
>
  Scan Wi-Fi (reiniciar)
</button>



      </div>
      <div class="bd">
        <div class="card-section">
          <div class="data-grid">
            <div class="data-item">
              <div class="label">Modo / Estado</div>
              <div class="value" id="wf_mode_state">{{ wifi.mode }} / {{ wifi.state }}</div>
            </div>
            <div class="data-item">
              <div class="label">SSID / BSSID</div>
              <div class="value mono" id="wf_ssid_bssid">{{ wifi.ssid }} | {{ wifi.bssid }}</div>
            </div>
            <div class="data-item">
              <div class="label">Canal / Freq / TX pwr</div>
              <div class="value" id="wf_chan_freq_txp">{{ wifi.channel }} / {{ wifi.freq_mhz }} / {{ wifi.txpower }}</div>
            </div>
            <div class="data-item">
              <div class="label">RSSI</div>
              <div class="value" id="wf_rssi">{{ wifi.rssi }}</div>
            </div>
            <div class="data-item">
              <div class="label">Distância (est.)</div>
              <div class="value" id="wf_dist">{{ wifi.distance_m }}</div>
            </div>
            <div class="data-item">
              <div class="label">Bitrate TX / RX</div>
              <div class="value" id="wf_rates">{{ wifi.tx_bitrate }} / {{ wifi.rx_bitrate }}</div>
            </div>
            <div class="data-item">
              <div class="label">Clientes (se AP)</div>
              <div class="value" id="wf_clients">{{ wifi.clients }}</div>
            </div>
            <div class="data-item">
              <div class="label">Tráfego (bytes)</div>
              <div class="value" id="wf_bytes">TX: {{ wifi.tx_bytes }} — RX: {{ wifi.rx_bytes }}</div>
            </div>
            <div class="data-item">
              <div class="label">Taxa instantânea</div>
              <div class="value" id="wf_bps">TX: {{ wifi.tx_bps }} — RX: {{ wifi.rx_bps }}</div>
            </div>
          </div>
        </div>
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
        
 <div class="card-section">
  <div class="card-section-title">Wi-Fi Salvos</div>

  {% if wifi_saved and wifi_saved|length > 0 %}
  <table class="table table-compact">
    <thead>
      <tr>
        <th>SSID</th>
        <th>Senha</th>
        <th>Ações</th>
      </tr>
    </thead>
    <tbody>
      {% for w in wifi_saved %}
      <tr>
        <td class="mono">{{ w.ssid }}</td>
<td class="mono">{{ w.psk|e if w.psk else '(aberta)' }}</td>
        <td>
          <div class="btn-group">
            <form method="post" action="{{ url_for('wifi_connect_saved_route') }}">
              <input type="hidden" name="id" value="{{ w.id }}">
              <button class="btn small ok" type="submit">Conectar</button>
            </form>

<button class="btn small outline" type="button"
        onclick='wifiEdit({{ w.id|tojson }}, {{ w.ssid|tojson }}, {{ w.psk|tojson }})'>
  Editar
</button>



            <form method="post" action="{{ url_for('wifi_delete_route') }}"
                  onsubmit="return confirm('Excluir o Wi-Fi {{ w.ssid|e }}?');">
              <input type="hidden" name="id" value="{{ w.id }}">
              <button class="btn small danger" type="submit">Excluir</button>
            </form>
          </div>
        </td>
      </tr>
      {% endfor %}
    </tbody>
  </table>
  {% else %}
  <div class="muted">Nenhum Wi-Fi salvo ainda.</div>
  {% endif %}
</div>

<div class="card-section">
  <div class="card-section-title">Adicionar / Editar Wi-Fi</div>

  <form method="post" action="{{ url_for('wifi_save_route') }}" id="wifi_save_form">
    <input type="hidden" name="id" id="wifi_edit_id" value="">
    <div class="form-group">
      <label class="form-label" for="ssidFieldSave">SSID</label>
      <input type="text" name="ssid" id="ssidFieldSave" required>
    </div>

    <div class="form-group">
      <label class="form-label" for="pskFieldSave">
        Senha (deixe vazio para manter a senha ao editar / ou rede aberta)
      </label>
<input type="text" name="psk" id="pskFieldSave" autocomplete="off">
    </div>

    <div class="btn-group">
      <button class="btn primary" type="submit" id="wifi_save_btn">Salvar</button>
      <button class="btn outline" type="button" onclick="wifiClearEdit()">Limpar</button>
    </div>
  </form>
</div>

       
          <div class="card-section">
            <form method="post" action="{{ url_for('wifi_disconnect_route') }}">
              <button class="btn warn">Desconectar Wi-Fi</button>
            </form>
          </div>
        </div>
        
        {% if wpa_file_networks and wpa_file_networks|length > 0 %}
        <div class="card-section">
          <div class="card-section-title">Rede do wpa_supplicant</div>
          <table class="table table-compact">
            <thead>
              <tr>
                <th>SSID</th>
                <th>Auth</th>
                <th>Key mgmt</th>
                <th>Priority</th>
              </tr>
            </thead>
            <tbody>
              {% for n in wpa_file_networks %}
<tr class="ssid-row" data-ssid="{{ n.ssid|e }}"
    onclick="wifiFillFromScan(this.dataset.ssid);">

                <td class="mono">{{ n.ssid }}</td>
                <td>{{ n.psk }}</td>
                <td>{{ n.key_mgmt }}</td>
                <td class="mono">{{ n.priority }}</td>
              </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
        {% endif %}
        
        {% if saved_networks and saved_networks|length > 0 %}
        <div class="card-section">
          <div class="card-section-title">Redes salvas (wpa_cli)</div>
          <table class="table table-compact">
            <thead>
              <tr>
                <th>ID</th>
                <th>SSID</th>
                <th>Flags</th>
              </tr>
            </thead>
            <tbody>
              {% for n in saved_networks %}
              <tr>
                <td class="mono">{{ n.id }}</td>
                <td class="mono">{{ n.ssid }}</td>
                <td>{{ n.flags }}</td>
              </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
        {% endif %}
        
        {% if scan %}
        <div class="card-section">
          <div class="card-section-title">Redes detectadas antes do AP (último boot)</div>
          <table class="table table-compact">
            <thead>
              <tr>
                <th>SSID</th>
                <th>Signal</th>
                <th>Freq</th>
                <th>Segurança</th>
              </tr>
            </thead>
            <tbody>
              {% for n in scan %}
<tr class="ssid-row" data-ssid="{{ n.ssid|e }}"
    onclick="wifiFillFromScan(this.dataset.ssid);">
                <td class="mono">{{ n.ssid }}</td>
                <td>{{ n.signal }}</td>
                <td>{{ n.freq }}</td>
                <td>{{ n.security }}</td>
              </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
        {% elif scan_dbg %}
        <div class="card-section">
          <div class="muted"><small>{{ scan_dbg }}</small></div>
        </div>
        {% endif %}
      </div>
    </div>













    <!-- Nova Seção: Redes, Rotas DNS, DHCP e Arquivos -->
    <div class="network-section">
      <!-- Coluna da Esquerda: Interfaces de Rede e DHCP Leases -->
      <div>
        <!-- Interfaces de Rede Card -->
        <div class="card">
          <div class="hd">Interfaces de Rede</div>
          <div class="bd">
            <table class="table table-compact">
              <thead>
                <tr>
                  <th>Interface</th>
                  <th>Estado</th>
                  <th>IPv4</th>
                  <th>RX</th>
                  <th>TX</th>
                </tr>
              </thead>
              <tbody id="if_table_body">
                {% for n in netlist %}
                <tr>
                  <td class="mono">{{ n.dev }}</td>
                  <td>{{ n.state }}</td>
                  <td class="mono">{{ n.ipv4 }}</td>
                  <td>{{ n.rx }}</td>
                  <td>{{ n.tx }}</td>
                </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        </div>

        <!-- DHCP Card (movido para baixo das Interfaces) -->
<div class="card">
  <div class="hd">DHCP Leases</div>
  <div class="bd">
    <table class="table table-compact">
      <thead>
        <tr>
          <th>IP</th>
          <th>Host</th>
          <th>MAC</th>
          <th>Expira</th>
        </tr>
      </thead>
      <tbody id="leases_table_body"></tbody>
    </table>

    <div id="leases_empty" class="text-center muted">Carregando…</div>
  </div>
</div>
</div>


      <!-- Coluna da Direita: Rotas DNS e Gerenciador de Arquivos -->
      <div>
        <!-- Rotas & DNS Card -->
        <div class="card">
          <div class="hd">Rotas & DNS</div>
          <div class="bd">
            <div class="card-section">
              <div class="card-section-title">Rota Padrão</div>
              <pre class="mono" id="def_route">{{ def_route }}</pre>
            </div>
            
            <div class="card-section">
              <div class="card-section-title">Todas as Rotas</div>
              <pre class="mono" id="all_routes">{{ all_routes }}</pre>
            </div>
            
            <div class="card-section">
              <div class="card-section-title">Servidores DNS</div>
              <pre class="mono" id="dns_info">{{ dns }}</pre>
            </div>
          </div>
        </div>

        <!-- Gerenciador de Arquivos Card -->
        <div class="card">
          <div class="hd">Gerenciador de Arquivos</div>
          <div class="bd">
            <div class="card-section">
              <div class="card-section-title">Enviar Arquivo</div>
              <form method="post" enctype="multipart/form-data" action="{{ url_for('file_upload_route') }}">
                <div class="form-group">
                  <input type="file" name="file" required>
                </div>
                <button class="btn primary">Enviar</button>
              </form>
            </div>
            
            {% if root_files and root_files|length > 0 %}
            <div class="card-section">
              <div class="card-section-title">Arquivos em /root</div>
              <table class="table table-compact">
                <tbody>
                  {% for f in root_files %}
                  <tr>
                    <td><a href="{{ url_for('file_download', filename=f) }}" class="mono">{{ f }}</a></td>
                  </tr>
                  {% endfor %}
                </tbody>
              </table>
            </div>
            {% endif %}
          </div>
        </div>
      </div>
    </div>

    <!-- Seção Terminal e Serviços -->
    <div class="services-terminal-section">
      <!-- Terminal Card -->
 <div class="card full-width" id="terminal_card">
  <div class="hd">
    <span>Terminal (ttyd)</span>
    <div class="btn-group">
      <a class="btn small ok" href="http://{{ host_ip }}:7681/" target="_blank" rel="noopener">Abrir</a>
      <button class="btn small outline" type="button" onclick="toggleTerminalEmbed()">Embed</button>
    </div>
  </div>

  <div class="bd">
    <div id="terminal_embed" class="hidden" style="margin-top:10px;">
      <div class="muted" style="margin-bottom:8px;">
        Login: <span class="mono">admin</span> / <span class="mono">qazwsx</span>
      </div>
      <iframe
        src="http://{{ host_ip }}:7681/"
        style="width:100%; height:60vh; border:1px solid var(--line); border-radius:8px; background:#0b0d10;"
        loading="lazy"
      ></iframe>
    </div>
  </div>
</div>


      <!-- Serviços Card -->
      <div class="card full-width">
        <div class="hd">
          <span>Serviços do Sistema</span>
          <button id="toggle_services_btn" class="btn small outline" type="button" onclick="toggleServices()">Ver serviços</button>
        </div>
        <div class="card hidden" id="services_card">
          <div class="bd">
            <table class="table table-compact">
              <thead>
                <tr>
                  <th>Serviço</th>
                  <th>Status</th>
                  <th>Enabled</th>
                  <th>Ações</th>
                </tr>
              </thead>
              <tbody id="svc_table_body">
                {% for s in services %}
                <tr>
                  <td class="mono">{{ s.name }}</td>
                  <td>
                    <span class="pill {{ 'okpill' if s.active else 'dangerpill' }}">
                      {{ 'ativo' if s.active else 'inativo' }}
                    </span>
                  </td>
                  <td>
                    <span class="pill {{ 'okpill' if s.enabled else 'warnpill' }}">
                      {{ 'habilitado' if s.enabled else 'desabilitado' }}
                    </span>
                  </td>
                  <td>
                    <form method="post" action="{{ url_for('svc_action_route') }}">
                      <input type="hidden" name="svc" value="{{ s.name }}">
                      <div class="btn-group">
                        <button class="btn small ok" name="action" value="start">Start</button>
                        <button class="btn small warn" name="action" value="stop">Stop</button>
                        <button class="btn small primary" name="action" value="restart">Restart</button>
                        {% if s.enabled %}
                        <button class="btn small outline" name="action" value="disable">Disable</button>
                        {% else %}
                        <button class="btn small primary" name="action" value="enable">Enable</button>
                        {% endif %}
                      </div>
                    </form>
                  </td>
                </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>
<script>
/* ===== AUTH super simples (plaintext) =====
   Lê /auth/users.json -> { "users": { "admin": "qazwsx", ... } }
   Salva sessão em localStorage por TTL fixo (minutos).
*/
const AUTH_URL = '/auth/users.json';
const AUTH_KEY = 'auth_session_v1';
const AUTH_TTL_MIN = 720; // 12h (ajuste se quiser)

function isAuthed(){
  try{
    const raw = localStorage.getItem(AUTH_KEY);
    if(!raw) return false;
    const s = JSON.parse(raw);
    if(!s?.user || !s?.exp) return false;
    if(Date.now() > s.exp){ localStorage.removeItem(AUTH_KEY); return false; }
    return true;
  }catch(e){ return false; }
}

function showOverlay(){
  const ov = document.getElementById('login_overlay');
  const wrap = document.querySelector('.wrap');
  if(ov) ov.style.display = 'flex';
  if(wrap) wrap.classList.add('blurred');
}

function hideOverlay(){
  const ov = document.getElementById('login_overlay');
  const wrap = document.querySelector('.wrap');
  if(ov) ov.style.display = 'none';
  if(wrap) wrap.classList.remove('blurred');
}

async function loadUsers(){
  const r = await fetch(AUTH_URL, {cache:'no-store'});
  if(!r.ok) throw new Error('Falha ao ler usuários');
  const j = await r.json();
  return j?.users || {};
}

async function doLogin(ev){
  ev?.preventDefault();
  const u = document.getElementById('login_user')?.value?.trim() || '';
  const p = document.getElementById('login_pass')?.value || '';
  const err = document.getElementById('login_err');

  let users = {};
  try{ users = await loadUsers(); }
  catch(e){ if(err){ err.style.display='block'; err.textContent='Erro ao carregar usuários.'; } return; }

  if(!users[u] || users[u] !== p){
    if(err){ err.style.display='block'; err.textContent='Usuário ou senha inválidos.'; }
    return;
  }

  const exp = Date.now() + AUTH_TTL_MIN*60*1000;
  try{ localStorage.setItem(AUTH_KEY, JSON.stringify({user:u, exp})); }catch(e){}
  hideOverlay();
}

(function(){
  // eventos
  document.getElementById('login_form')?.addEventListener('submit', doLogin);
  document.getElementById('login_pass')?.addEventListener('keypress', e=>{ if(e.key==='Enter') doLogin(e); });
  document.getElementById('login_show')?.addEventListener('change', e=>{
    const pass = document.getElementById('login_pass');
    if(pass) pass.type = e.target.checked ? 'text' : 'password';
  });

  // estado inicial
  if(isAuthed()){ hideOverlay(); }
  else{
    showOverlay();
    // autofocus
    setTimeout(()=> document.getElementById('login_user')?.focus(), 0);
  }
})();
</script>


<script>
// Funções JavaScript existentes (mantidas do código original)


function scanRebootConfirm(){
  if(!confirm(
    "O Mirako será reiniciado para escanear redes Wi-Fi antes do AP.Deseja continuar?"
  )) return;

  fetch('/scan-reboot', { method: 'POST' })
    .then(() => {
      alert("Reiniciando para scan Wi-Fi…");
    });
}


function togglePass(){
  var ps = document.getElementById('pskField');
  if(ps){ ps.type = (ps.type === 'password') ? 'text' : 'password'; }
}

/* ===== Descrição dos perfis ===== */
const PROFILE_DESCS = {
  "ap": "AP em wlan0; uplink/NAT por end0 (create_ap --no-virt). end0 atua como WAN (DHCP cliente).",
  "wifi-router": "Cliente Wi-Fi em wlan0 (WAN); end0 entrega LAN 192.168.50.0/24 com DHCP+NAT.",
  "client-wifi": "wlan0 cliente no SSID; end0 também cliente (sem NAT/DHCP locais).",
  "client-lan": "Apenas end0 como cliente DHCP (scan por cabo). wlan0 livre para scan.",
  "3g": "AP em wlan0 roteando via ppp0; end0 com LAN 192.168.60.0/24 + DHCP e NAT para ppp0.",
  "3g-client": "AP em wlan0 via ppp0; end0 recebe IP por DHCP interno (sem NAT local no end0)."
};
function updateProfileDesc(){
  var sel = document.getElementById('profile_select');
  var out = document.getElementById('profile_desc');
  if(!sel || !out) return;
  var v = sel.value || '';
  out.textContent = PROFILE_DESCS[v] || '';
}
(function(){
  var sel = document.getElementById('profile_select');
  if(sel){
    sel.addEventListener('change', updateProfileDesc);
    try{ sel.value = "{{ last_profile }}"; }catch(e){}
    updateProfileDesc();
  }
})();

/* ===== Atualização de STATUS a cada 15s ===== */
async function fetchStatus(){
  try{
    const r = await fetch('/status.json?ts=' + Date.now());
    if(!r.ok) return;
    const j = await r.json();

    setText('wf_mode_state', j.wifi.mode+' / '+j.wifi.state);
    setText('wf_ssid_bssid', j.wifi.ssid+' | '+j.wifi.bssid);
    setText('wf_chan_freq_txp', j.wifi.channel+' / '+j.wifi.freq_mhz+' / '+j.wifi.txpower);
    setText('wf_rssi', j.wifi.rssi);
    setText('wf_dist', j.wifi.distance_m);
    setText('wf_rates', j.wifi.tx_bitrate+' / '+j.wifi.rx_bitrate);
    setText('wf_clients', j.wifi.clients);
    setText('wf_bytes', 'TX: '+j.wifi.tx_bytes+' — RX: '+j.wifi.rx_bytes);
    setText('wf_bps', 'TX: '+j.wifi.tx_bps+' — RX: '+j.wifi.rx_bps);

    setText('sys_temp', j.cpu_temp);
    setText('sys_cpu', j.cpu_pct+'%');
    setText('sys_mem', j.mem.pct+'%');
    setText('sys_disk', j.disk.pct+'%');
    setText('sys_mem_detail', j.mem.used+' / '+j.mem.total);
    setText('sys_disk_detail', j.disk.used+' / '+j.disk.total);
    setText('sys_uptime', j.uptime);
    setText('sys_cpus', j.cpu_used+' / '+j.cpu_count);
    setText('desired_profile', j.desired_profile || '-');
    setText('active_profile', j.active_profile || '-');

const banner = document.getElementById('ap_fallback_banner');
if (banner){
  const rem = Number(j.ap_fallback_rem || 0);
  banner.style.display = rem > 0 ? 'block' : 'none';
  setText('ap_fallback_rem', rem);
}



const ifTbody = document.querySelector('#if_table_body');
if (ifTbody){
  ifTbody.innerHTML = '';
  (j.netlist || []).forEach(n=>{
    const tr = document.createElement('tr');
    tr.innerHTML =
      '<td class="mono">'+n.dev+'</td>'+
      '<td>'+n.state+'</td>'+
      '<td class="mono">'+n.ipv4+'</td>'+
      '<td>'+n.rx+'</td>'+
      '<td>'+n.tx+'</td>';
    ifTbody.appendChild(tr);
  });
}


    setText('def_route', j.def_route);
    setText('all_routes', j.all_routes);
    setText('dns_info', j.dns);
    setText('ppp_ipv4', j.ppp_ipv4);

const leasesBody = document.querySelector('#leases_table_body');
const leasesEmpty = document.getElementById('leases_empty');

if (leasesBody){
  const leases = Array.isArray(j.leases) ? j.leases : [];
  leasesBody.innerHTML = '';

  if (leases.length){
    if (leasesEmpty) leasesEmpty.style.display = 'none';

    leases.forEach(L=>{
      const tr = document.createElement('tr');
      tr.innerHTML =
        '<td class="mono">'+(L.ip||'-')+'</td>'+
        '<td class="mono">'+(L.hostname||'-')+'</td>'+
        '<td class="mono">'+(L.mac||'-')+'</td>'+
        '<td class="mono">'+(L.expiry||'-')+'</td>';
      leasesBody.appendChild(tr);
    });
  } else {
    if (leasesEmpty){
      leasesEmpty.style.display = 'block';
      leasesEmpty.textContent = 'Sem leases no momento.';
    }
  }
}




}catch(e){
  console.error('fetchStatus erro:', e);
}
}
function setText(id, txt){ var el=document.getElementById(id); if(el){ el.textContent = (txt!=null? String(txt): ''); } }
setInterval(fetchStatus, 15000);
fetchStatus();




function wifiEdit(id, ssid, psk){
  const idEl  = document.getElementById('wifi_edit_id');
  const ssidEl = document.getElementById('ssidFieldSave');
  const pskEl  = document.getElementById('pskFieldSave');
  const btn    = document.getElementById('wifi_save_btn');

  if(idEl) idEl.value = id || '';
  if(ssidEl) ssidEl.value = ssid || '';
  if(pskEl) pskEl.value = (psk || ''); // ✅ agora preenche a senha salva
  if(btn) btn.textContent = 'Atualizar';
  if(ssidEl) ssidEl.focus();
}

function wifiClearEdit(){
  const idEl  = document.getElementById('wifi_edit_id');
  const ssidEl = document.getElementById('ssidFieldSave');
  const pskEl  = document.getElementById('pskFieldSave');
  const btn    = document.getElementById('wifi_save_btn');

  if(idEl) idEl.value = '';
  if(ssidEl) ssidEl.value = '';
  if(pskEl) pskEl.value = '';
  if(btn) btn.textContent = 'Salvar';
}

function wifiFillFromScan(ssid){
  // quando clicar numa rede detectada, prepara para “novo cadastro”
  wifiClearEdit();
  const ssidEl = document.getElementById('ssidFieldSave');
  if(ssidEl){
    ssidEl.value = ssid || '';
    ssidEl.focus();
  }
}





/* ===== Terminal ===== */

function toggleTerminalEmbed(){
  const el = document.getElementById('terminal_embed');
  if(!el) return;
  el.classList.toggle('hidden');
}







let servicesPolling = null;

async function fetchServices(){
  try{
    const r = await fetch('/services.json?ts=' + Date.now(), {cache:'no-store'});
    if(!r.ok) return;
    const j = await r.json();

    const svtbody = document.querySelector('#svc_table_body');
    if (!svtbody) return;

    svtbody.innerHTML = '';

    (j.services || []).forEach(s=>{
      const pillA = s.active ? 'okpill' : 'dangerpill';
      const pillE = s.enabled ? 'okpill' : 'warnpill';
      const tr = document.createElement('tr');
      tr.innerHTML =
        '<td class="mono">'+s.name+'</td>'+
        '<td><span class="pill '+pillA+'">'+(s.active?'ativo':'inativo')+'</span></td>'+
        '<td><span class="pill '+pillE+'">'+(s.enabled?'habilitado':'desabilitado')+'</span></td>'+
        '<td>'+
          '<form method="post" action="/svc_action">'+
            '<input type="hidden" name="svc" value="'+s.name+'">'+
            '<div class="btn-group">'+
              '<button class="btn small ok" name="action" value="start">Start</button>'+
              '<button class="btn small warn" name="action" value="stop">Stop</button>'+
              '<button class="btn small primary" name="action" value="restart">Restart</button>'+
              (s.enabled
                ? '<button class="btn small outline" name="action" value="disable">Disable</button>'
                : '<button class="btn small primary" name="action" value="enable">Enable</button>')+
            '</div>'+
          '</form>'+
        '</td>';
      svtbody.appendChild(tr);
    });

  }catch(e){}
}



/* Serviços: mostrar/ocultar */
function toggleServices(){
  const card = document.getElementById('services_card');
  const btn  = document.getElementById('toggle_services_btn');
  if(!card || !btn) return;

  const hiddenNow = card.classList.toggle('hidden');
  btn.textContent = hiddenNow ? 'Ver serviços' : 'Ocultar serviços';

  try { localStorage.setItem('svc_hidden', hiddenNow ? '1' : '0'); } catch(e){}

  if(!hiddenNow){
    fetchServices();
    if(servicesPolling) clearInterval(servicesPolling);
    servicesPolling = setInterval(fetchServices, 20000);
  } else {
    if(servicesPolling) clearInterval(servicesPolling);
    servicesPolling = null;
  }
}


(function(){
  const card = document.getElementById('services_card');
  const btn  = document.getElementById('toggle_services_btn');
  if(!card || !btn) return;

  let stored = null;
  try { stored = localStorage.getItem('svc_hidden'); } catch(e){}
  const hidden = (stored === null) ? true : (stored === '1');

  card.classList.toggle('hidden', hidden);
  btn.textContent = hidden ? 'Ver serviços' : 'Ocultar serviços';

  // ✅ se começa visível, carrega e liga polling
  if(!hidden){
    fetchServices();
    if(servicesPolling) clearInterval(servicesPolling);
    servicesPolling = setInterval(fetchServices, 20000);
  }
})();

</script>




</body>
</html>
"""

# ========================== Rotas ==========================
def list_root_files() -> List[str]:
    try:
        return [f for f in os.listdir("/root") if not f.startswith(".")]
    except Exception:
        return []

@app.route("/", methods=["GET"])
def index():
    # 🔁 sempre carrega o último scan salvo pelo profiles.sh
    scan, scan_dbg = get_cached_wifi_scan()
    saved_networks = get_saved_networks()
    wpa_file_networks = read_wpa_conf_networks()
    host_ip = request.host.split(":")[0]


    context = dict(
        WLAN_IF=WLAN_IF,
        LAN_IF=LAN_IF,
        PPP_IF=PPP_IF,
        PPP_PEER=PPP_PEER,
        desired_profile=get_last_profile(),
        active_profile=get_active_profile(),
        ap_fallback_rem=ap_fallback_remaining_sec(),
        wifi_saved=wifi_saved_list(),
        host_ip=host_ip,


        


        # ---- Wi-Fi (placeholders iniciais; atualizados via status.json) ----
        wifi={
            "mode": "-",
            "state": "-",
            "ssid": "-",
            "bssid": "-",
            "channel": "-",
            "freq_mhz": "-",
            "txpower": "-",
            "rssi": "-",
            "tx_bitrate": "-",
            "rx_bitrate": "-",
            "tx_bytes": "-",
            "rx_bytes": "-",
            "tx_bps": "0",
            "rx_bps": "0",
            "clients": 0,
            "distance_m": "-",
        },

        # ---- Rede / sistema (placeholders) ----
        ppp_ipv4="-",
        def_route="-",
        all_routes="-",
        dns="-",
        leases=[],
        netlist=[],

        services=[],        # NÃO carregar aqui (carregado via status.json)
        saved_networks=saved_networks,
        wpa_file_networks=wpa_file_networks,

        cpu_temp="-",
        cpu_pct="0.0",
        mem_used="-",
        mem_total="-",
        mem_pct="0.0",
        disk_used="-",
        disk_total="-",
        disk_pct="0.0",
        uptime="-",

        cpu_count=os.cpu_count() or 1,
        cpu_used="0.0",

        # ---- Estado do Mirako ----
        last_profile=get_last_profile(),
        root_files=list_root_files(),
        auto_dial_enabled=is_auto_dial_enabled(),

        # ✅ redes detectadas SEM clicar em botão
        scan=scan,
        scan_dbg=scan_dbg,
    )

    return render_template_string(TEMPLATE, **context)


@app.post("/wifi/save")
def wifi_save_route():
    item_id = (request.form.get("id") or "").strip()
    ssid = (request.form.get("ssid") or "").strip()
    psk = (request.form.get("psk") or "").strip()

    if not ssid:
        flash("Informe um SSID.")
        return redirect(url_for("index"))

    try:
        wifi_saved_upsert(item_id, ssid, psk)
        flash("✅ Wi-Fi salvo/atualizado.")
    except Exception as e:
        flash(f"❌ Erro ao salvar Wi-Fi: {e}")

    return redirect(url_for("index"))

@app.post("/wifi/delete")
def wifi_delete_route():
    item_id = (request.form.get("id") or "").strip()
    try:
        wifi_saved_delete(item_id)
        flash("✅ Wi-Fi removido.")
    except Exception as e:
        flash(f"❌ Erro ao remover Wi-Fi: {e}")
    return redirect(url_for("index"))

@app.post("/wifi/connect_saved")
def wifi_connect_saved_route():
    item_id = (request.form.get("id") or "").strip()
    it = wifi_saved_get(item_id)
    if not it:
        flash("Wi-Fi salvo não encontrado.")
        return redirect(url_for("index"))

    ok, msg = connect_wifi_guarded(it["ssid"], it.get("psk", ""))
    flash(msg)
    return redirect(url_for("index"))


@app.post("/wifi/connect")
def wifi_connect_route():
    ssid = (request.form.get("ssid") or "").strip()
    psk  = (request.form.get("psk") or "").strip()

    if not ssid:
        flash("Informe um SSID.")
        return redirect(url_for("index"))

    # salva na lista também (pode tirar se quiser “não salvar automático”)
    try:
        wifi_saved_upsert("", ssid, psk)
    except Exception:
        pass

    ok, msg = connect_wifi_guarded(ssid, psk)
    flash(msg)
    return redirect(url_for("index"))



@app.post("/wifi/disconnect")
def wifi_disconnect_route():
    # grava boot desejado
    try:
        os.makedirs("/var/lib/mirako", exist_ok=True)
        with open("/var/lib/mirako/last_profile", "w", encoding="utf-8") as f:
            f.write("ap\n")
            f.flush()
            os.fsync(f.fileno())
        os.sync()
    except Exception:
        pass

    try:
        with open("/var/lib/mirako/last_action", "w", encoding="utf-8") as f:
            f.write("wifi_disconnect_to_ap\n")
    except Exception:
        pass

    flash("🔁 Voltando para AP… reiniciando para aplicar de forma limpa.")

    # IMPORTANTE: tudo pesado em background (não derruba o HTTP)
    threading.Thread(target=switch_to_ap_and_reboot, daemon=True).start()

    # ✅ PRG: POST -> GET / (e o browser fica na home)
    return redirect(url_for("index"), code=303)




@app.post("/setprofile")
def setprofile():
    profile = (request.form.get("profile") or "").strip()
    if not profile:
        flash("Selecione um perfil.")
        return redirect(url_for("index"))

    # ✅ Se for AP: grava last_profile e reinicia (troca limpa do driver)
    if profile == "ap":
        try:
            os.makedirs("/var/lib/mirako", exist_ok=True)
            with open("/var/lib/mirako/last_profile", "w", encoding="utf-8") as f:
                f.write("ap\n")
                f.flush()
                os.fsync(f.fileno())
            os.sync()
        except Exception:
            pass

        try:
            with open("/var/lib/mirako/last_action", "w", encoding="utf-8") as f:
                f.write("switch_to_ap\n")
        except Exception:
            pass

        flash("🔁 Reiniciando para aplicar AP de forma limpa…")

        threading.Thread(target=switch_to_ap_and_reboot, daemon=True).start()

        return redirect(url_for("index"), code=303)




@app.post("/profiles/stop")
def profiles_stop_route():
    rc, out = run([PROFILES_SCRIPT, "stop"], timeout=120)
    flash(f"<b>profiles.sh stop</b>:<br><pre class='mono'>{(out or 'ok') if rc==0 else ('erro: '+(out or ''))}</pre>")
    return redirect(url_for("index"))

@app.post("/profiles/status")
def profiles_status_route():
    rc, out = run([PROFILES_SCRIPT, "status"], timeout=120)
    flash(f"<b>profiles.sh status</b>:<br><pre class='mono'>{out or '(sem saída)'}</pre>")
    return redirect(url_for("index"))

@app.post("/modem/connect")
def modem_connect_route():
    ok, msg = modem_connect()
    flash(("pon enviado" if ok else "Falha") + f" ({msg})")
    return redirect(url_for("index"))

@app.post("/modem/disconnect")
def modem_disconnect_route():
    ok, msg = modem_disconnect()
    flash(("poff enviado" if ok else "Falha") + f" ({msg})")
    return redirect(url_for("index"))

@app.post("/modem/auto_dial")
def modem_auto_dial_route():
    val = (request.form.get("auto_dial") or "").strip()
    enabled = val == "1"
    set_auto_dial(enabled)
    flash("Discagem automática " + ("habilitada" if enabled else "desabilitada"))
    return redirect(url_for("index"))

@app.post("/file/upload")
def file_upload_route():
    uploaded = request.files.get("file")
    if uploaded and uploaded.filename:
        filename = os.path.basename(uploaded.filename)
        save_path = os.path.join("/root", filename)
        try:
            uploaded.save(save_path)
            flash(f"Arquivo '{filename}' enviado para /root")
        except Exception as e:
            flash(f"Erro ao salvar arquivo: {e}")
    else:
        flash("Nenhum arquivo selecionado.")
    return redirect(url_for("index"))

# ===== Download seguro de /root =====
@app.get("/file/download/<path:filename>")
def file_download(filename):
    fn = os.path.basename(filename)
    if not fn or fn.startswith("."):
        abort(404)
    path = os.path.join("/root", fn)
    if not os.path.isfile(path):
        abort(404)
    return send_from_directory("/root", fn, as_attachment=True, download_name=fn)

@app.post("/svc_action")
def svc_action_route():
    svc = (request.form.get("svc") or "").strip()
    action = (request.form.get("action") or "").strip()
    if not svc or not action:
        flash("Ação ou serviço inválido.")
        return redirect(url_for("index"))
    ok, msg = service_action(svc, action)
    flash(("Sucesso" if ok else "Falha") + f" ({msg})")
    return redirect(url_for("index"))

# --------- Terminal ---------
@app.post("/shell/run")
def shell_run_route():
    cmd = (
        request.form.get("cmd")
        or (request.json.get("cmd") if request.is_json else "")
        or ""
    ).strip()
    if not cmd:
        return {"ok": False, "err": "comando vazio"}, 400
    start_command(cmd)
    return {"ok": True}

@app.get("/shell/log")
def shell_log_route():
    data = read_log_tail()
    return app.response_class(data, mimetype="text/plain; charset=utf-8")

@app.post("/shell/stop")
def shell_stop_route():
    stop_command()
    return {"ok": True}

@app.post("/shell/clear")
def shell_clear_route():
    clear_log()
    return {"ok": True}

def reboot_now() -> None:
    try:
        subprocess.Popen(["/sbin/shutdown", "-r", "now"])
    except Exception:
        subprocess.Popen(["/sbin/reboot"])


def reboot_delayed(delay_sec: float = 2.5) -> None:
    time.sleep(delay_sec)
    reboot_now()

def switch_to_ap_and_reboot() -> None:
    # opcional: parar tudo antes do reboot
    run([PROFILES_SCRIPT, "stop"], timeout=60)
    reboot_delayed(1.5)
    

@app.post("/reboot")
def shell_reboot_route():
    try:
        threading.Thread(target=reboot_now, daemon=True).start()
    except Exception as e:
        return {"ok": False, "err": str(e)}, 500
    return {"ok": True}




@app.post("/scan-reboot")
def scan_reboot_route():
    try:
        # opcional: marca motivo do reboot
        with open("/var/lib/mirako/last_action", "w") as f:
            f.write("scan_reboot\n")
    except Exception:
        pass

    try:
        subprocess.Popen(["/sbin/shutdown", "-r", "now"])
    except Exception:
        subprocess.Popen(["/sbin/reboot"])

    return {"ok": True}



@app.get("/auth/users.json")
def auth_users_json():
    def nocache(resp):
        resp.headers["Cache-Control"] = "no-store, max-age=0"
        resp.headers["Pragma"] = "no-cache"
        resp.headers["Expires"] = "0"
        return resp
    cfg = configparser.ConfigParser()
    if not os.path.exists(AUTH_INI):
        resp = make_response(jsonify({"users": {"admin": "qazwsx"}}))
        return nocache(resp)
    cfg.read(AUTH_INI)
    if "users" not in cfg or not dict(cfg["users"]):
        abort(404)
    users = dict(cfg["users"])
    return nocache(make_response(jsonify({"users": users})))

# --------- STATUS JSON (para atualização a cada 15s) ---------
@app.get("/status.json")
def status_json():
    t = cpu_temp_c()
    mem = mem_stats()
    disk = disk_stats("/")


    cpu_pct = round(cpu_usage_pct(), 1)
    cpu_count = os.cpu_count() or 1
    cpu_used  = round(max(0.0, min(cpu_count, (cpu_pct / 100.0) * cpu_count)), 1)

    leases, _, _ = read_dnsmasq_leases()
    payload = dict(
        wifi=wifi_status_details(),
        cpu_temp=(f"{t:.1f} °C" if t is not None else "-"),
        cpu_pct=cpu_pct,
        mem=dict(
            total=human_bytes(mem["total"]),
            used=human_bytes(mem["used"]),
            pct=f"{mem['pct']:.1f}",
        ),
        disk=dict(
            total=human_bytes(disk["total"]),
            used=human_bytes(disk["used"]),
            pct=f"{disk['pct']:.1f}",
        ),
        netlist=[net_stats_for(i) for i in list_interfaces(include_virtual=True, include_lo=True)],
        def_route=default_route(),
        all_routes=routes(),
        dns=dns_info(),
        leases=leases,
        ppp_ipv4=get_ipv4_list(PPP_IF),

        # >>> adicionados:
        uptime=uptime_str(),
        cpu_count=cpu_count,
        cpu_used=cpu_used,
        desired_profile=get_last_profile(),
        active_profile=get_active_profile(),
        ap_fallback_rem=ap_fallback_remaining_sec(),
    )
    return jsonify(payload)

# --------- Entrypoint ---------
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8080, threaded=True)

EOF

sudo systemctl restart mirako-web









































sudo tee /usr/local/bin/profiles.sh >/dev/null <<'SH'
#!/usr/bin/env bash
# profiles.sh — Mirako Network Profiles (COMPLETO / ROBUSTO)
#
# Regras principais:
# - last_profile (/var/lib/mirako/last_profile) = PERFIL DESEJADO (selecionado pela UI/boot)
# - active_profile (/var/lib/mirako/active_profile) = PERFIL ATIVO (informativo)
# - Se client-wifi / wifi-router falhar, sobe AP "temporário" SEM sobrescrever last_profile
# - Wi-Fi "OK" por padrão exige: ASSOCIADO + DHCP + (GW OU INTERNET) (configurável)
# - Cache de scan Wi-Fi para UI em /var/lib/mirako/wifi_scan.json (corrigido)

set -Eeuo pipefail
trap 'echo "[profiles][ERRO] linha $LINENO: $BASH_COMMAND" >&2' ERR

PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
LOGTAG="profiles"

# ================= INTERFACES =================
WLAN_IF="${WLAN_IF:-wlan0}"
LAN_IF="${LAN_IF:-end0}"
PPP_IF="${PPP_IF:-ppp0}"
PPP_PEER="${PPP_PEER:-3g}"

# ================= RETRY / TIMEOUTS =================
WIFI_RETRY_MAX="${WIFI_RETRY_MAX:-10}"
WIFI_RETRY_DELAY="${WIFI_RETRY_DELAY:-2}"
WIFI_ASSOC_TIMEOUT="${WIFI_ASSOC_TIMEOUT:-10}"          # segundos aguardando wpa_state=COMPLETED
WIFI_DHCP_TIMEOUT="${WIFI_DHCP_TIMEOUT:-12}"            # timeout DHCP no wlan0
WIFI_GW_PING_TIMEOUT="${WIFI_GW_PING_TIMEOUT:-2}"       # ping gateway (seg)

DHCP_WAN_TIMEOUT="${DHCP_WAN_TIMEOUT:-12}"              # dhcp no WAN (ex: end0 no perfil AP)
AP_FALLBACK_MARK_WINDOW="${AP_FALLBACK_MARK_WINDOW:-180}"  # marcação do fallback (seg)

# ================= WIFI VALIDATION =================
# Modos:
# - assoc_dhcp      => considera ok após ASSOCIADO + DHCP (sem ping)
# - gw              => exige ping no gateway
# - internet         => exige ping em IPs externos
# - gw_or_internet  => tenta GW; se falhar, aceita internet (PADRÃO)
WIFI_VALIDATE_MODE="${WIFI_VALIDATE_MODE:-assoc_dhcp}"

# IPs para teste externo (ICMP). Ajuste se a rede bloquear ping.
WIFI_TEST_IPS_DEFAULT=("1.1.1.1" "8.8.8.8")
# Permite override via env: WIFI_TEST_IPS="1.1.1.1 9.9.9.9"
if [ -n "${WIFI_TEST_IPS:-}" ]; then
  # shellcheck disable=SC2206
  WIFI_TEST_IPS_ARR=($WIFI_TEST_IPS)
else
  WIFI_TEST_IPS_ARR=("${WIFI_TEST_IPS_DEFAULT[@]}")
fi

# ================= PATHS =================
RUND="/run/mirako"
mkdir -p "$RUND" /etc/mirako /var/lib/mirako

LAST_FILE="/var/lib/mirako/last_profile"              # PERFIL DESEJADO (UI/boot)
ACTIVE_FILE="/var/lib/mirako/active_profile"          # PERFIL ATIVO (informativo)
FALLBACK_UNTIL_FILE="/var/lib/mirako/ap_fallback_until"

WIFI_ENV="/etc/mirako/wifi.env"
AP_ENV="/etc/mirako/ap.env"
LAST_ACTION_FILE="/var/lib/mirako/last_action"


HOSTAPD_CONF="$RUND/hostapd.conf"
WPA_CTRL_DIR="/run/wpa_supplicant"
WPA_CONF="/etc/wpa_supplicant/wpa_supplicant-${WLAN_IF}.conf"

WIFI_SCAN_CACHE="/var/lib/mirako/wifi_scan.json"

# ================= DEFAULTS (AP) =================
AP_SSID_DEFAULT="MirakoAP"
AP_PASS_DEFAULT="12345678"
AP_CHANNEL_DEFAULT="6"
COUNTRY_CODE_DEFAULT="BR"

# ================= LOAD AP CONFIG =================
[ -f "$AP_ENV" ] && . "$AP_ENV"

AP_SSID="${AP_SSID:-$AP_SSID_DEFAULT}"
AP_PASS="${AP_PASS:-$AP_PASS_DEFAULT}"
AP_CHANNEL="${AP_CHANNEL:-$AP_CHANNEL_DEFAULT}"
COUNTRY_CODE="${COUNTRY_CODE:-$COUNTRY_CODE_DEFAULT}"

# ================= IPs / DHCP =================
AP_IP="192.168.40.1/24"
AP_RANGE="192.168.40.50,192.168.40.200"

WR_IP="192.168.50.1/24"
WR_RANGE="192.168.50.50,192.168.50.200"


# ================= BIN HELPERS =================
have(){ command -v "$1" >/dev/null 2>&1; }

IW_BIN="$(have iw && echo iw || echo "")"
IWLIST_BIN="$(have iwlist && echo iwlist || echo "")"
PY_BIN="$(have python3 && echo python3 || echo "")"

WPA_SUPP_BIN="$(have wpa_supplicant && echo wpa_supplicant || echo "")"
WPA_CLI_BIN="$(have wpa_cli && echo wpa_cli || echo "")"

DHCLIENT_BIN="$(have dhclient && echo dhclient || echo "")"
UDHCPC_BIN="$(have udhcpc && echo udhcpc || echo "")"

TIMEOUT_BIN="$(have timeout && echo timeout || echo "")"

# ================= HELPERS =================
log(){ echo "[$LOGTAG] $*"; logger -t "$LOGTAG" -- "$*"; }

rf_on(){
  rfkill unblock all 2>/dev/null || true
  ip link set "$WLAN_IF" up 2>/dev/null || true
}

flush_fw(){
  iptables -t nat -F 2>/dev/null || true
  iptables -F FORWARD 2>/dev/null || true
}

wifi_prepare_managed(){
  rfkill unblock all 2>/dev/null || true
  ip link set "$WLAN_IF" down 2>/dev/null || true
  iw reg set "$COUNTRY_CODE" 2>/dev/null || true
  iw dev "$WLAN_IF" set type managed 2>/dev/null || true
  ip link set "$WLAN_IF" up 2>/dev/null || true
  iw dev "$WLAN_IF" set power_save off 2>/dev/null || true
  sleep 0.3
}


wifi_prepare_ap(){
  rfkill unblock all 2>/dev/null || true
  ip link set "$WLAN_IF" down 2>/dev/null || true
  iw reg set "$COUNTRY_CODE" 2>/dev/null || true

  # alguns drivers aceitam "__ap__" (mais comum), outros "ap"
  iw dev "$WLAN_IF" set type __ap__ 2>/dev/null || \
  iw dev "$WLAN_IF" set type ap 2>/dev/null || true

  ip link set "$WLAN_IF" up 2>/dev/null || true
  iw dev "$WLAN_IF" set power_save off 2>/dev/null || true

  sleep 0.3
}


wifi_driver_reset(){
  if lsmod 2>/dev/null | grep -q '^unisoc_wifi'; then
    log "resetando driver unisoc_wifi"

    pkill -x hostapd dnsmasq wpa_supplicant 2>/dev/null || true
    ip link set "$WLAN_IF" down 2>/dev/null || true

    # dá um "hard toggle" no rádio (ajuda muito no unisoc)
    rfkill block all 2>/dev/null || true
    sleep 0.5

    rmmod unisoc_wifi 2>/dev/null || true
    sleep 0.8

    modprobe unisoc_wifi 2>/dev/null || true
    sleep 0.8

    rfkill unblock all 2>/dev/null || true

    # ✅ espera wlan0 voltar a existir
    for i in $(seq 1 50); do
      ip link show "$WLAN_IF" >/dev/null 2>&1 && break
      sleep 0.1
    done
  fi
}



nat_on(){
  local LAN="$1" WAN="$2"
  sysctl -w net.ipv4.ip_forward=1 >/dev/null

  iptables -t nat -C POSTROUTING -o "$WAN" -j MASQUERADE 2>/dev/null || \
    iptables -t nat -A POSTROUTING -o "$WAN" -j MASQUERADE

  iptables -C FORWARD -i "$LAN" -o "$WAN" -j ACCEPT 2>/dev/null || \
    iptables -A FORWARD -i "$LAN" -o "$WAN" -j ACCEPT

  iptables -C FORWARD -i "$WAN" -o "$LAN" -m state --state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null || \
    iptables -A FORWARD -i "$WAN" -o "$LAN" -m state --state RELATED,ESTABLISHED -j ACCEPT
}

set_last(){
  echo "$1" > "$LAST_FILE"
  sync
}

set_active(){
  echo "$1" > "$ACTIVE_FILE"
  sync
}

mark_ap_fallback_window(){
  local until=$(( $(date +%s) + AP_FALLBACK_MARK_WINDOW ))
  echo "$until" > "$FALLBACK_UNTIL_FILE" 2>/dev/null || true
}

clear_ap_fallback_window(){
  rm -f "$FALLBACK_UNTIL_FILE" 2>/dev/null || true
}

# ---------- DHCP helpers (dhclient/udhcpc) ----------
dhcp_release(){
  local dev="$1"
  if [ -n "$DHCLIENT_BIN" ]; then
    dhclient -r "$dev" 2>/dev/null || true
  fi
  if [ -n "$UDHCPC_BIN" ]; then
    # udhcpc geralmente não tem "release" confiável aqui; apenas mata instâncias.
    pkill -f "udhcpc.*-i $dev" 2>/dev/null || true
  fi
}

dhcp_acquire(){
  local dev="$1"
  local tmo="${2:-12}"

  if [ -n "$DHCLIENT_BIN" ]; then
    if [ -n "$TIMEOUT_BIN" ]; then
      timeout "$tmo" dhclient -1 "$dev" >/dev/null 2>&1
    else
      dhclient -1 "$dev" >/dev/null 2>&1
    fi
    return $?
  fi

  if [ -n "$UDHCPC_BIN" ]; then
    # -n: sai se falhar, -q: quiet, -t tentativas, -T timeout por tentativa
    if [ -n "$TIMEOUT_BIN" ]; then
      timeout "$tmo" udhcpc -i "$dev" -n -q -t 3 -T 3 >/dev/null 2>&1
    else
      udhcpc -i "$dev" -n -q -t 3 -T 3 >/dev/null 2>&1
    fi
    return $?
  fi

  log "ERRO: nenhum cliente DHCP encontrado (dhclient/udhcpc)"
  return 1
}

# ---------- WPA CLI wrapper ----------
wpa_cli_cmd(){
  # Usa -p para garantir ctrl_interface correto
  [ -n "$WPA_CLI_BIN" ] || return 1
  wpa_cli -p "$WPA_CTRL_DIR" -i "$WLAN_IF" "$@" 2>/dev/null
}

gw_for_dev(){
  local dev="$1"
  ip -4 route show default dev "$dev" 2>/dev/null | awk '
    $1=="default" {
      for(i=1;i<=NF;i++){
        if($i=="via"){print $(i+1); exit}
      }
    }'
}

ping_via(){
  local dev="$1"; local ip="$2"
  ping -I "$dev" -c1 -W2 "$ip" >/dev/null 2>&1
}

gw_ok_for_dev(){
  local dev="$1"
  local gw
  gw="$(gw_for_dev "$dev" || true)"
  [ -n "${gw:-}" ] || return 1
  ping -I "$dev" -c1 -W"$WIFI_GW_PING_TIMEOUT" "$gw" >/dev/null 2>&1
}

internet_ok_for_dev(){
  local dev="$1"
  local ip
  for ip in "${WIFI_TEST_IPS_ARR[@]}"; do
    if ping_via "$dev" "$ip"; then
      return 0
    fi
  done
  return 1
}

uplink_ok_for_wifi(){
  case "$WIFI_VALIDATE_MODE" in
    assoc_dhcp)
      return 0
      ;;
    gw)
      gw_ok_for_dev "$WLAN_IF"
      ;;
    internet)
      internet_ok_for_dev "$WLAN_IF"
      ;;
    gw_or_internet|*)
      if gw_ok_for_dev "$WLAN_IF"; then
        return 0
      fi
      internet_ok_for_dev "$WLAN_IF"
      ;;
  esac
}

stop_all(){
  log "resetando rede"
  pkill -x hostapd dnsmasq wpa_supplicant pppd 2>/dev/null || true

  dhcp_release "$WLAN_IF"
  dhcp_release "$LAN_IF"

  ip addr flush dev "$WLAN_IF" 2>/dev/null || true
  ip addr flush dev "$LAN_IF" 2>/dev/null || true

  ip link set "$WLAN_IF" down 2>/dev/null || true
  ip link set "$LAN_IF" down 2>/dev/null || true

  flush_fw
}

# ================= WIFI SCAN CACHE (corrigido) =================
wifi_scan_cache_update(){
  [ -n "$PY_BIN" ] || return 0

  # 0) limpeza: evita scan falhar por “busy”
  pkill -x hostapd dnsmasq wpa_supplicant 2>/dev/null || true

  # 1) garante rádio liberado e interface rearmada
  rfkill unblock all 2>/dev/null || true
  ip link set "$WLAN_IF" down 2>/dev/null || true
  sleep 0.3
  ip link set "$WLAN_IF" up 2>/dev/null || true

  # 2) força regdomain (ajuda MUITO em scan/canais)
  if command -v iw >/dev/null 2>&1; then
    iw reg set "$COUNTRY_CODE" 2>/dev/null || true
  fi

  # 3) tenta forçar modo managed (nem todo driver deixa)
  if command -v iw >/dev/null 2>&1; then
    iw dev "$WLAN_IF" set type managed 2>/dev/null || true
  fi

  # 4) scan com timeout e fallback
  local raw="" ok=0

  if [ -n "$IW_BIN" ]; then
    if [ -n "$TIMEOUT_BIN" ]; then
      raw="$($TIMEOUT_BIN 12 "$IW_BIN" dev "$WLAN_IF" scan 2>/dev/null || true)"
    else
      raw="$("$IW_BIN" dev "$WLAN_IF" scan 2>/dev/null || true)"
    fi
    [ -n "$raw" ] && ok=1
  fi

  if [ "$ok" -ne 1 ] && [ -n "$IWLIST_BIN" ]; then
    if [ -n "$TIMEOUT_BIN" ]; then
      raw="$($TIMEOUT_BIN 12 "$IWLIST_BIN" "$WLAN_IF" scan 2>/dev/null || true)"
    else
      raw="$("$IWLIST_BIN" "$WLAN_IF" scan 2>/dev/null || true)"
    fi
    [ -n "$raw" ] && ok=2
  fi


  # 5) salva cache (mesmo se vazio, pra UI não “sumir”)
  printf '%s' "$raw" | "$PY_BIN" -c '
import sys, json, time, re
mode = int(sys.argv[1])
outf = sys.argv[2]
raw  = sys.stdin.read()
nets = []
ts = int(time.time())

def uniq_by_ssid(items):
    best = {}
    for n in items:
        ssid = (n.get("ssid") or "").strip()
        if not ssid:
            continue
        if ssid not in best:
            best[ssid] = n
        else:
            # tenta comparar sinal numérico quando dá
            try:
                a = float(str(n.get("signal","")).split()[0])
                b = float(str(best[ssid].get("signal","")).split()[0])
                if a > b:
                    best[ssid] = n
            except Exception:
                pass
    return list(best.values())

if mode == 1:
    bss = None
    for line in raw.splitlines():
        s = line.strip()
        if s.startswith("BSS "):
            if bss: nets.append(bss)
            bss = {"ssid":"","signal":"","freq":"","security":"?"}
        elif s.startswith("SSID:"):
            if bss is None: bss = {"ssid":"","signal":"","freq":"","security":"?"}
            bss["ssid"] = s.split("SSID:",1)[1].strip()
        elif s.startswith("freq:"):
            if bss is None: bss = {"ssid":"","signal":"","freq":"","security":"?"}
            bss["freq"] = s.split("freq:",1)[1].strip()
        elif s.startswith("signal:"):
            if bss is None: bss = {"ssid":"","signal":"","freq":"","security":"?"}
            bss["signal"] = s.split("signal:",1)[1].strip()
        elif s.startswith("RSN:") or s.startswith("WPA:"):
            if bss is None: bss = {"ssid":"","signal":"","freq":"","security":"?"}
            bss["security"] = "WPA/WPA2"
    if bss: nets.append(bss)
    nets = [n for n in nets if (n.get("ssid") or "").strip()]

elif mode == 2:
    for cell in raw.split("Cell "):
        m_ssid = re.search(r"ESSID:\"(.*)\"", cell)
        if not m_ssid: continue
        ssid = m_ssid.group(1)
        m_sig = re.search(r"Signal level=(-?\d+)", cell) or re.search(r"Quality=([0-9/]+)", cell)
        m_frq = re.search(r"Frequency:([0-9\.]+)", cell)
        enc = "Open" if "Encryption key:off" in cell else "WPA/WPA2"
        nets.append({"ssid": ssid,
                     "signal": (m_sig.group(1) if m_sig else "?"),
                     "freq": (m_frq.group(1) if m_frq else "?"),
                     "security": enc})

nets = uniq_by_ssid(nets)
payload = {"ts": ts, "mode": mode, "count": len(nets), "nets": nets}
with open(outf, "w", encoding="utf-8") as f:
    json.dump(payload, f, ensure_ascii=False)
' "$ok" "$WIFI_SCAN_CACHE" 2>/dev/null || true

  return 0
}

  
 
# ================= AP =================
write_hostapd(){
  if [ "${#AP_PASS}" -lt 8 ]; then
    log "WARN: AP_PASS menor que 8 chars; hostapd pode falhar"
  fi
  cat >"$HOSTAPD_CONF" <<EOF
interface=$WLAN_IF
ssid=$AP_SSID
country_code=$COUNTRY_CODE
hw_mode=g
channel=$AP_CHANNEL
ieee80211n=0
wmm_enabled=0
auth_algs=1
wpa=2
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
wpa_passphrase=$AP_PASS
EOF
}

start_ap_services(){
  # ✅ Só faz scan se o último action foi scan_reboot
  if [ -f "$LAST_ACTION_FILE" ] && grep -q "scan_reboot" "$LAST_ACTION_FILE"; then
    wifi_scan_cache_update
    rm -f "$LAST_ACTION_FILE" 2>/dev/null || true
  fi

  pkill -x wpa_supplicant 2>/dev/null || true

  wifi_prepare_ap
  ip addr replace "$AP_IP" dev "$WLAN_IF" 2>/dev/null || true

  write_hostapd

  dnsmasq \
    --conf-file=/dev/null \
    --no-hosts --no-resolv \
    --server=1.1.1.1 --server=8.8.8.8 \
    --interface="$WLAN_IF" --bind-interfaces \
    --dhcp-range="$AP_RANGE" \
    --dhcp-option=3,${AP_IP%/*} \
    --dhcp-option=6,${AP_IP%/*} \
    >/dev/null 2>&1 || true

  hostapd -B "$HOSTAPD_CONF"
}


# ================= CLIENT WIFI =================
ensure_wpa(){
  [ -f "$WIFI_ENV" ] || return 1
  # shellcheck disable=SC1090
  . "$WIFI_ENV"

  : "${WIFI_SSID:?}"

  mkdir -p "$WPA_CTRL_DIR" 2>/dev/null || true

  cat >"$WPA_CONF" <<EOF
ctrl_interface=$WPA_CTRL_DIR
update_config=1
country=$COUNTRY_CODE
network={
  ssid="$WIFI_SSID"
EOF

  if [ -n "${WIFI_PSK:-}" ]; then
    echo "  psk=\"$WIFI_PSK\"" >>"$WPA_CONF"
  else
    echo "  key_mgmt=NONE" >>"$WPA_CONF"
  fi

  echo "}" >>"$WPA_CONF"
  chmod 600 "$WPA_CONF"
}

start_wifi_once(){
  pkill -x hostapd dnsmasq 2>/dev/null || true
  pkill -x wpa_supplicant 2>/dev/null || true

  dhcp_release "$WLAN_IF"
  wifi_prepare_managed
  rf_on

  [ -n "$WPA_SUPP_BIN" ] || { log "ERRO: wpa_supplicant não encontrado"; return 1; }

  wpa_supplicant -B -i "$WLAN_IF" -c "$WPA_CONF"

  local i=1
  while [ "$i" -le "$WIFI_ASSOC_TIMEOUT" ]; do
    wpa_cli_cmd status | grep -q '^wpa_state=COMPLETED' && break
    sleep 1
    i=$((i+1))
  done

  wpa_cli_cmd status | grep -q '^wpa_state=COMPLETED' || return 1

  dhcp_acquire "$WLAN_IF" "$WIFI_DHCP_TIMEOUT" || return 1

  # Validação de uplink (configurável)
  uplink_ok_for_wifi || return 1

  return 0
}

wifi_connect_with_retry(){
  local attempt=1
  while [ "$attempt" -le "$WIFI_RETRY_MAX" ]; do
    log "Wi-Fi tentativa $attempt/$WIFI_RETRY_MAX (validate=$WIFI_VALIDATE_MODE)"
    if start_wifi_once; then
      log "Wi-Fi OK (associado + DHCP + validação ok)"
      return 0
    fi
    log "Falha na tentativa $attempt — aguardando ${WIFI_RETRY_DELAY}s"
    sleep "$WIFI_RETRY_DELAY"
    attempt=$((attempt + 1))
  done
  return 1
}

# ================= FALLBACK AP (SEM ALTERAR last_profile) =================
fallback_ap_runtime(){
  local reason="${1:-}"
  log "fallback AP temporário: ${reason:-motivo não informado}"
  mark_ap_fallback_window

  stop_all

  # ✅ reset do driver antes de subir AP
  wifi_driver_reset

  start_ap_services

  ip link set "$LAN_IF" up 2>/dev/null || true
  dhcp_acquire "$LAN_IF" "$DHCP_WAN_TIMEOUT" >/dev/null 2>&1 || true

  nat_on "$WLAN_IF" "$LAN_IF"
  set_active "ap(fallback)"
  log "AP temporário ativo ($AP_SSID) — last_profile preservado"
}


# ================= PROFILES =================
profile_ap(){
  local commit="${1:-1}"
  stop_all

  # ✅ reset do driver com interface DOWN (antes de qualquer iw/ip up)
  wifi_driver_reset

  # ✅ sobe AP (aqui dentro já chama wifi_prepare_ap + ip addr replace + hostapd/dnsmasq)
  start_ap_services

  ip link set "$LAN_IF" up 2>/dev/null || true
  dhcp_acquire "$LAN_IF" "$DHCP_WAN_TIMEOUT" >/dev/null 2>&1 || true

  nat_on "$WLAN_IF" "$LAN_IF"

  clear_ap_fallback_window
  set_active "ap"
  [ "$commit" = "1" ] && set_last "ap"
  log "AP ativo ($AP_SSID)"
}


profile_client_wifi(){
  local commit="${1:-1}"  # 1 = grava last_profile, 0 = não grava (uso interno)
  stop_all

  ensure_wpa || { fallback_ap_runtime "sem credenciais Wi-Fi"; return 1; }

  if ! wifi_connect_with_retry; then
    fallback_ap_runtime "Wi-Fi falhou após ${WIFI_RETRY_MAX} tentativas"
    return 1
  fi

  # opcional: end0 também cliente (não bloqueia)
  ip link set "$LAN_IF" up 2>/dev/null || true
  dhcp_acquire "$LAN_IF" "$DHCP_WAN_TIMEOUT" >/dev/null 2>&1 || true

  clear_ap_fallback_window
  set_active "client-wifi"
  [ "$commit" = "1" ] && set_last "client-wifi"
  log "client-wifi conectado (validate=$WIFI_VALIDATE_MODE)"
}

profile_wifi_router(){
  local commit="${1:-1}"
  # WAN = WLAN (cliente), LAN = end0 (192.168.50.0/24)
  stop_all

  ensure_wpa || { fallback_ap_runtime "sem credenciais Wi-Fi (wifi-router)"; return 1; }
  if ! wifi_connect_with_retry; then
    fallback_ap_runtime "wifi-router: uplink Wi-Fi falhou"
    return 1
  fi

  ip link set "$LAN_IF" up 2>/dev/null || true
  ip addr replace "$WR_IP" dev "$LAN_IF"

  dnsmasq \
    --conf-file=/dev/null \
    --no-hosts --no-resolv \
    --server=1.1.1.1 --server=8.8.8.8 \
    --interface="$LAN_IF" --bind-interfaces \
    --dhcp-range="$WR_RANGE" \
    --dhcp-option=3,${WR_IP%/*} \
    --dhcp-option=6,${WR_IP%/*} \
    >/dev/null 2>&1 || true


  nat_on "$LAN_IF" "$WLAN_IF"

  clear_ap_fallback_window
  set_active "wifi-router"
  [ "$commit" = "1" ] && set_last "wifi-router"
  log "wifi-router ativo (WAN=$WLAN_IF, LAN=$LAN_IF, validate=$WIFI_VALIDATE_MODE)"
}

profile_client_lan(){
  stop_all
  ip link set "$LAN_IF" up 2>/dev/null || true

  # Se não pegar DHCP no cabo, volta para AP para não perder acesso
  if ! dhcp_acquire "$LAN_IF" "$DHCP_WAN_TIMEOUT" >/dev/null 2>&1; then
    fallback_ap_runtime "client-lan: sem DHCP em $LAN_IF"
    return 1
  fi

  clear_ap_fallback_window
  set_active "client-lan"
  set_last "client-lan"
  log "client-lan ativo (DHCP ok em $LAN_IF)"
}


profile_3g(){
  stop_all
  pppd call "$PPP_PEER" &

  rf_on
  ip link set "$WLAN_IF" up 2>/dev/null || true
  ip addr replace "192.168.60.1/24" dev "$WLAN_IF"
  start_ap_services
  nat_on "$WLAN_IF" "$PPP_IF"

  clear_ap_fallback_window
  set_active "3g"
  set_last "3g"
  log "3g ativo (AP via ppp0)"
}

profile_3g_client(){
  stop_all
  pppd call "$PPP_PEER" &

  rf_on
  ip link set "$WLAN_IF" up 2>/dev/null || true
  ip addr replace "192.168.61.1/24" dev "$WLAN_IF"
  start_ap_services
  nat_on "$WLAN_IF" "$PPP_IF"

  ip link set "$LAN_IF" up 2>/dev/null || true
  dhcp_acquire "$LAN_IF" "$DHCP_WAN_TIMEOUT" >/dev/null 2>&1 || true

  clear_ap_fallback_window
  set_active "3g-client"
  set_last "3g-client"
  log "3g-client ativo"
}

# ================= DISPATCH =================
case "${1:-}" in
  ap)          profile_ap 1 ;;
  client-wifi) profile_client_wifi 1 ;;
  wifi-router) profile_wifi_router 1 ;;
  client-lan)  profile_client_lan ;;
  3g)          profile_3g ;;
  3g-client)   profile_3g_client ;;
  stop)
    stop_all
    set_active "stopped"
    log "parado"
    ;;
  status)
    echo "=== desired(last_profile) ==="
    cat "$LAST_FILE" 2>/dev/null || echo "(none)"
    echo
    echo "=== active(active_profile) ==="
    cat "$ACTIVE_FILE" 2>/dev/null || echo "(none)"
    echo
    echo "=== validate ==="
    echo "WIFI_VALIDATE_MODE=$WIFI_VALIDATE_MODE"
    echo "WIFI_TEST_IPS=${WIFI_TEST_IPS_ARR[*]}"
    echo
    echo "=== ip addr ==="
    ip addr || true
    echo
    echo "=== ip route ==="
    ip route || true
    echo
    if [ -n "$WPA_CLI_BIN" ]; then
      echo "=== wpa_cli status ($WLAN_IF) ==="
      wpa_cli_cmd status || true
      echo
    fi
    ;;
  *)
    echo "uso: $0 {ap|client-wifi|wifi-router|client-lan|3g|3g-client|stop|status}"
    exit 1
    ;;
esac






SH

sudo chmod +x /usr/local/bin/profiles.sh
















































sudo tee /usr/local/bin/mirako-apply-last-profile.sh >/dev/null <<'EOF'
#!/usr/bin/env bash
# /usr/local/bin/mirako-apply-last-profile.sh
# Aplica o último perfil salvo em /var/lib/mirako/last_profile no boot.

set -euo pipefail

PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:${PATH:-}"
LOGTAG="mirako-apply"

# Caminhos (podem ser sobrescritos pelo unit via Environment=)
PROFILES_SCRIPT="${PROFILES_SCRIPT:-/usr/local/bin/profiles.sh}"
LAST_FILE="${LAST_FILE:-/var/lib/mirako/last_profile}"

log()  { echo "[$LOGTAG] $*" ; logger -t "$LOGTAG" -- "$*"; }
warn() { echo "[$LOGTAG][WARN] $*" ; logger -t "$LOGTAG" -- "[WARN] $*"; }
err()  { echo "[$LOGTAG][ERRO] $*" ; logger -t "$LOGTAG" -- "[ERRO] $*"; }

# Perfis suportados
ALLOWED_PROFILES=("ap" "wifi-router" "client-wifi" "client-lan" "3g" "3g-client" "stop" "status")

# Normaliza sinônimos/variações para o nome oficial
normalize_profile() {
  local in="${1:-}"
  in="$(echo -n "$in" | tr '[:upper:]' '[:lower:]' | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')"
  case "$in" in
    "wifi_router"|"wifi router") echo "wifi-router" ;;
    "client_wifi"|"client wifi") echo "client-wifi" ;;
    "client_lan"|"client lan")   echo "client-lan" ;;
    "3gclient"|"3g_client"|"3g client") echo "3g-client" ;;
    *) echo "$in" ;;
  esac
}

# Verifica se perfil está na lista permitida
is_allowed() {
  local p="$1"
  for a in "${ALLOWED_PROFILES[@]}"; do
    [[ "$a" == "$p" ]] && return 0
  done
  return 1
}

# ---- Pré-checagens ----
[[ -x "$PROFILES_SCRIPT" ]] || { err "Script $PROFILES_SCRIPT não encontrado ou não executável"; exit 1; }

if [[ ! -f "$LAST_FILE" ]]; then
  warn "Arquivo $LAST_FILE ausente; usando perfil padrão 'ap'"
fi

PROFILE="$(cat "$LAST_FILE" 2>/dev/null || echo ap)"
PROFILE="$(normalize_profile "$PROFILE")"

if ! is_allowed "$PROFILE"; then
  warn "Perfil '$PROFILE' não suportado; caindo para 'ap'"
  PROFILE="ap"
fi

# ---- Esperas de boot/ordenação ----
# 1) udev settle (dispositivos como wlan0/end0/ttyUSB*)
if command -v udevadm >/dev/null 2>&1; then
  log "Aguardando udev settle…"
  udevadm settle --timeout=20 || true
fi

# 2) network-online.target (se existir na máquina)
if command -v systemctl >/dev/null 2>&1; then
  if systemctl list-unit-files | grep -q '^network-online\.target'; then
    log "Aguardando network-online.target…"
    # Se já estiver ativa, ótimo; do contrário, aguarda
    systemctl is-active --quiet network-online.target || \
      systemctl --no-pager --quiet wait network-online.target || true
  fi

  # 3) netfilter-persistent (ou equivalente) — não bloqueia se ausente
  if systemctl list-unit-files | grep -q '^netfilter-persistent\.service'; then
    # Apenas registra estado; não há 'wait' padrão
    if systemctl is-failed --quiet netfilter-persistent.service; then
      warn "netfilter-persistent.service falhou (seguindo assim mesmo)"
    else
      log "netfilter-persistent.service presente"
    fi
  fi
fi

# Buffer final para serviços que sobem logo após online
sleep 2

# ---- Aplicação do perfil ----
log "Aplicando perfil: $PROFILE"
if "$PROFILES_SCRIPT" "$PROFILE"; then
  log "Perfil '$PROFILE' aplicado com sucesso"
  exit 0
else
  err "Falha ao aplicar perfil '$PROFILE'"
  exit 1
fi

EOF

sudo chmod +x /usr/local/bin/mirako-apply-last-profile.sh













sudo tee /usr/local/bin/mirako-netwatch.sh >/dev/null <<'EOF'
#!/usr/bin/env bash
# mirako-netwatch.sh — Supervisor de conectividade Mirako (respeita UI/last_profile)
#
# Objetivo:
# - last_profile = perfil DESEJADO (selecionado pela UI / boot).
# - active_profile = perfil ATIVO (informativo; o profiles.sh mantém).
# - Se last_profile for client-wifi ou wifi-router:
#     * se Wi-Fi estiver degradado, sobe AP temporário (fallback) por 180s,
#       mantendo last_profile intacto, e depois tenta reconectar no Wi-Fi.
# - Se last_profile for ap / client-lan / 3g / 3g-client:
#     * não força alternância para Wi-Fi (apenas reaplica o próprio perfil quando fizer sentido).
#
# OBS: este script assume o profiles.sh que:
# - valida GW no client-wifi/wifi-router (associação + DHCP + ping gateway)
# - fallback AP temporário NÃO sobrescreve last_profile

set -Eeuo pipefail
trap 'echo "[mirako-netwatch][ERRO] linha $LINENO: $BASH_COMMAND" >&2' ERR

PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:${PATH:-}"
LOGTAG="mirako-netwatch"

PROFILES_SCRIPT="${PROFILES_SCRIPT:-/usr/local/bin/profiles.sh}"
LAST_FILE="${LAST_FILE:-/var/lib/mirako/last_profile}"
ACTIVE_FILE="${ACTIVE_FILE:-/var/lib/mirako/active_profile}"
FALLBACK_UNTIL_FILE="${FALLBACK_UNTIL_FILE:-/var/lib/mirako/ap_fallback_until}"

WLAN_IF="${WLAN_IF:-wlan0}"
LAN_IF="${LAN_IF:-end0}"
PPP_IF="${PPP_IF:-ppp0}"

# Alvos de teste (use 2 para reduzir falsos positivos de DNS/rota)
TARGETS_DEFAULT=("1.1.1.1" "8.8.8.8")

CHECK_INTERVAL="${CHECK_INTERVAL:-10}"        # segundos
AP_FALLBACK_WINDOW="${AP_FALLBACK_WINDOW:-180}" # segundos (deve casar com profiles.sh)

# Quantas falhas consecutivas antes de tentar reaplicar (evita flapping)
FAILS_BEFORE_ACTION="${FAILS_BEFORE_ACTION:-2}"

log(){ echo "[$LOGTAG] $*"; logger -t "$LOGTAG" -- "$*"; }

have(){ command -v "$1" >/dev/null 2>&1; }

get_file_trim(){
  local f="$1"
  [ -f "$f" ] || { echo ""; return 0; }
  tr -d '\r\n' < "$f" 2>/dev/null || echo ""
}

get_last_profile(){
  local p
  p="$(get_file_trim "$LAST_FILE" | tr '[:upper:]' '[:lower:]')"
  echo "${p:-ap}"
}

get_active_profile(){
  local p
  p="$(get_file_trim "$ACTIVE_FILE" | tr '[:upper:]' '[:lower:]')"
  echo "${p:-}"
}

fallback_until_ts(){
  local v
  v="$(get_file_trim "$FALLBACK_UNTIL_FILE")"
  if [[ "${v:-}" =~ ^[0-9]+$ ]]; then
    echo "$v"
  else
    echo "0"
  fi
}

now_ts(){ date +%s; }

in_fallback_window(){
  local until
  until="$(fallback_until_ts)"
  [ "$until" -gt 0 ] || return 1
  [ "$(now_ts)" -lt "$until" ]
}

# ---------- Checks ----------
iface_has_ipv4(){
  local dev="$1"
  ip -4 addr show dev "$dev" 2>/dev/null | grep -q 'inet '
}

wpa_completed(){
  local dev="$1"
  have wpa_cli || return 0
  wpa_cli -i "$dev" status 2>/dev/null | grep -q '^wpa_state=COMPLETED'
}

gw_for_dev(){
  local dev="$1"
  ip -4 route show default dev "$dev" 2>/dev/null | awk '
    $1=="default" {
      for(i=1;i<=NF;i++){
        if($i=="via"){print $(i+1); exit}
      }
    }'
}

ping_via(){
  local dev="$1"; shift
  local ip="$1"
  ping -I "$dev" -c1 -W2 "$ip" >/dev/null 2>&1
}

any_target_ok(){
  local dev="$1"
  local t
  for t in "${TARGETS_DEFAULT[@]}"; do
    if ping_via "$dev" "$t"; then
      return 0
    fi
  done
  return 1
}

wifi_ok(){
  ip link show "$WLAN_IF" >/dev/null 2>&1 || return 1
  wpa_completed "$WLAN_IF" || return 1
  iface_has_ipv4 "$WLAN_IF" || return 1

  # valida GW (mais confiável que ping externo isolado)
  local gw
  gw="$(gw_for_dev "$WLAN_IF" || true)"
  [ -n "${gw:-}" ] || return 1
  ping_via "$WLAN_IF" "$gw" || return 1

  # e ao menos 1 alvo externo
  any_target_ok "$WLAN_IF" || return 1

  return 0
}

lan_ok(){
  ip link show "$LAN_IF" >/dev/null 2>&1 || return 1
  iface_has_ipv4 "$LAN_IF" || return 1
  any_target_ok "$LAN_IF" || return 1
  return 0
}

ppp_ok(){
  ip link show "$PPP_IF" >/dev/null 2>&1 || return 1
  iface_has_ipv4 "$PPP_IF" || return 1
  ping -I "$PPP_IF" -c1 -W4 1.1.1.1 >/dev/null 2>&1 || return 1
  return 0
}

apply_profile(){
  local p="$1"
  log "reaplicando perfil '$p' via profiles.sh"
  if "$PROFILES_SCRIPT" "$p"; then
    log "perfil '$p' reaplicado (ok)"
    return 0
  else
    log "ERRO ao reaplicar perfil '$p'"
    return 1
  fi
}

# ---------- Estado / contadores ----------
FAIL_WIFI=0
FAIL_LAN=0
LAST_SEEN_PROFILE=""

log "iniciado (CHECK_INTERVAL=${CHECK_INTERVAL}s, WLAN_IF=$WLAN_IF, LAN_IF=$LAN_IF, PPP_IF=$PPP_IF)"
log "alvos: ${TARGETS_DEFAULT[*]} | FAILS_BEFORE_ACTION=$FAILS_BEFORE_ACTION | AP_FALLBACK_WINDOW=${AP_FALLBACK_WINDOW}s"

while true; do
  DESIRED="$(get_last_profile)"
  ACTIVE="$(get_active_profile)"

  # log leve quando trocar perfil desejado (UI)
  if [ "$DESIRED" != "$LAST_SEEN_PROFILE" ]; then
    log "perfil desejado (last_profile) = '$DESIRED' (ativo: '${ACTIVE:-?}')"
    LAST_SEEN_PROFILE="$DESIRED"
    FAIL_WIFI=0
    FAIL_LAN=0
  fi

  case "$DESIRED" in
    wifi-router|client-wifi)
      # 1) se estamos na janela de fallback AP, NÃO tenta reconectar ainda
      if in_fallback_window; then
        # garante que AP está de pé (sem ficar reaplicando sem necessidade)
        # apenas loga raramente (a cada ~60s)
        if (( ( $(now_ts) % 60 ) == 0 )); then
          local_until="$(fallback_until_ts)"
          remain=$(( local_until - $(now_ts) ))
          [ "$remain" -lt 0 ] && remain=0
          log "janela AP fallback ativa, restam ~${remain}s (não tentando Wi-Fi agora)"
        fi
        sleep "$CHECK_INTERVAL"
        continue
      fi

      # 2) fora da janela: precisa que Wi-Fi esteja OK; se não, aciona reconexão
      if wifi_ok; then
        FAIL_WIFI=0
      else
        FAIL_WIFI=$((FAIL_WIFI+1))
        log "Wi-Fi degradado ($FAIL_WIFI/$FAILS_BEFORE_ACTION) — desejado=$DESIRED (ativo=${ACTIVE:-?})"
        if [ "$FAIL_WIFI" -ge "$FAILS_BEFORE_ACTION" ]; then
          FAIL_WIFI=0
          # reaplica o perfil desejado; o profiles.sh:
          # - tenta Wi-Fi (com retry e valida GW)
          # - se falhar: sobe AP temporário por 180s, preservando last_profile
          apply_profile "$DESIRED" || true
        fi
      fi
      ;;

    client-lan)
      if lan_ok; then
        FAIL_LAN=0
      else
        FAIL_LAN=$((FAIL_LAN+1))
        log "LAN degradada ($FAIL_LAN/$FAILS_BEFORE_ACTION) — desejado=client-lan"
        if [ "$FAIL_LAN" -ge "$FAILS_BEFORE_ACTION" ]; then
          FAIL_LAN=0
          apply_profile "client-lan" || true
        fi
      fi
      ;;

    3g|3g-client)
      # PPP costuma ser cuidado por autodial; aqui só reporta.
      if ppp_ok; then
        :
      else
        log "PPP degradado (perfil $DESIRED) — autodial/pppd cuidará"
      fi
      ;;

    ap|"")
      # Se AP é o desejado, não forçamos reconexão de Wi-Fi nunca.
      # Mas podemos garantir que está rodando (se alguém matou serviços).
      # Evita loop: só reaplica se active_profile estiver vazio/stopped.
      if [ -z "${ACTIVE:-}" ] || [[ "$ACTIVE" == "stopped" ]]; then
        log "AP desejado mas ativo indefinido — reaplicando 'ap'"
        apply_profile "ap" || true
      fi
      ;;

    *)
      log "perfil desejado desconhecido '$DESIRED' — ignorando"
      ;;
  esac

  sleep "$CHECK_INTERVAL"
done



EOF

sudo chmod +x /usr/local/bin/mirako-netwatch.sh
















sudo tee /etc/systemd/system/mirako-web.service >/dev/null <<'EOF'
[Unit]
Description=Mirako Router Web UI (Flask)
After=network.target
Wants=network.target

[Service]
Type=simple
User=root
WorkingDirectory=/opt/mirako_web
ExecStart=/usr/bin/python3 /opt/mirako_web/web_config.py
Restart=on-failure
RestartSec=2

[Install]
WantedBy=multi-user.target
EOF

sudo systemctl daemon-reload
sudo systemctl enable --now mirako-web.service









sudo tee /etc/systemd/system/mirako-apply-last-profile.service >/dev/null <<'EOF'
[Unit]
Description=Mirako: aplicar último perfil após o boot
After=systemd-udev-settle.service network-online.target netfilter-persistent.service mirako-autodial.service
Wants=systemd-udev-settle.service network-online.target
# Só executa se estes caminhos existirem/forem válidos:
ConditionPathExists=/usr/local/bin/mirako-apply-last-profile.sh
ConditionPathIsExecutable=/usr/local/bin/mirako-apply-last-profile.sh


[Service]
Type=oneshot
# Opcional: expõe caminhos usados pelo script (caso ele leia via env)
Environment="PROFILES_SCRIPT=/usr/local/bin/profiles.sh" "LAST_FILE=/var/lib/mirako/last_profile"
ExecStart=/usr/local/bin/mirako-apply-last-profile.sh
# perfis podem levar um pouco; combine com seu profiles.sh
TimeoutStartSec=180
RemainAfterExit=yes
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF

sudo systemctl daemon-reload
sudo systemctl enable --now mirako-apply-last-profile.service







sudo tee /etc/systemd/system/mirako-netwatch.service >/dev/null <<'EOF'
[Unit]
Description=Mirako network health supervisor
After=network-online.target mirako-apply-last-profile.service
Wants=network-online.target

[Service]
Type=simple
Environment=WLAN_IF=wlan0
Environment=LAN_IF=end0
Environment=PPP_IF=ppp0
ExecStart=/usr/local/bin/mirako-netwatch.sh
Restart=always
RestartSec=5

# Se quiser integrar com watchdog do systemd:
# WatchdogSec=60
# NotifyAccess=all

[Install]
WantedBy=multi-user.target
EOF

sudo systemctl daemon-reload
sudo systemctl enable --now mirako-netwatch.service















































sudo tee /etc/systemd/system/mirako-autodial.service >/dev/null <<'EOF'
[Unit]
Description=Mirako auto-dial 3G while /var/lib/mirako/auto_dial_enabled exists
After=network-online.target
Wants=network-online.target
ConditionPathExists=/var/lib/mirako/auto_dial_enabled

[Service]
Type=simple
Environment=PPP_IF=ppp0
Environment=PPP_PEER=3g
ExecStart=/usr/local/bin/mirako-autodial.sh
ExecStop=/usr/bin/pkill -x pppd
Restart=always
RestartSec=30

[Install]
WantedBy=multi-user.target

EOF

sudo systemctl daemon-reload
sudo systemctl enable mirako-autodial.service




sudo tee /usr/local/bin/mirako-autodial.sh >/dev/null <<'EOF'
#!/bin/sh
set -eu

FLAG="/var/lib/mirako/auto_dial_enabled"
PPP_IF="${PPP_IF:-ppp0}"
PPP_PEER="${PPP_PEER:-3g}"
IP="/usr/sbin/ip"
PPPD="/usr/sbin/pppd"

log() { printf '[autodial] %s %s\n' "$(date '+%F %T')" "$*"; }

trap 'log "saindo"; /usr/bin/pkill -x pppd >/dev/null 2>&1 || true; exit 0' INT TERM

while [ -e "$FLAG" ]; do
  # já está up? só monitora
  if $IP link show "$PPP_IF" >/dev/null 2>&1; then
    sleep 5
    continue
  fi

  log "$PPP_IF down; limpando e discando..."
  /usr/bin/pkill -x pppd >/dev/null 2>&1 || true
  /bin/rm -f /var/lock/LCK..ttyUSB* /var/lock/LCK..ttyACM* >/dev/null 2>&1 || true

  # inicia em foreground para logar no journald
  $PPPD call "$PPP_PEER" nodetach &
  PPPD_PID=$!

  # aguarda até 30s o ppp0 aparecer
  i=0
  while [ $i -lt 30 ]; do
    if $IP link show "$PPP_IF" >/dev/null 2>&1; then
      log "$PPP_IF ativo."
      break
    fi
    i=$((i+1))
    sleep 1
  done

  # espera pppd ou flag sumir
  while kill -0 "$PPPD_PID" 2>/dev/null; do
    [ -e "$FLAG" ] || { log "flag removida; encerrando pppd"; kill "$PPPD_PID" >/dev/null 2>&1 || true; break; }
    sleep 2
  done

  wait "$PPPD_PID" || true
  log "pppd saiu; nova tentativa em 5s..."
  sleep 5
done

log "flag ausente; encerrando."
exit 0
EOF



sudo chmod +x /usr/local/bin/mirako-autodial.sh








sudo systemctl daemon-reload
sudo systemctl enable mirako-autodial.service
sudo systemctl restart mirako-autodial.service






















sudo systemctl enable watchdog
sudo systemctl start watchdog




sudo apt install certbot python3-certbot-nginx
sudo certbot --nginx -d alien.mirako.org






##SCRIPT DE EXPANSAO DA IMAGEM DE INSTALACAO CASO NAO TENHA SE EXPANDIDO
cat > expand_ext4.sh << 'EOF'
#!/bin/bash
echo "=== Expansão para sistema de arquivos ext4 ==="

# Dispositivo
DEVICE="/dev/mmcblk0p1"

echo "Estado ANTES:"
df -h /
echo ""

# Verificar e reparar o sistema de arquivos
echo "1. Verificando sistema de arquivos ext4..."
e2fsck -f $DEVICE

# Expandir o sistema de arquivos ext4 para preencher a partição
echo "2. Expandindo sistema de arquivos ext4..."
resize2fs $DEVICE

echo "3. Estado DEPOIS:"
df -h /

echo "4. Informações detalhadas do sistema de arquivos:"
tune2fs -l $DEVICE | grep -E "(Block count|Block size|Filesystem size)"

echo "=== Concluído ==="
EOF

chmod +x expand_ext4.sh
sudo ./expand_ext4.sh










