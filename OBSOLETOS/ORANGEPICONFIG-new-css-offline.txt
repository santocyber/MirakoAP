sudo tee /etc/update-motd.d/10-orangepi-header >/dev/null <<'EOF'
#!/bin/bash
#
# Copyright (c) Authors: https://www.armbian.com/authors
#
# This file is licensed under the terms of the GNU General Public
# License version 2. This program is licensed "as is" without any
# warranty of any kind, whether express or implied.

# DO NOT EDIT THIS FILE but add config options to /etc/default/orangepi-motd
# any changes will be lost on board support package update

THIS_SCRIPT="header"
MOTD_DISABLE=""

[[ -f /etc/default/orangepi-motd ]] && . /etc/default/orangepi-motd

for f in $MOTD_DISABLE; do
	[[ $f == $THIS_SCRIPT ]] && exit 0
done

. /etc/os-release
. /etc/orangepi-release

KERNELID=$(uname -r)
TERM=linux toilet -f standard -F metal $(echo 'Mirako.org')
echo -e "Welcome to \e[0;91mOrange Pi ${VERSION} ${DISTRIBUTION_CODENAME^}\x1B[0m with $([[ $BRANCH == edge ]] && echo -e "\e[0;91mbleeding\x1B[0m edge " )\e[0;91mLinux $KERNELID\x1B[0m\n \e[0;97m by SantoCyber\x1B[0m\n"

EOF

figlet "Mirako.ORG"
figlet "SantoCyber"




sudo apt update
sudo apt install -y hostapd dnsmasq ppp usb-modeswitch wpasupplicant iptables-persistent python3-flask python3-systemd traceroute tcpdump isc-dhcp-client dnsmasq hostapd iptables ppp pppoeconf rfkill wpasupplicant





echo 'net.ipv4.ip_forward=1' | sudo tee /etc/sysctl.d/99-iptables.conf
sudo sysctl -p /etc/sysctl.d/99-iptables.conf






sudo tee /etc/hostapd/hostapd.conf >/dev/null <<'EOF'
# /etc/hostapd/hostapd.conf
interface=wlan0
driver=nl80211
ssid=MirakoAP
country_code=BR
ieee80211d=1

# 2.4 GHz
hw_mode=g
channel=6
wmm_enabled=1
ieee80211n=1
# (opcional) algumas placas precisam disso para estabilidade:
# ht_capab=[SHORT-GI-20][SHORT-GI-40]

# WPA2-PSK CCMP
auth_algs=1
ignore_broadcast_ssid=0
wpa=2
wpa_key_mgmt=WPA-PSK
rsn_pairwise=CCMP
wpa_pairwise=CCMP
wpa_passphrase=12345678

# interface de controle (útil para debug)
ctrl_interface=/var/run/hostapd
logger_syslog=-1
logger_syslog_level=2


EOF



sudo tee /etc/default/hostapd >/dev/null <<'EOF' 
DAEMON_CONF="/etc/hostapd/hostapd.conf"
EOF


sudo tee /etc/dnsmasq.d/mirako.conf >/dev/null <<'EOF' 
interface=wlan0,end0        # serve DHCP nas interfaces LAN/AP
dhcp-range=192.168.7.50,192.168.7.240,12h
domain=mirako.local
dhcp-option=3,192.168.7.1   # gateway padrão (endereço da Pi)
dhcp-option=6,8.8.8.8,8.8.4.4  # servidores DNS
log-queries
log-dhcp
EOF


sudo systemctl disable --now hostapd dnsmasq
sudo systemctl disable --now wpa_supplicant@wlan0.service
sudo systemctl disable --now NetworkManager.service



# crie/garanta diretório de chats
sudo mkdir -p /etc/chatscripts

# (re)crie o chat de CONEXÃO

sudo install -d /etc/chatscripts

sudo tee /etc/chatscripts/3g.chat >/dev/null <<'EOF'
ABORT   'BUSY'
ABORT   'NO CARRIER'
ABORT   'NO DIALTONE'
ABORT   'NO ANSWER'
ABORT   'ERROR'
ABORT   'SIM PIN'
REPORT  CONNECT
TIMEOUT 45
''        AT
OK        ATE0
OK        ATZ
OK        AT+CFUN=1
OK        AT+CGDCONT=1,"IP","zap.vivo.com.br"
OK        ATD*99#
CONNECT   \d\c
EOF


# chat de DESCONEXÃO
sudo tee /etc/chatscripts/3g-disconnect.chat >/dev/null <<'EOF'
'' '+++'
'' 'ATH'
'' 'ATZ'
EOF

# permissões: leitura suficiente (chat só precisa ler)
sudo chmod 644 /etc/chatscripts/3g.chat /etc/chatscripts/3g-disconnect.chat

# peers do pppd
sudo mkdir -p /etc/ppp/peers
sudo tee /etc/ppp/peers/3g >/dev/null <<'EOF'
/dev/ttyUSB2 115200
connect "/usr/sbin/chat -v -f /etc/chatscripts/3g.chat"
crtscts
modem
lock
debug
noauth
defaultroute
replacedefaultroute
usepeerdns
persist
holdoff 5
maxfail 0
noipdefault
noipv6
lcp-echo-interval 5
lcp-echo-failure 6
connect-delay 1000
EOF









sudo tee /usr/local/bin/profiles.sh >/dev/null <<'EOF'
#!/usr/bin/env bash
set -Eeuo pipefail

###############################################################################
# Mirako profiles script
#
# This script manages various network profiles for the Mirako router.  It can
# configure the device as an access point (AP) bridged to a wired LAN, a
# 3G/4G router using a PPP modem, a Wi-Fi client with ethernet LAN, or a
# LAN client with free Wi-Fi for scanning.  It also handles NAT, DHCP,
# firewall rules and fallbacks.
#
# The current profile is stored in /var/lib/mirako/last_profile and is used
# by the autoboot logic to reapply the desired mode on boot.
#
# Usage: profiles.sh {ap|3g|client-wifi|client-lan|ap-stop}
###############################################################################

# ===== Configuration =====
SSID="MirakoAP"
PASS="12345678"
CHANNEL=6
COUNTRY="BR"

WLAN_IF="${WLAN_IF:-wlan0}"
LAN_IF="${LAN_IF:-end0}"
PPP_IF="${PPP_IF:-ppp0}"
PPP_PEER="${PPP_PEER:-3g}"

AP_GW="${AP_GW:-192.168.0.1}"
AP_DNS1="${AP_DNS1:-8.8.8.8}"
AP_DNS2="${AP_DNS2:-8.8.4.4}"

PROFILE_FILE=/var/lib/mirako/last_profile

log() { echo "[profiles] $*"; }
have() { command -v "$1" >/dev/null 2>&1; }
T() { timeout -k 5 "${2:-25}"s bash -lc "$1"; }
save_last_profile(){ echo "$1" > "$PROFILE_FILE"; }

# Garante que o wpa_supplicant pode salvar redes
ensure_wpa_conf(){
  local conf="/etc/wpa_supplicant/wpa_supplicant-${WLAN_IF}.conf"
  local country="${COUNTRY:-BR}"
  mkdir -p /etc/wpa_supplicant

  if [ ! -s "$conf" ]; then
    {
      echo "ctrl_interface=/var/run/wpa_supplicant"
      echo "update_config=1"
      echo "country=${country}"
    } > "$conf"
    chmod 600 "$conf"
  else
    grep -q '^ctrl_interface=' "$conf" || sed -i '1i ctrl_interface=/var/run/wpa_supplicant' "$conf"
    grep -q '^update_config=1' "$conf" || sed -i '1i update_config=1' "$conf"
    grep -q '^country=' "$conf"       || sed -i "1i country=${country}" "$conf"
  fi

  # Sanitiza campos de mesh que quebram parse em modo infra
  sed -i '/^[[:space:]]*mesh_fwding[[:space:]]*=/d' "$conf"

  # Garante compatibilidade com templates que usam wpa_supplicant.conf genérico
  ln -sf "wpa_supplicant-${WLAN_IF}.conf" /etc/wpa_supplicant/wpa_supplicant.conf
}




wifi_associate_saved(){ ensure_wpa_running; }





# ===== Helpers: NAT, forwarding, DHCP =====
ensure_wpa_running(){
  ensure_wpa_conf

  # Garante diretório para o ctrl_interface
  mkdir -p /run/wpa_supplicant
  # /var/run -> /run nas distros modernas, mas garantimos dos dois lados
  [ -d /var/run/wpa_supplicant ] || ln -s /run/wpa_supplicant /var/run/wpa_supplicant 2>/dev/null || true

  # Mata iwd e mascara para não tomar a interface
  systemctl stop iwd 2>/dev/null || true
  systemctl mask iwd 2>/dev/null || true

  # Tenta via systemd template
  systemctl unmask "wpa_supplicant@.service" >/dev/null 2>&1 || true
  systemctl reset-failed "wpa_supplicant@${WLAN_IF}.service" >/dev/null 2>&1 || true
  systemctl start "wpa_supplicant@${WLAN_IF}.service" >/dev/null 2>&1 || true
  sleep 1

  if ! systemctl is-active --quiet "wpa_supplicant@${WLAN_IF}.service"; then
    # Fallback manual
    pkill -f "wpa_supplicant.*${WLAN_IF}" 2>/dev/null || true
    wpa_supplicant -B -i "$WLAN_IF" \
      -c "/etc/wpa_supplicant/wpa_supplicant-${WLAN_IF}.conf" \
      -D nl80211,wext \
      -C /run/wpa_supplicant \
      -f /var/log/wpa_supplicant.log >/dev/null 2>&1 || true
    sleep 1
  fi

  ip link set "$WLAN_IF" up || true

  if command -v wpa_cli >/dev/null 2>&1; then
    # Recarrega, habilita e seleciona rede salva
    wpa_cli -i "$WLAN_IF" reconfigure  >/dev/null 2>&1 || true
    wpa_cli -i "$WLAN_IF" list_networks 2>/dev/null | awk 'NR>1 {print $1}' | \
      while read -r id; do wpa_cli -i "$WLAN_IF" enable_network "$id" >/dev/null 2>&1 || true; done

    # Seleciona a última não desabilitada; se não achar, pega a primeira
    local sel
    sel="$(wpa_cli -i "$WLAN_IF" list_networks 2>/dev/null | \
           awk 'NR>1 && $4 !~ /DISABLED/ {keep=$1} END{print keep}')"
    [ -z "$sel" ] && sel="$(wpa_cli -i "$WLAN_IF" list_networks 2>/dev/null | awk 'NR==2 {print $1}')"
    [ -n "$sel" ] && wpa_cli -i "$WLAN_IF" select_network "$sel" >/dev/null 2>&1 || true

    # Dispara associação
    wpa_cli -i "$WLAN_IF" scan        >/dev/null 2>&1 || true
    wpa_cli -i "$WLAN_IF" reconnect   >/dev/null 2>&1 || true
    wpa_cli -i "$WLAN_IF" reassociate >/dev/null 2>&1 || true
    wpa_cli -i "$WLAN_IF" save_config >/dev/null 2>&1 || true
  fi
}




ensure_ip_forward() {
  sysctl -w net.ipv4.ip_forward=1 >/dev/null 2>&1 || true
}

ensure_nat() {
  local WAN="$1"
  have iptables || return 0
  sysctl -w net.ipv4.ip_forward=1 >/dev/null 2>&1 || true
  iptables -C FORWARD -j ACCEPT 2>/dev/null || iptables -A FORWARD -j ACCEPT
  iptables -C FORWARD -i "$WAN" -o "$WLAN_IF" -m state --state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null \
    || iptables -A FORWARD -i "$WAN" -o "$WLAN_IF" -m state --state RELATED,ESTABLISHED -j ACCEPT
  iptables -C FORWARD -i "$WLAN_IF" -o "$WAN" -j ACCEPT 2>/dev/null \
    || iptables -A FORWARD -i "$WLAN_IF" -o "$WAN" -j ACCEPT
  iptables -t nat -S POSTROUTING | awk '/MASQUERADE/ {print $0}' | sed -n 's/^-A/ -D/p' | while read -r del; do iptables -t nat $del 2>/dev/null || true; done
  iptables -t nat -A POSTROUTING -o "$WAN" -j MASQUERADE 2>/dev/null || true
}

pick_ppp_iface() {
  if ip -4 addr show dev "$PPP_IF" 2>/dev/null | grep -q 'inet '; then return 0; fi
  if ip -4 addr show dev ppp0 2>/dev/null | grep -q 'inet '; then PPP_IF="ppp0"; export PPP_IF; return 0; fi
  for d in /sys/class/net/ppp*; do
    [ -e "$d" ] || continue
    dev="$(basename "$d")"
    if ip -4 addr show dev "$dev" 2>/dev/null | grep -q 'inet '; then PPP_IF="$dev"; export PPP_IF; return 0; fi
  done
  return 1
}



wifi_force_connect_saved(){
  local conf="/etc/wpa_supplicant/wpa_supplicant-${WLAN_IF}.conf"
  [ -r "$conf" ] || return 0

  # Pega último SSID declarado no conf (assumindo que a UI grava no final)
  local want_ssid
  want_ssid="$(awk -F= '/^[[:space:]]*ssid=/{gsub(/^[[:space:]]*ssid=|"/,"",$0); s=$0} END{print s}' "$conf")"

  if command -v wpa_cli >/dev/null 2>&1; then
    # Habilita tudo e tenta selecionar por SSID se existir
    wpa_cli -i "$WLAN_IF" reconfigure  >/dev/null 2>&1 || true
    wpa_cli -i "$WLAN_IF" list_networks 2>/dev/null | awk 'NR>1 {print $1}' | \
      while read -r id; do wpa_cli -i "$WLAN_IF" enable_network "$id" >/dev/null 2>&1 || true; done

    if [ -n "$want_ssid" ]; then
      # Procura network id com esse SSID
      local nid
      nid="$(wpa_cli -i "$WLAN_IF" list_networks 2>/dev/null | \
             awk -v s="$want_ssid" -F'\t' 'NR>1 && $2==s {print $1; exit}')"
      if [ -n "$nid" ]; then
        wpa_cli -i "$WLAN_IF" select_network "$nid" >/dev/null 2>&1 || true
      fi
    fi

    wpa_cli -i "$WLAN_IF" reconnect   >/dev/null 2>&1 || true
    wpa_cli -i "$WLAN_IF" reassociate >/dev/null 2>&1 || true
  fi
}



stop_conflict() {
  # Para tudo que possa conflitar com STA/AP
  systemctl stop create_ap 2>/dev/null || true
  systemctl stop hostapd dnsmasq 2>/dev/null || true
  systemctl stop "wpa_supplicant@${WLAN_IF}.service" 2>/dev/null || true
  systemctl stop NetworkManager 2>/dev/null || true
  systemctl stop iwd 2>/dev/null || true
  systemctl mask iwd 2>/dev/null || true

  pkill -f "wpa_supplicant.*${WLAN_IF}" 2>/dev/null || true
  pkill -f "hostapd.*${WLAN_IF}"        2>/dev/null || true
  pkill iwd 2>/dev/null || true
  pkill dnsmasq 2>/dev/null || true
  rfkill unblock all || true

  ip link set "$WLAN_IF" down || true
  ip addr flush dev "$WLAN_IF" || true
  ip link set "$WLAN_IF" up || true
}


create_ap_daemon() {
  local WAN="$1"
  create_ap --stop "$WLAN_IF" 2>/dev/null || true
  if [ -z "$WAN" ]; then
    echo "[profiles] WAN vazia — usando AP nativo (hostapd/dnsmasq)"
    start_ap_native
    return
  fi
  if command -v create_ap >/dev/null 2>&1; then
    if ! create_ap --daemon --no-virt --ieee80211n --freq-band 2.4 \
                   -c "$CHANNEL" --country "$COUNTRY" \
                   "$WLAN_IF" "$WAN" "$SSID" "$PASS"; then
      echo "[profiles] create_ap falhou — caindo para AP nativo"
      start_ap_native
    fi
  else
    echo "[profiles] create_ap não encontrado — usando AP nativo"
    start_ap_native
  fi
}

has_ppp_ipv4() { ip -4 addr show dev "$PPP_IF" 2>/dev/null | grep -q 'inet '; }

ensure_ppp_up() {
  if has_ppp_ipv4; then
    log "PPP já está com IPv4 em ${PPP_IF}"
    return 0
  fi
  pkill -x pppd 2>/dev/null || true
  rm -f /var/lock/LCK..ttyUSB* 2>/dev/null || true
  if have pppd && [ -f "/etc/ppp/peers/${PPP_PEER}" ]; then
    log "Discando: pppd call ${PPP_PEER}"
    T "pppd call ${PPP_PEER}" 30 || true
  elif have pon; then
    log "Discando: pon ${PPP_PEER}"
    T "pon ${PPP_PEER}" 30 || true
  else
    log "ERRO: nem pppd nem pon encontrados."
    return 1
  fi
  for i in {1..60}; do
    if pick_ppp_iface && has_ppp_ipv4; then
      log "PPP ativo com IPv4 em ${PPP_IF}"
      return 0
    fi
    sleep 1
  done
  log "PPP não obteve IPv4 a tempo"
  return 1
}

apply_dns_to_system() {
  local ns1="$1" ns2="$2"
  if [ -n "$ns1" ] || [ -n "$ns2" ]; then
    [ -L /etc/resolv.conf ] && rm -f /etc/resolv.conf
    {
      echo "# Generated by Mirako profiles.sh (AP mode)"
      [ -n "$ns1" ] && echo "nameserver $ns1"
      [ -n "$ns2" ] && echo "nameserver $ns2"
    } > /etc/resolv.conf
  fi
}

start_ap_native() {
  systemctl unmask hostapd dnsmasq >/dev/null 2>&1 || true
  systemctl stop create_ap hostapd dnsmasq >/dev/null 2>&1 || true
  rfkill unblock all || true
  ip link set "$WLAN_IF" down || true
  ip addr flush dev "$WLAN_IF" || true
  ip addr add 192.168.7.1/24 dev "$WLAN_IF" || true
  ip link set "$WLAN_IF" up || true
  systemctl enable --now dnsmasq >/dev/null 2>&1 || true
  systemctl enable --now hostapd >/dev/null 2>&1 || true
  sleep 1
  if ! iw dev "$WLAN_IF" info 2>/dev/null | grep -q "type AP"; then
    logger -t profiles "hostapd/dnsmasq ativos, mas iface não reporta AP — rearmando"
    systemctl restart hostapd dnsmasq || true
  fi
}

start_ap_wan() {
  local WAN_IF="$1"
  stop_conflict
  ensure_ip_forward
  if [ -n "$WAN_IF" ]; then ensure_nat "$WAN_IF"; fi
  if command -v create_ap >/dev/null 2>&1; then
    create_ap --stop "$WLAN_IF" >/dev/null 2>&1 || true
    if [ -n "$WAN_IF" ]; then
      if create_ap --daemon --no-virt --ieee80211n --freq-band 2.4 \
                   -c "$CHANNEL" --country "$COUNTRY" \
                   "$WLAN_IF" "$WAN_IF" "$SSID" "$PASS"; then
        sleep 1
        if ! iw dev "$WLAN_IF" info 2>/dev/null | grep -q "type AP"; then
          echo "[profiles] create_ap subiu, mas interface não está em AP; fallback nativo."
          start_ap_native
        fi
      else
        echo "[profiles] create_ap falhou; fallback nativo."
        start_ap_native
      fi
    else
      start_ap_native
    fi
  else
    start_ap_native
  fi
  if [ -n "$WAN_IF" ]; then
    if ip -4 addr show dev "$WAN_IF" | grep -q 'inet '; then
      ip route replace default dev "$WAN_IF" || true
    fi
  fi
}

renew_dhcp() {
  have dhclient || return 0
  T "dhclient -r $1" 8 || true
  T "dhclient $1" 20 || true
}

bring_up_with_dhcp_no_default() {
  local IF="$1"
  ip link set "$IF" up || true

  if have dhclient; then
    T "dhclient -r ${IF}" 6  || true
    T "dhclient ${IF}"   25  || true
  elif have udhcpc; then
    T "udhcpc -i ${IF} -q -n" 25 || true
  fi

  # Nunca deixe esse IF colocar/ficar com default
  ip -4 route del default dev "$IF" 2>/dev/null || true

  # Mantém rota de baixa prioridade (se o lease tiver gateway), mas sem impactar a principal
  local GW
  GW="$(awk '/option routers/{for(i=3;i<=NF;i++){gsub(/[,;]*/,"",$i); printf "%s ",$i}} END{print ""}' \
        /var/lib/dhcp/dhclient.${IF}.leases 2>/dev/null | awk '{print $NF}')"
  if [ -n "$GW" ]; then
    ip route replace default via "$GW" dev "$IF" metric 400 2>/dev/null || true
  fi
}


prefer_default_via_dev() {
  local IF="$1"
  local GW
  GW="$(awk '/option routers/{for(i=3;i<=NF;i++){gsub(/[,;]*/,"",$i); printf "%s ",$i}} END{print ""}' \
        /var/lib/dhcp/dhclient.${IF}.leases 2>/dev/null | awk '{print $NF}')"
  ip -4 route del default 2>/dev/null || true
  if [ -n "$GW" ]; then
    ip route add default via "$GW" dev "$IF" metric 50 2>/dev/null || \
    ip route replace default via "$GW" dev "$IF" metric 50
  else
    ip route add default dev "$IF" metric 50 2>/dev/null || \
    ip route replace default dev "$IF" metric 50
  fi
}


PPP_CONNECT_CHECK_HOST="${PPP_CONNECT_CHECK_HOST:-8.8.8.8}"

start_ap_native_if_needed(){ start_ap_native; }
start_ap_wan_if_needed(){ local WAN="$1"; start_ap_wan "$WAN"; }

ppp_has_connectivity() {
  ip -4 addr show dev "$PPP_IF" 2>/dev/null | grep -q 'inet ' || return 1
  ping -I "$PPP_IF" -c2 -W3 "$PPP_CONNECT_CHECK_HOST" >/dev/null 2>&1
}

usage() {
  echo "Uso: $0 {ap|3g|client-wifi|client-lan|ap-stop}"
  exit 1
}

[ $# -ge 1 ] || usage
PROFILE="$1"

case "$PROFILE" in
  ap)
    save_last_profile ap
    log "== Roteador AP (WAN=${LAN_IF} → AP em ${WLAN_IF}) =="
    stop_conflict
    ip link set "$LAN_IF" up || true
    renew_dhcp "$LAN_IF"
    ensure_ip_forward
    ip route replace default via "$AP_GW" dev "$LAN_IF" || ip route replace default dev "$LAN_IF"
    ensure_nat "$LAN_IF"
    create_ap_daemon "$LAN_IF"
    apply_dns_to_system "$AP_DNS1" "$AP_DNS2"
    log "OK: AP+NAT via ${LAN_IF} (GW=${AP_GW})"
  ;;

  3g|ppp|ppp3g)
    save_last_profile 3g
    log "== Perfil: Roteador 3G/4G (WAN=${PPP_IF} → AP em ${WLAN_IF}) =="
    stop_conflict
    ensure_ip_forward
    ip link set "$LAN_IF" up || true
    bring_up_with_dhcp_no_default "$LAN_IF"
    start_ap_native
    if ensure_ppp_up && pick_ppp_iface; then
      ip route del default 2>/dev/null || true
      ip route add default dev "$PPP_IF" 2>/dev/null || ip route replace default dev "$PPP_IF"
      ensure_nat "$PPP_IF"
      log "OK: AP ativo; default via ${PPP_IF}"
    else
      ensure_nat "$PPP_IF" || true
      log "PPP indisponível agora; AP continua ativo e keepalive fará rediscagem."
    fi
  ;;

  client-wifi|wifi-client|sta)
    save_last_profile client-wifi
    log "== Cliente Wi-Fi (WAN=${WLAN_IF}) =="
    stop_conflict
    rfkill unblock all || true
    systemctl disable --now hostapd dnsmasq create_ap >/dev/null 2>&1 || true

    ip link set "$WLAN_IF" down || true
    iw dev "$WLAN_IF" set type managed 2>/dev/null || true
    ip addr flush dev "$WLAN_IF" || true
    ip link set "$WLAN_IF" up || true

    ip link set "$LAN_IF" up || true
    bring_up_with_dhcp_no_default "$LAN_IF"

    ensure_wpa_running
    wifi_force_connect_saved

    # Aguarda associação (até 60s)
    for i in {1..60}; do
      STATE="$(wpa_cli -i "$WLAN_IF" status 2>/dev/null | awk -F= '/^wpa_state=/{print $2}')"
      [ "$STATE" = "COMPLETED" ] && break
      sleep 1
    done


    # DHCP na wlan0
    if have dhclient; then
      T "dhclient -r ${WLAN_IF}" 8  || true
      T "dhclient ${WLAN_IF}"  25   || true
    elif have udhcpc; then
      T "udhcpc -i ${WLAN_IF} -q -n" 25 || true
    fi

    prefer_default_via_dev "$WLAN_IF"

    for IF in $(ls /sys/class/net/en* 2>/dev/null || true); do
      bring_up_with_dhcp_no_default "$(basename "$IF")"
    done
    ip link set "$LAN_IF" up || true
    renew_dhcp "$LAN_IF"

    log "OK: STA no Wi-Fi (default via ${WLAN_IF}); LAN(s) ativa(s) com IP (sem default)."
  ;;

  client-lan|lan-client)
    save_last_profile client-lan
    log "== Cliente LAN (WAN=${LAN_IF}; Wi-Fi livre p/ scan) =="
    create_ap --stop "$WLAN_IF" 2>/dev/null || true
    systemctl stop hostapd dnsmasq 2>/dev/null || true
    ip link set "$WLAN_IF" down || true
    iw dev "$WLAN_IF" set type managed 2>/dev/null || true
    ip link set "$WLAN_IF" up || true
    ip link set "$LAN_IF" up || true
    renew_dhcp "$LAN_IF"
    systemctl start NetworkManager 2>/dev/null || true
    systemctl restart "wpa_supplicant@${WLAN_IF}.service" 2>/dev/null || true
    ip addr flush dev "$WLAN_IF" || true
    log "OK: WAN pela ${LAN_IF}; Wi-Fi em managed p/ scan"
  ;;

  ap-stop)
    log "Parando AP"
    create_ap --stop "$WLAN_IF" 2>/dev/null || true
    log "OK"
  ;;

  *)
    usage
  ;;
esac


EOF

sudo chmod +x /usr/local/bin/profiles.sh




sudo tee /usr/local/bin/mirako-autoboot.sh >/dev/null <<'EOF'
#!/usr/bin/env bash
set -Euo pipefail

# Auto-selector for router profiles on boot.
# Reads last profile from /var/lib/mirako/last_profile and applies the
# appropriate profile via profiles.sh. Supports fallback to AP if
# connectivity criteria are not met.

PROFILE_FILE=/var/lib/mirako/last_profile
DEF=ap
want="$(cat "$PROFILE_FILE" 2>/dev/null || echo "$DEF")"

# Default interfaces; can be overridden via environment.
export WLAN_IF="${WLAN_IF:-wlan0}"
export LAN_IF="${LAN_IF:-end0}"
export PPP_IF="${PPP_IF:-ppp0}"
export PPP_PEER="${PPP_PEER:-3g}"
export PROFILES_SCRIPT="${PROFILES_SCRIPT:-/usr/local/bin/profiles.sh}"

log(){ echo "[autoboot] $*"; }
record_profile(){ echo "$1" > "$PROFILE_FILE"; }

# Cria/ajusta o wpa_supplicant conf para permitir salvar redes
ensure_wpa_conf(){
  local conf="/etc/wpa_supplicant/wpa_supplicant-${WLAN_IF}.conf"
  local country="${COUNTRY:-BR}"
  mkdir -p /etc/wpa_supplicant

  if [ ! -s "$conf" ]; then
    {
      echo "ctrl_interface=/var/run/wpa_supplicant"
      echo "update_config=1"
      echo "country=${country}"
    } > "$conf"
    chmod 600 "$conf"
  else
    grep -q '^ctrl_interface=' "$conf" || sed -i '1i ctrl_interface=/var/run/wpa_supplicant' "$conf"
    grep -q '^update_config=1' "$conf" || sed -i '1i update_config=1' "$conf"
    grep -q '^country=' "$conf"       || sed -i "1i country=${country}" "$conf"
  fi

  # Sanitiza campos de mesh que quebram parse em modo infra
  sed -i '/^[[:space:]]*mesh_fwding[[:space:]]*=/d' "$conf"

  # Garante compatibilidade com templates que usam wpa_supplicant.conf genérico
  ln -sf "wpa_supplicant-${WLAN_IF}.conf" /etc/wpa_supplicant/wpa_supplicant.conf
}


# Ensure wpa_supplicant service is running for Wi-Fi client mode.
ensure_wpa_running(){
  ensure_wpa_conf

  # Garante diretório para o ctrl_interface
  mkdir -p /run/wpa_supplicant
  # /var/run -> /run nas distros modernas, mas garantimos dos dois lados
  [ -d /var/run/wpa_supplicant ] || ln -s /run/wpa_supplicant /var/run/wpa_supplicant 2>/dev/null || true

  # Mata iwd e mascara para não tomar a interface
  systemctl stop iwd 2>/dev/null || true
  systemctl mask iwd 2>/dev/null || true

  # Tenta via systemd template
  systemctl unmask "wpa_supplicant@.service" >/dev/null 2>&1 || true
  systemctl reset-failed "wpa_supplicant@${WLAN_IF}.service" >/dev/null 2>&1 || true
  systemctl start "wpa_supplicant@${WLAN_IF}.service" >/dev/null 2>&1 || true
  sleep 1

  if ! systemctl is-active --quiet "wpa_supplicant@${WLAN_IF}.service"; then
    # Fallback manual
    pkill -f "wpa_supplicant.*${WLAN_IF}" 2>/dev/null || true
    wpa_supplicant -B -i "$WLAN_IF" \
      -c "/etc/wpa_supplicant/wpa_supplicant-${WLAN_IF}.conf" \
      -D nl80211,wext \
      -C /run/wpa_supplicant \
      -f /var/log/wpa_supplicant.log >/dev/null 2>&1 || true
    sleep 1
  fi

  ip link set "$WLAN_IF" up || true

  if command -v wpa_cli >/dev/null 2>&1; then
    # Recarrega, habilita e seleciona rede salva
    wpa_cli -i "$WLAN_IF" reconfigure  >/dev/null 2>&1 || true
    wpa_cli -i "$WLAN_IF" list_networks 2>/dev/null | awk 'NR>1 {print $1}' | \
      while read -r id; do wpa_cli -i "$WLAN_IF" enable_network "$id" >/dev/null 2>&1 || true; done

    # Seleciona a última não desabilitada; se não achar, pega a primeira
    local sel
    sel="$(wpa_cli -i "$WLAN_IF" list_networks 2>/dev/null | \
           awk 'NR>1 && $4 !~ /DISABLED/ {keep=$1} END{print keep}')"
    [ -z "$sel" ] && sel="$(wpa_cli -i "$WLAN_IF" list_networks 2>/dev/null | awk 'NR==2 {print $1}')"
    [ -n "$sel" ] && wpa_cli -i "$WLAN_IF" select_network "$sel" >/dev/null 2>&1 || true

    # Dispara associação
    wpa_cli -i "$WLAN_IF" scan        >/dev/null 2>&1 || true
    wpa_cli -i "$WLAN_IF" reconnect   >/dev/null 2>&1 || true
    wpa_cli -i "$WLAN_IF" reassociate >/dev/null 2>&1 || true
    wpa_cli -i "$WLAN_IF" save_config >/dev/null 2>&1 || true
  fi
}






# Get current wpa_supplicant association state via wpa_cli.
wifi_state(){
  command -v wpa_cli >/dev/null 2>&1 || { echo "DOWN"; return; }
  wpa_cli -i "$WLAN_IF" status 2>/dev/null | sed -n 's/^wpa_state=//p'
}

# Test if WLAN interface has IPv4.  Suppress errors when the interface does not exist.
wlan_has_ipv4(){
  ip -4 addr show dev "$WLAN_IF" 2>/dev/null | grep -q 'inet ' || return 1
}

# Try DHCP on WLAN interface.
try_dhcp_wlan(){
  command -v dhclient >/dev/null 2>&1 || return 0
  dhclient -r "$WLAN_IF" >/dev/null 2>&1 || true
  dhclient "$WLAN_IF" >/dev/null 2>&1 || true
}

# Wait for Wi-Fi association and IPv4 acquisition
wait_wifi_connected(){
  local timeout="${1:-60}"
  local end=$((SECONDS+timeout))
  local associated=0
  while [ $SECONDS -lt $end ]; do
    local st
    st="$(command -v wpa_cli >/dev/null 2>&1 && wpa_cli -i "$WLAN_IF" status 2>/dev/null | sed -n 's/^wpa_state=//p' || echo DOWN)"
    if [ "$st" = "COMPLETED" ]; then
      associated=1
      if ip -4 addr show dev "$WLAN_IF" 2>/dev/null | grep -q 'inet '; then
        return 0
      fi
      if command -v dhclient >/dev/null 2>&1; then
        dhclient -r "$WLAN_IF" >/dev/null 2>&1 || true
        dhclient    "$WLAN_IF" >/dev/null 2>&1 || true
      elif command -v udhcpc >/dev/null 2>&1; then
        udhcpc -i "$WLAN_IF" -q -n >/dev/null 2>&1 || true
      fi
      sleep 2
      ip -4 addr show dev "$WLAN_IF" 2>/dev/null | grep -q 'inet ' && return 0
    else
      sleep 1
    fi
  done
  [ "$associated" = "1" ]
}



wifi_force_connect_saved(){
  local conf="/etc/wpa_supplicant/wpa_supplicant-${WLAN_IF}.conf"
  [ -r "$conf" ] || return 0

  # Pega último SSID declarado no conf (assumindo que a UI grava no final)
  local want_ssid
  want_ssid="$(awk -F= '/^[[:space:]]*ssid=/{gsub(/^[[:space:]]*ssid=|"/,"",$0); s=$0} END{print s}' "$conf")"

  if command -v wpa_cli >/dev/null 2>&1; then
    # Habilita tudo e tenta selecionar por SSID se existir
    wpa_cli -i "$WLAN_IF" reconfigure  >/dev/null 2>&1 || true
    wpa_cli -i "$WLAN_IF" list_networks 2>/dev/null | awk 'NR>1 {print $1}' | \
      while read -r id; do wpa_cli -i "$WLAN_IF" enable_network "$id" >/dev/null 2>&1 || true; done

    if [ -n "$want_ssid" ]; then
      # Procura network id com esse SSID
      local nid
      nid="$(wpa_cli -i "$WLAN_IF" list_networks 2>/dev/null | \
             awk -v s="$want_ssid" -F'\t' 'NR>1 && $2==s {print $1; exit}')"
      if [ -n "$nid" ]; then
        wpa_cli -i "$WLAN_IF" select_network "$nid" >/dev/null 2>&1 || true
      fi
    fi

    wpa_cli -i "$WLAN_IF" reconnect   >/dev/null 2>&1 || true
    wpa_cli -i "$WLAN_IF" reassociate >/dev/null 2>&1 || true
  fi
}


stop_conflict() {
  # Para tudo que possa conflitar com STA/AP
  systemctl stop create_ap 2>/dev/null || true
  systemctl stop hostapd dnsmasq 2>/dev/null || true
  systemctl stop "wpa_supplicant@${WLAN_IF}.service" 2>/dev/null || true
  systemctl stop NetworkManager 2>/dev/null || true
  systemctl stop iwd 2>/dev/null || true
  systemctl mask iwd 2>/dev/null || true

  pkill -f "wpa_supplicant.*${WLAN_IF}" 2>/dev/null || true
  pkill -f "hostapd.*${WLAN_IF}"        2>/dev/null || true
  pkill iwd 2>/dev/null || true
  pkill dnsmasq 2>/dev/null || true
  rfkill unblock all || true

  ip link set "$WLAN_IF" down || true
  ip addr flush dev "$WLAN_IF" || true
  ip link set "$WLAN_IF" up || true
}

# Determine se o link da LAN está ativo
lan_has_link(){
  local if="${LAN_IF:-end0}"
  ip link show "$if" >/dev/null 2>&1 || return 1
  # ethtool se existir, usa; senão, assume link se tiver carrier no sysfs
  if command -v ethtool >/dev/null 2>&1; then
    ethtool "$if" 2>/dev/null | grep -q "Link detected: yes"
  else
    [ "$(cat /sys/class/net/$if/carrier 2>/dev/null)" = "1" ]
  fi
}



# Check PPP interface connectivity via ping to 8.8.8.8.
ppp_connectivity(){
  ip -4 addr show dev "$PPP_IF" 2>/dev/null | grep -q 'inet ' || return 1
  ping -I "$PPP_IF" -c2 -W3 8.8.8.8 >/dev/null 2>&1
}

case "$want" in
  ap)
    record_profile ap
    exec "$PROFILES_SCRIPT" ap
    ;;

  3g|ppp|ppp3g)
    record_profile 3g
    exec "$PROFILES_SCRIPT" 3g
    ;;

  client-lan|lan-client)
    if lan_has_link; then
      record_profile client-lan
      exec "$PROFILES_SCRIPT" client-lan
    else
      record_profile ap
      exec "$PROFILES_SCRIPT" ap
    fi
    ;;

  client-wifi|wifi-client|sta)
    ensure_wpa_running
    attempts=0
    while [ $attempts -lt 5 ]; do
      "$PROFILES_SCRIPT" client-wifi || true
      if wait_wifi_connected 15; then
        log "Wi-Fi conectado/associado (STA). Mantendo perfil client-wifi."
        record_profile client-wifi
        exit 0
      fi
      attempts=$((attempts+1))
      log "Tentativa Wi-Fi ${attempts}/5 falhou; tentando novamente..."
    done
    log "Não foi possível conectar ao Wi-Fi após 5 tentativas. Fallback para AP."
    record_profile ap
    "$PROFILES_SCRIPT" ap || true
    exit 0
    ;;

  *)
    record_profile ap
    exec "$PROFILES_SCRIPT" ap
    ;;
esac

EOF

sudo chmod +x /usr/local/bin/mirako-autoboot.sh





mkdir /opt/mirako_web

sudo tee /opt/mirako_web/web_config.py >/dev/null <<'EOF'
#!/usr/bin/env python3
# coding: utf-8
"""
Mirako router configuration web application — versão offline sem Bootstrap.

Alterações desta versão:
- Remoção total de Bootstrap/CDN (CSS embutido).
- Atualização de status do sistema a cada 15s via /status.json.
- Lista de Wi-Fi lida também do wpa_supplicant.
- Card de arquivos: clique no nome para baixar diretamente de /root.
- Cores dos botões destacadas no CSS (hover/active/outline/danger/ok/warn/primary).
"""

from __future__ import annotations

import os
import re
import time
import glob
import shutil
import subprocess
import threading
import signal
from typing import Any, List, Tuple, Dict

from flask import (
    Flask,
    render_template_string,
    request,
    redirect,
    url_for,
    flash,
    jsonify,
    send_from_directory,
    abort,
)

app = Flask(__name__)
app.secret_key = os.environ.get("MIRAKO_SECRET", "devkey")

# ========================== Config em runtime ==========================
WLAN_IF = os.environ.get("WLAN_IF", "wlan0")
LAN_IF = os.environ.get("LAN_IF", "end0")
PPP_IF = os.environ.get("PPP_IF", "ppp0")
PPP_PEER = os.environ.get("PPP_PEER", "3g")
PROFILES_SCRIPT = os.environ.get("PROFILES_SCRIPT", "/usr/local/bin/profiles.sh")
AUTO_DIAL_FILE = "/var/lib/mirako/auto_dial_enabled"
SSID = os.environ.get("SSID") or os.environ.get("AP_SSID") or "MirakoAP"
PASS = os.environ.get("PASS") or os.environ.get("AP_PASS") or "12345678"

def find_bin(name: str, fallbacks: List[str]) -> str:
    p = shutil.which(name)
    if p:
        return p
    for fb in fallbacks:
        if os.path.exists(fb) and os.access(fb, os.X_OK):
            return fb
    return name

PPPD_BIN = find_bin("pppd", ["/usr/sbin/pppd", "/sbin/pppd", "/usr/bin/pppd"])
IP_BIN = find_bin("ip", ["/usr/sbin/ip", "/sbin/ip", "/usr/bin/ip"])
IW_BIN = find_bin("iw", ["/usr/sbin/iw", "/sbin/iw", "/usr/bin/iw"])
IWLIST_BIN = find_bin("iwlist", ["/usr/sbin/iwlist", "/sbin/iwlist", "/usr/bin/iwlist"])
WPA_CLI_BIN = find_bin("wpa_cli", ["/usr/sbin/wpa_cli", "/sbin/wpa_cli", "/usr/bin/wpa_cli"])
RESOLVECTL_BIN = find_bin("resolvectl", ["/usr/bin/resolvectl", "/usr/sbin/resolvectl", "/bin/resolvectl"])

# ========================== Terminal ao vivo ==========================
LOG_DIR = "/var/log/mirako"
os.makedirs(LOG_DIR, exist_ok=True)
TERM_LOG = os.path.join(LOG_DIR, "terminal.log")
RUN: Dict[str, Any] = {"proc": None, "pgid": None}
RUN_LOCK = threading.Lock()

def _write_line(text: str) -> None:
    try:
        with open(TERM_LOG, "a", encoding="utf-8", errors="ignore") as f:
            f.write(text)
            if not text.endswith("\n"):
                f.write("\n")
    except Exception:
        pass

def _pump_stdout(proc: subprocess.Popen) -> None:
    try:
        for line in iter(proc.stdout.readline, ""):
            _write_line(line.rstrip("\n"))
    except Exception as e:
        _write_line(f"[pump] erro: {e}")
    finally:
        code = proc.wait()
        _write_line(f"\n[processo finalizado] exit={code}")

def start_command(cmd: str) -> None:
    raw = cmd.strip()
    if not raw:
        return
    with RUN_LOCK:
        if RUN["proc"] is not None and RUN["proc"].poll() is None:
            try:
                os.killpg(RUN["pgid"], signal.SIGINT)
            except Exception:
                try:
                    RUN["proc"].terminate()
                except Exception:
                    pass
        try:
            with open(TERM_LOG, "w", encoding="utf-8", errors="ignore") as f:
                f.write(f"# {time.strftime('%Y-%m-%d %H:%M:%S')} — exec: {raw}\n")
        except Exception:
            pass
        proc = subprocess.Popen(
            raw,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1,
            preexec_fn=os.setsid,
        )
        RUN["proc"] = proc
        RUN["pgid"] = os.getpgid(proc.pid)
        t = threading.Thread(target=_pump_stdout, args=(proc,), daemon=True)
        t.start()

def stop_command() -> None:
    with RUN_LOCK:
        if RUN["proc"] is not None and RUN["proc"].poll() is None:
            try:
                os.killpg(RUN["pgid"], signal.SIGINT)
                _write_line("[SIGINT enviado]")
            except Exception as e:
                _write_line(f"[erro SIGINT] {e}")
                try:
                    RUN["proc"].terminate()
                except Exception:
                    pass

def clear_log() -> None:
    try:
        with open(TERM_LOG, "w", encoding="utf-8") as f:
            f.write("")
    except Exception:
        pass

def read_log_tail(max_bytes: int = 120_000) -> str:
    try:
        with open(TERM_LOG, "rb") as f:
            f.seek(0, os.SEEK_END)
            size = f.tell()
            off = max(0, size - max_bytes)
            f.seek(off, os.SEEK_SET)
            data = f.read().decode("utf-8", errors="ignore")
            return data
    except Exception:
        return "(sem saída ainda)"

# ========================== Helpers genéricos ==========================
def run(cmd: List[str], timeout: int = 10) -> Tuple[int, str]:
    try:
        out = subprocess.check_output(
            cmd, stderr=subprocess.STDOUT, text=True, timeout=timeout
        )
        return 0, out.strip()
    except subprocess.CalledProcessError as e:
        return e.returncode, (e.output or "").strip()
    except Exception as e:
        return 1, f"{type(e).__name__}: {e}"

def human_bytes(n: float) -> str:
    try:
        n = float(n)
    except Exception:
        return str(n)
    units = ["B", "KB", "MB", "GB", "TB"]
    i = 0
    while n >= 1024 and i < len(units) - 1:
        n /= 1024.0
        i += 1
    return f"{n:.1f} {units[i]}"

# ========================== Rede ==========================
def ensure_iface_up(dev: str) -> None:
    base = f"/sys/class/net/{dev}"
    if not os.path.exists(base):
        return
    try:
        state = open(os.path.join(base, "operstate")).read().strip().lower()
    except Exception:
        state = "unknown"
    if state != "up":
        run([IP_BIN, "link", "set", "dev", dev, "up"])

def get_ipv4_list(dev: str) -> str:
    rc, out = run([IP_BIN, "-4", "addr", "show", "dev", dev])
    if rc != 0:
        return "-"
    ips: List[str] = []
    for line in out.splitlines():
        s = line.strip()
        if s.startswith("inet "):
            parts = s.split()
            if len(parts) >= 2:
                ips.append(parts[1])
    return ", ".join(ips) if ips else "-"

def default_route() -> str:
    rc, out = run([IP_BIN, "-4", "route", "show", "default"])
    return out if rc == 0 and out else "<sem rota>"

def routes() -> str:
    rc, out = run([IP_BIN, "-4", "route"])
    return out if rc == 0 else f"(erro ip route rc={rc})"

def dns_info() -> str:
    if os.path.exists(RESOLVECTL_BIN):
        rc, out = run([RESOLVECTL_BIN, "status"], timeout=5)
        if rc == 0 and out:
            return out
    try:
        with open("/etc/resolv.conf", "r", encoding="utf-8", errors="ignore") as f:
            return f.read()
    except Exception as e:
        return f"# erro ao ler resolv.conf: {e}"

def read_dnsmasq_leases() -> Tuple[List[dict], str, str | None]:
    paths = ["/var/lib/misc/dnsmasq.leases", "/var/lib/dnsmasq/dnsmasq.leases"]
    for path in paths:
        if os.path.exists(path):
            leases: List[dict] = []
            raw = ""
            try:
                raw = open(path, "r", encoding="utf-8", errors="ignore").read()
                for line in raw.splitlines():
                    parts = line.split()
                    if len(parts) >= 5:
                        expiry, mac, ip, hostname, client_id = parts[:5]
                        try:
                            expi = int(expiry)
                            when = (
                                "infinito"
                                if expi == 0
                                else time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(expi))
                            )
                        except Exception:
                            when = expiry
                        leases.append(
                            {
                                "expiry": when,
                                "mac": mac,
                                "ip": ip,
                                "hostname": hostname if hostname != "*" else "",
                                "client_id": client_id,
                            }
                        )
            except Exception as e:
                raw = f"(erro ao ler {path}: {e})"
            return leases, raw, path
    return [], "(arquivo de leases não encontrado)", None

# ========================== Estado do sistema ==========================
def cpu_temp_c() -> float | None:
    temps: List[float] = []
    best: float | None = None
    for path in glob.glob("/sys/class/thermal/thermal_zone*/temp"):
        try:
            t = int(open(path).read().strip())
            c = t / 1000.0 if t > 1000 else float(t)
            ttype_path = path.replace("/temp", "/type")
            ttype = open(ttype_path).read().strip().lower() if os.path.exists(ttype_path) else ""
            if "cpu" in ttype or "soc" in ttype:
                best = c
            temps.append(c)
        except Exception:
            pass
    if best is not None:
        return best
    if temps:
        return sum(temps) / len(temps)
    try:
        c = int(open("/sys/class/thermal/thermal_zone0/temp").read().strip()) / 1000.0
        return c
    except Exception:
        return None

def cpu_usage_pct(sample_sec: float = 0.2) -> float:
    def read_cpu() -> Tuple[int, int]:
        with open("/proc/stat", "r") as f:
            for line in f:
                if line.startswith("cpu "):
                    parts = line.split()
                    vals = list(map(int, parts[1:]))
                    idle = vals[3] + (vals[4] if len(vals) > 4 else 0)
                    total = sum(vals)
                    return idle, total
        return 0, 1
    idle1, total1 = read_cpu()
    time.sleep(sample_sec)
    idle2, total2 = read_cpu()
    dtotal = total2 - total1
    didle = idle2 - idle1
    if dtotal <= 0:
        return 0.0
    busy = 100.0 * (1.0 - (didle / dtotal))
    if busy < 0:
        busy = 0.0
    max_pct = 100 * (os.cpu_count() or 1)
    return busy if busy <= max_pct else max_pct

def mem_stats() -> Dict[str, float]:
    info: Dict[str, str] = {}
    with open("/proc/meminfo", "r") as f:
        for line in f:
            k, v = line.split(":", 1)
            info[k.strip()] = v.strip()
    def kB(name: str) -> int:
        val = info.get(name, "0").split()[0]
        return int(val)
    total = kB("MemTotal") * 1024
    avail = kB("MemAvailable") * 1024
    used = total - avail
    pct = (used / total * 100.0) if total > 0 else 0.0
    return dict(total=total, used=used, avail=avail, pct=pct)

def disk_stats(path: str = "/") -> Dict[str, float]:
    du = shutil.disk_usage(path)
    used = du.total - du.free
    pct = used / du.total * 100.0 if du.total else 0.0
    return dict(total=du.total, used=used, free=du.free, pct=pct)

def processes_top(n: int = 20) -> List[dict]:
    rc, out = run(["ps", "-eo", "pid,comm,%cpu,%mem", "--sort=-%cpu"])
    procs: List[dict] = []
    if rc == 0 and out:
        lines = out.splitlines()
        for line in lines[1 : 1 + n]:
            parts = line.split(None, 4)
            if len(parts) >= 4:
                pid, comm, pcpu, pmem = parts[:4]
                procs.append(dict(pid=pid, comm=comm, pcpu=pcpu, pmem=pmem))
    return procs

def net_stats_for(dev: str) -> dict:
    base = f"/sys/class/net/{dev}"
    if not os.path.exists(base):
        return dict(dev=dev, state="DOWN", ipv4="-", rx="-", tx="-")
    try:
        state = open(os.path.join(base, "operstate")).read().strip().upper()
    except Exception:
        state = "?"
    def read_num(p: str) -> int:
        try:
            return int(open(p).read().strip())
        except Exception:
            return 0
    rx = read_num(os.path.join(base, "statistics/rx_bytes"))
    tx = read_num(os.path.join(base, "statistics/tx_bytes"))
    return dict(
        dev=dev,
        state=state,
        ipv4=get_ipv4_list(dev),
        rx=human_bytes(rx),
        tx=human_bytes(tx),
    )

# ========================== Wi-Fi ==========================
def iw_info() -> dict:
    rc, out = run([IW_BIN, "dev", WLAN_IF, "info"])
    info: Dict[str, Any] = {"type": "-", "channel": "-", "freq_mhz": None, "txpower_dbm": "-"}
    if rc == 0 and out:
        for ln in out.splitlines():
            s = ln.strip()
            if s.startswith("type "):
                info["type"] = s.split(" ", 1)[1].strip()
            elif "channel" in s and "(" in s and "MHz" in s:
                try:
                    parts = s.split()
                    info["channel"] = parts[1]
                    mhz = s.split("(")[1].split("MHz")[0].strip()
                    info["freq_mhz"] = float(mhz)
                except Exception:
                    pass
            elif s.startswith("txpower "):
                try:
                    val = s.split()[1]
                    info["txpower_dbm"] = f"{float(val):.1f} dBm"
                except Exception:
                    pass
    return info

def get_ap_ssid() -> str:
    for path in glob.glob("/tmp/create_ap*.conf"):
        try:
            txt = open(path, "r", encoding="utf-8", errors="ignore").read()
            m = re.search(r"^\s*ssid\s*=\s*(.+)$", txt, re.M)
            if m:
                return m.group(1).strip()
        except Exception:
            pass
    rc, out = run([IW_BIN, "dev", WLAN_IF, "info"])
    if rc == 0 and out:
        for ln in out.splitlines():
            s = ln.strip()
            if s.lower().startswith("ssid "):
                return s.split(None, 1)[1].strip()
    return SSID

def iw_link() -> dict:
    rc, out = run([IW_BIN, "dev", WLAN_IF, "link"])
    d: Dict[str, Any] = {
        "connected": False,
        "ssid": "-",
        "bssid": "-",
        "signal_dbm": None,
        "rx_bitrate": "-",
        "tx_bitrate": "-",
        "rx": "-",
        "tx": "-",
        "clients": 0,
    }
    if rc == 0 and out:
        if "Not connected." in out:
            d["connected"] = True
            d["ssid"] = get_ap_ssid()
            rc2, st = run([IW_BIN, "dev", WLAN_IF, "station", "dump"])
            if rc2 == 0 and st:
                clients = 0
                rssi = None
                for ln in st.splitlines():
                    s = ln.strip().lower()
                    if s.startswith("station "):
                        clients += 1
                    if s.startswith("signal:"):
                        try:
                            rssi = float(s.split()[1])
                        except Exception:
                            pass
                d["clients"] = clients
                if rssi is not None:
                    d["signal_dbm"] = rssi
            return d
        else:
            d["connected"] = True
            for ln in out.splitlines():
                s = ln.strip()
                if s.startswith("SSID:"):
                    d["ssid"] = s.split(":", 1)[1].strip()
                elif s.startswith("Connected to "):
                    d["bssid"] = s.split()[2].strip()
                elif s.startswith("signal:"):
                    try:
                        d["signal_dbm"] = float(s.split()[1])
                    except Exception:
                        pass
                elif s.startswith("rx bitrate:"):
                    d["rx_bitrate"] = s.split(":", 1)[1].strip()
                elif s.startswith("tx bitrate:"):
                    d["tx_bitrate"] = s.split(":", 1)[1].strip()
                elif s.startswith("RX:"):
                    d["rx"] = s.split(":", 1)[1].strip()
                elif s.startswith("TX:"):
                    d["tx"] = s.split(":", 1)[1].strip()
    return d

def iface_byte_counters(dev: str) -> Tuple[int, int, int, int]:
    base = f"/sys/class/net/{dev}/statistics"
    try:
        rx1 = int(open(os.path.join(base, "rx_bytes")).read().strip())
        tx1 = int(open(os.path.join(base, "tx_bytes")).read().strip())
        time.sleep(0.25)
        rx2 = int(open(os.path.join(base, "rx_bytes")).read().strip())
        tx2 = int(open(os.path.join(base, "tx_bytes")).read().strip())
        rx_bps = (rx2 - rx1) * 8 * 4
        tx_bps = (tx2 - tx1) * 8 * 4
        return (rx2, tx2, rx_bps, tx_bps)
    except Exception:
        return (0, 0, 0, 0)

def wpa_status() -> dict:
    rc, out = run([WPA_CLI_BIN, "-i", WLAN_IF, "status"])
    d: Dict[str, Any] = {}
    if rc == 0:
        for line in out.splitlines():
            if "=" in line:
                k, v = line.split("=", 1)
                d[k] = v
    return d

def wifi_status_details() -> dict:
    st = wpa_status()
    ii = iw_info()
    lk = iw_link()
    rxB, txB, rxbps, txbps = iface_byte_counters(WLAN_IF)
    mode = ii.get("type", "-").upper()
    state = st.get("wpa_state", "-")
    channel = ii.get("channel", "-")
    freq_mhz = ii.get("freq_mhz")
    rssi = lk.get("signal_dbm")
    dist_m = None
    try:
        import math
        if (rssi is not None) and freq_mhz:
            dist_m = round(10 ** ((27.55 - (20 * math.log10(float(freq_mhz))) + abs(float(rssi))) / 20), 1)
    except Exception:
        pass
    return {
        "mode": mode,
        "state": state,
        "ssid": lk.get("ssid", "-"),
        "bssid": lk.get("bssid", "-"),
        "channel": channel,
        "freq_mhz": f"{freq_mhz:.0f} MHz" if freq_mhz else "-",
        "txpower": ii.get("txpower_dbm", "-"),
        "rssi": f"{rssi:.0f} dBm" if rssi is not None else "-",
        "tx_bitrate": lk.get("tx_bitrate", "-"),
        "rx_bitrate": lk.get("rx_bitrate", "-"),
        "rx_bytes": human_bytes(rxB),
        "tx_bytes": human_bytes(txB),
        "rx_bps": f"{rxbps/1e6:.2f} Mbit/s" if rxbps > 0 else "0",
        "tx_bps": f"{txbps/1e6:.2f} Mbit/s" if txbps > 0 else "0",
        "clients": lk.get("clients", 0),
        "distance_m": f"~{dist_m} m" if dist_m else "-",
    }

def wifi_scan() -> Tuple[List[dict], str | None]:
    ensure_iface_up(WLAN_IF)
    rc, out = run([IW_BIN, "dev", WLAN_IF, "scan"])
    if rc == 0 and out:
        bss: Dict[str, Any] | None = None
        nets: List[dict] = []
        for line in out.splitlines():
            s = line.strip()
            if s.startswith("BSS "):
                if bss:
                    nets.append(bss)
                bss = {"ssid": "", "signal": "", "freq": "", "security": "?"}
            elif s.startswith("SSID:"):
                if bss is None:
                    bss = {}
                bss["ssid"] = s[5:].strip()
            elif s.startswith("freq:"):
                if bss is None:
                    bss = {}
                bss["freq"] = s[5:].strip()
            elif s.startswith("signal:"):
                if bss is None:
                    bss = {}
                bss["signal"] = s[7:].strip()
            elif s.startswith("RSN:") or s.startswith("WPA:"):
                if bss is None:
                    bss = {}
                bss["security"] = "WPA/WPA2"
        if bss:
            nets.append(bss)
        nets = [n for n in nets if n.get("ssid")]
        uniq: Dict[str, dict] = {}
        for n in nets:
            ssid = n["ssid"]
            if ssid not in uniq or n.get("signal", "") > uniq[ssid].get("signal", ""):
                uniq[ssid] = n
        return list(uniq.values()), None
    rc2, out2 = run([IWLIST_BIN, WLAN_IF, "scan"])
    if rc2 == 0 and out2:
        nets = []
        for b in out2.split("Cell "):
            ssid_m = re.search(r'ESSID:"(.*)"', b)
            qual = re.search(r"Signal level=(-?\d+)", b) or re.search(r"Quality=([0-9/]+)", b)
            freq = re.search(r"Frequency:([0-9\.]+)", b)
            enc = "Open" if "Encryption key:off" in b else "WPA/WPA2"
            if ssid_m:
                nets.append(
                    {
                        "ssid": ssid_m.group(1),
                        "signal": (qual.group(1) if qual else "?"),
                        "freq": (freq.group(1) if freq else "?"),
                        "security": enc,
                    }
                )
        return nets, None
    return [], "iw scan falhou"

def get_saved_networks() -> List[Dict[str, str]]:
    rc, out = run([WPA_CLI_BIN, "-i", WLAN_IF, "list_networks"])
    nets: List[Dict[str, str]] = []
    if rc == 0 and out:
        lines = out.splitlines()[1:]
        for line in lines:
            parts = line.split("\t")
            if len(parts) >= 4:
                nets.append(
                    {"id": parts[0].strip(), "ssid": parts[1].strip(), "bssid": parts[2].strip(), "flags": parts[3].strip()}
                )
    return nets

def read_wpa_conf_networks() -> List[Dict[str, str]]:
    paths = [
        f"/etc/wpa_supplicant/wpa_supplicant-{WLAN_IF}.conf",
        "/etc/wpa_supplicant/wpa_supplicant.conf",
    ]
    items: List[Dict[str, str]] = []
    for path in paths:
        if not os.path.exists(path):
            continue
        try:
            txt = open(path, "r", encoding="utf-8", errors="ignore").read()
        except Exception:
            continue
        for block in re.findall(r'network=\{(.*?)\}', txt, flags=re.S | re.M):
            ssid_m = re.search(r'^\s*ssid\s*=\s*"(.*?)"\s*$', block, flags=re.M)
            psk_m  = re.search(r'^\s*psk\s*=\s*"(.*?)"\s*$', block, flags=re.M)
            keymgmt_m = re.search(r'^\s*key_mgmt\s*=\s*(.*?)\s*$', block, flags=re.M)
            prio_m = re.search(r'^\s*priority\s*=\s*(\d+)\s*$', block, flags=re.M)
            items.append({
                "ssid": ssid_m.group(1) if ssid_m else "(sem ssid)",
                "psk": ("(oculta)" if psk_m else ("OPEN" if (keymgmt_m and keymgmt_m.group(1).strip().upper()=="NONE") else "(?)")),
                "key_mgmt": (keymgmt_m.group(1).strip() if keymgmt_m else "-"),
                "priority": (prio_m.group(1) if prio_m else "-"),
            })
    uniq: Dict[str, Dict[str, str]] = {}
    for n in items:
        k = n["ssid"]
        if k not in uniq:
            uniq[k] = n
        else:
            try:
                if int(n.get("priority","0")) > int(uniq[k].get("priority","0")):
                    uniq[k] = n
            except Exception:
                pass
    out = list(uniq.values())
    try:
        out.sort(key=lambda x: int(x.get("priority","0")), reverse=True)
    except Exception:
        pass
    return out

def wifi_connect(ssid: str, psk: str | None = None) -> Tuple[bool, str]:
    rc_svc, _ = run(["systemctl", "is-active", f"wpa_supplicant@{WLAN_IF}.service"])
    if rc_svc != 0:
        run(["systemctl", "unmask", "wpa_supplicant@.service"])
        run(["systemctl", "daemon-reload"])
        run(["systemctl", "reset-failed", f"wpa_supplicant@{WLAN_IF}.service"])
        run(["systemctl", "enable", "--now", f"wpa_supplicant@{WLAN_IF}.service"])
        time.sleep(1)
        rc_svc, _ = run(["systemctl", "is-active", f"wpa_supplicant@{WLAN_IF}.service"])
        if rc_svc != 0:
            return False, "wpa_supplicant não está ativo (use o perfil Cliente Wi-Fi)."
    rc, out = run([WPA_CLI_BIN, "-i", WLAN_IF, "list_networks"])
    existing_id: str | None = None
    if rc == 0 and out:
        for line in out.splitlines():
            parts = line.split("\t")
            if len(parts) >= 2 and parts[1] == ssid:
                existing_id = parts[0]
                break
    if existing_id is None:
        rc, out = run([WPA_CLI_BIN, "-i", WLAN_IF, "add_network"])
        if rc != 0:
            return False, f"add_network falhou: {out}"
        existing_id = out.strip()
    rc1, out1 = run([WPA_CLI_BIN, "-i", WLAN_IF, "set_network", existing_id, "ssid", f'"{ssid}"'])
    if rc1 != 0:
        return False, f"set ssid falhou: {out1}"
    if psk and psk.strip():
        rc2, out2 = run([WPA_CLI_BIN, "-i", WLAN_IF, "set_network", existing_id, "psk", f'"{psk}"'])
    else:
        rc2, out2 = run([WPA_CLI_BIN, "-i", WLAN_IF, "set_network", existing_id, "key_mgmt", "NONE"])
    if rc2 != 0:
        return False, f"config segurança falhou: {out2}"
    rc3, out3 = run([WPA_CLI_BIN, "-i", WLAN_IF, "enable_network", existing_id])
    rc4, out4 = run([WPA_CLI_BIN, "-i", WLAN_IF, "select_network", existing_id])
    run([WPA_CLI_BIN, "-i", WLAN_IF, "save_config"])
    run([WPA_CLI_BIN, "-i", WLAN_IF, "reassociate"])
    if not (rc3 == 0 and rc4 == 0):
        return False, ("; ".join([out3, out4])).strip()
    deadline = time.time() + 30
    last_state = ""
    while time.time() < deadline:
        st = wpa_status()
        last_state = st.get("wpa_state", "")
        if last_state == "COMPLETED":
            break
        time.sleep(1)
    if last_state != "COMPLETED":
        return False, f"associação não completou (estado={last_state or 'desconhecido'})"
    run(["dhclient", "-r", WLAN_IF])
    rc_dh, out_dh = run(["dhclient", WLAN_IF], timeout=25)
    ip = get_ipv4_list(WLAN_IF)
    if ip == "-" or rc_dh != 0:
        return False, f"associou, mas sem IP (dhclient rc={rc_dh}) {out_dh}"
    routers, dns_servers = parse_dhclient_lease(WLAN_IF)
    if routers:
        ensure_default_via(routers[0], WLAN_IF)
    if dns_servers:
        apply_dns(dns_servers)
    return True, (f"conectado com IP {ip}; GW={routers[0] if routers else '?'}; DNS="
                  + (", ".join(dns_servers) if dns_servers else "?"))

def wifi_disconnect() -> Tuple[bool, str]:
    rc, out = run([WPA_CLI_BIN, "-i", WLAN_IF, "disconnect"])
    return (rc == 0, out)

# ========================== Serviços & PPP ==========================
def list_services() -> List[dict]:
    services: List[dict] = []
    rc, out = run(["systemctl","list-unit-files","--type=service","--no-pager","--no-legend"])
    if rc != 0 or not out:
        return services
    for line in out.splitlines():
        parts = line.split()
        if not parts:
            continue
        name = parts[0]
        state = parts[1] if len(parts) > 1 else "disabled"
        rc_active, _ = run(["systemctl", "is-active", name])
        active = (rc_active == 0)
        enabled = state.startswith("enabled")
        services.append({"name": name, "active": active, "enabled": enabled})
    services.sort(key=lambda x: x["name"])
    return services

def service_action(service: str, action: str) -> Tuple[bool, str]:
    valid = {"start","stop","restart","enable","disable"}
    if action not in valid:
        return False, f"ação inválida: {action}"
    cmd = ["systemctl", action, service] if action in {"start","stop","restart"} else ["systemctl", action, service]
    rc, out = run(cmd, timeout=20)
    return (rc == 0, out)

def parse_dhclient_lease(iface: str) -> Tuple[List[str], List[str]]:
    path = f"/var/lib/dhcp/dhclient.{iface}.leases"
    routers: List[str] = []
    dns: List[str] = []
    try:
        if os.path.exists(path):
            txt = open(path, "r", encoding="utf-8", errors="ignore").read()
            m_dns = re.findall(r"option\s+domain-name-servers\s+([^;]+);", txt)
            m_rtr = re.findall(r"option\s+routers\s+([^;]+);", txt)
            if m_dns:
                dns = [i.strip() for i in re.split(r"[,\s]+", m_dns[-1].strip()) if i.strip()]
            if m_rtr:
                routers = [i.strip() for i in re.split(r"[,\s]+", m_rtr[-1].strip()) if i.strip()]
    except Exception:
        pass
    return routers, dns

def apply_dns(nameservers: List[str]) -> Tuple[bool, str]:
    try:
        if os.path.islink("/etc/resolv.conf"):
            os.unlink("/etc/resolv.conf")
        with open("/etc/resolv.conf", "w", encoding="utf-8") as f:
            f.write("# Generated by Mirako client-wifi\n")
            for ns in nameservers:
                if ns:
                    f.write(f"nameserver {ns}\n")
        return True, "resolv.conf atualizado"
    except Exception as e:
        return False, f"erro ao escrever resolv.conf: {e}"

def is_auto_dial_enabled() -> bool:
    try:
        return os.path.exists(AUTO_DIAL_FILE)
    except Exception:
        return False

def set_auto_dial(enabled: bool) -> None:
    try:
        if enabled:
            os.makedirs(os.path.dirname(AUTO_DIAL_FILE), exist_ok=True)
            with open(AUTO_DIAL_FILE, "w") as f:
                f.write("1")
        else:
            if os.path.exists(AUTO_DIAL_FILE):
                os.remove(AUTO_DIAL_FILE)
    except Exception:
        pass

def ensure_default_via(gw: str, dev: str) -> None:
    if not gw:
        return
    run([IP_BIN, "route", "replace", "default", "via", gw, "dev", dev])

def list_interfaces(include_virtual: bool = True, include_lo: bool = True) -> List[str]:
    try:
        names = sorted(os.listdir("/sys/class/net"))
    except Exception:
        names = []
    skip_prefix = ("veth", "br-", "docker", "virbr", "vmnet", "vnet", "zt")
    out: List[str] = []
    for n in names:
        if not include_lo and n == "lo":
            continue
        if not include_virtual and n.startswith(skip_prefix):
            continue
        out.append(n)
    return out

def profile_set(profile: str) -> Tuple[int, str]:
    return run([PROFILES_SCRIPT, profile], timeout=90)

def modem_connect() -> Tuple[bool, str]:
    run(["pkill", "-x", "pppd"])
    run(["rm", "-f", "/var/lock/LCK..ttyUSB*"])
    try:
        subprocess.Popen([PPPD_BIN, "call", PPP_PEER], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
    except Exception as e:
        return False, f"erro ao iniciar pppd: {e}"
    deadline = time.time() + 20
    up = False
    while time.time() < deadline:
        rc, _ = run([IP_BIN, "link", "show", PPP_IF])
        if rc == 0:
            up = True
            break
        time.sleep(1.0)
    if up:
        return True, "pppd call enviado e ppp0 ativo"
    rc1, j1 = run(["journalctl", "-b", "-n", "50", "--no-pager"])
    last: List[str] = []
    if rc1 == 0 and j1:
        for ln in j1.splitlines():
            if ("pppd" in ln.lower()) or ("chat" in ln.lower()):
                last.append(ln)
    msg = "ppp0 não subiu. "
    if last:
        msg += "Logs recentes: " + ("\n".join(last[-8:]))
    else:
        msg += "Sem logs do pppd/chat."
    return False, msg

def modem_disconnect() -> Tuple[bool, str]:
    rc, out = run(["poff", PPP_PEER], timeout=20)
    msg = (out or "").strip()
    if rc != 0 and ("No pppd is running" in msg or "None stopped" in msg):
        return True, "pppd já estava parado"
    if rc != 0:
        run(["pkill", "-x", "pppd"])
        run(["rm", "-f", "/var/lock/LCK..ttyUSB*"])
        return True, "pppd finalizado"
    return True, msg or "poff enviado"

def get_last_profile() -> str:
    path = "/var/lib/mirako/last_profile"
    try:
        with open(path, "r", encoding="utf-8") as f:
            return f.read().strip() or "ap"
    except Exception:
        return "ap"

# ========================== Template (sem Bootstrap) ==========================
TEMPLATE = """
<!doctype html>
<html lang="pt-br">
<head>
<meta charset="utf-8">
<title>Mirako — Orange Pi Router</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  :root{
    --bg:#0b0d10; --panel:#12161b; --muted:#9aa4b2; --text:#e6e6e6; --acc:#25a0ff;
    --ok:#2ea043; --ok-b:#1f4726;
    --warn:#e0b84f; --warn-b:#4a3f1d;
    --pri:#2563eb; --pri-b:#1e3a8a;
    --danger:#ef4444; --danger-b:#7f1d1d;
    --line:#1e252d;
  }
  *{box-sizing:border-box}
  html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif}
  a{color:var(--acc);text-decoration:none} a:hover{text-decoration:underline}
  .wrap{max-width:1200px;margin:0 auto;padding:16px}
  .topbar{display:flex;justify-content:space-between;align-items:center;padding:12px 16px;background:#0f141a;border:1px solid var(--line);border-radius:8px;margin-bottom:16px}
  .brand{font-weight:600}
  .grid{display:grid;grid-template-columns:1fr;gap:12px}
  @media(min-width:992px){.grid-2{grid-template-columns:1fr 1fr}.grid-3{grid-template-columns:1fr 1fr 1fr}}
  .card{background:var(--panel);border:1px solid var(--line);border-radius:8px}
  .card .hd{padding:10px 12px;border-bottom:1px solid var(--line);font-weight:600}
  .card .bd{padding:12px}
  .muted{color:var(--muted)}
  .row{display:grid;grid-template-columns:repeat(12,1fr);gap:8px}
  .col-3{grid-column:span 3}.col-4{grid-column:span 4}.col-6{grid-column:span 6}.col-12{grid-column:span 12}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,'Liberation Mono',monospace}
  /* ===== Botões com cores destacadas ===== */
  .btn{
    display:inline-block;padding:8px 12px;border:1px solid var(--line);border-radius:6px;
    background:#16212c;color:var(--text);cursor:pointer;transition:all .12s ease-in-out;
    box-shadow:0 0 0 0 rgba(0,0,0,0);
  }
  .btn:hover{filter:brightness(1.07);transform:translateY(-1px);box-shadow:0 6px 14px -8px rgba(0,0,0,.6)}
  .btn:active{transform:translateY(0);box-shadow:none}
  .btn.small{padding:5px 8px;font-size:0.9em}

  .btn.ok{background:linear-gradient(180deg, var(--ok), #238636);border-color:var(--ok-b)}
  .btn.ok:hover{filter:brightness(1.03)}
  .btn.warn{background:linear-gradient(180deg, var(--warn), #b5892e);border-color:var(--warn-b);color:#1b1407}
  .btn.warn:hover{filter:brightness(1.03)}
  .btn.primary{background:linear-gradient(180deg, var(--pri), #1d4ed8);border-color:var(--pri-b)}
  .btn.primary:hover{filter:brightness(1.03)}
  .btn.danger{background:linear-gradient(180deg, var(--danger), #b91c1c);border-color:var(--danger-b)}
  .btn.danger:hover{filter:brightness(1.03)}
  .btn.outline{background:transparent;border-color:var(--line)}
  .btn.group .btn{margin-right:6px}

  .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#10151b;border:1px solid var(--line);font-size:.85em}
  .okpill{background:#102216;border-color:#194d2b}
  .warnpill{background:#241f10;border-color:#4a3f1d}

  .table{width:100%;border-collapse:collapse}
  .table th,.table td{border-bottom:1px solid var(--line);padding:8px;vertical-align:middle}
  .table th{text-align:left;color:var(--muted);font-weight:600}
  .table tr:hover{background:#131a22}

  input[type=text],input[type=password],input[type=file]{width:100%;padding:8px;border:1px solid var(--line);border-radius:6px;background:#0e141a;color:var(--text)}
  .input-row{display:flex;gap:8px;align-items:center}
  .switch{display:flex;align-items:center;gap:8px}
  .logbox{background:#0b0d10;border:1px solid var(--line);border-radius:.5rem;padding:.5rem;height:50vh;overflow:auto;color:#d6d6d6}
  pre{white-space:pre-wrap;word-wrap:break-word;margin:0}
  .ssid-row{cursor:pointer}
  .flash{padding:10px 12px;border:1px solid var(--line);border-radius:8px;background:#0f141a;margin-bottom:10px}
  .gap{height:16px}
  .hidden{display:none}

</style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">Mirako Router</div>
      <div class="muted">Orange Pi — Debian</div>
    </div>

    {% with messages = get_flashed_messages() %}
      {% if messages %}
        {% for msg in messages %}
          <div class="flash">{{ msg }}</div>
        {% endfor %}
      {% endif %}
    {% endwith %}

    <div class="grid grid-3">
      <!-- Perfis -->
      <div class="card">
        <div class="hd">Perfis (atual: {{ last_profile }})</div>
        <div class="bd">
          <form method="post" action="{{ url_for('setprofile') }}">
            <div class="grid">
              <button class="btn primary" name="profile" value="ap">Roteador AP (WAN={{LAN_IF}} → AP em {{WLAN_IF}})</button>
              <button class="btn primary" name="profile" value="3g">Roteador 3G PPP (WAN={{PPP_IF}} → AP/LAN)</button>
              <button class="btn primary" name="profile" value="client-wifi">Cliente Wi-Fi (WAN={{WLAN_IF}} → LAN {{LAN_IF}})</button>
              <button class="btn outline" name="profile" value="client-lan">Cliente LAN (WAN={{LAN_IF}}; Wi-Fi liberado p/ scan)</button>
            </div>
          </form>
        </div>
      </div>


      <!-- Sistema -->
      <div class="card" style="grid-column:span 2;">
        <div class="hd">Sistema</div>
        <div class="bd">
          <div class="row">
            <div class="col-3"><div class="muted">Temp CPU</div><div class="mono" id="sys_temp">{{ cpu_temp }}</div></div>
            <div class="col-3"><div class="muted">Uso CPU</div><div class="mono" id="sys_cpu">{{ cpu_pct }}%</div></div>
            <div class="col-3"><div class="muted">Memória</div><div class="mono" id="sys_mem">{{ mem_used }} / {{ mem_total }} ({{ mem_pct }}%)</div></div>
            <div class="col-3"><div class="muted">Disco (/)</div><div class="mono" id="sys_disk">{{ disk_used }} / {{ disk_total }} ({{ disk_pct }}%)</div></div>
          </div>
        </div>
      </div>
    </div>
    
      <!-- Wi-Fi -->
      <div class="card" style="grid-column:span 2;">
        <div class="hd" style="display:flex;justify-content:space-between;align-items:center;">
          <span>Wi-Fi ({{WLAN_IF}})</span>
          <form method="post" action="{{ url_for('wifi_scan_route') }}">
            <button class="btn small outline">Escanear redes</button>
          </form>
        </div>
        <div class="bd">
          <div class="row">
            <div class="col-4">
              <div class="muted">Modo / Estado</div>
              <div id="wf_mode_state">{{ wifi.mode }} / {{ wifi.state }}</div>
            </div>
            <div class="col-4">
              <div class="muted">SSID / BSSID</div>
              <div class="mono" id="wf_ssid_bssid">{{ wifi.ssid }} | {{ wifi.bssid }}</div>
            </div>
            <div class="col-4">
              <div class="muted">Canal / Freq / TX pwr</div>
              <div id="wf_chan_freq_txp">{{ wifi.channel }} / {{ wifi.freq_mhz }} / {{ wifi.txpower }}</div>
            </div>
            <div class="col-3"><div class="muted">RSSI</div><div id="wf_rssi">{{ wifi.rssi }}</div></div>
            <div class="col-3"><div class="muted">Distância (est.)</div><div id="wf_dist">{{ wifi.distance_m }}</div></div>
            <div class="col-3"><div class="muted">Bitrate TX / RX</div><div id="wf_rates">{{ wifi.tx_bitrate }} / {{ wifi.rx_bitrate }}</div></div>
            <div class="col-3"><div class="muted">Clientes (se AP)</div><div id="wf_clients">{{ wifi.clients }}</div></div>
            <div class="col-6"><div class="muted">Tráfego (bytes)</div><div id="wf_bytes">TX: {{ wifi.tx_bytes }} — RX: {{ wifi.rx_bytes }}</div></div>
            <div class="col-6"><div class="muted">Taxa instantânea</div><div id="wf_bps">TX: {{ wifi.tx_bps }} — RX: {{ wifi.rx_bps }}</div></div>
          </div>
          <div class="gap"></div>
          <form class="grid" method="post" action="{{ url_for('wifi_connect_route') }}">
            <label>SSID<input type="text" name="ssid" id="ssidField" required></label>
            <label>Senha (vazio = aberta)<input type="password" name="psk" id="pskField" autocomplete="off"></label>
            <div class="switch">
              <input type="checkbox" id="showPass" onchange="togglePass()">
              <label for="showPass" class="muted">Mostrar senha</label>
            </div>
            <button class="btn ok">Conectar</button>
          </form>
          <div class="gap"></div>
          <form method="post" action="{{ url_for('wifi_disconnect_route') }}">
            <button class="btn warn">Desconectar Wi-Fi</button>
          </form>

          {% if wpa_file_networks and wpa_file_networks|length > 0 %}
          <div class="gap"></div>
          <div class="muted">Redes do wpa_supplicant</div>
          <table class="table">
            <thead><tr><th>SSID</th><th>Auth</th><th>Key mgmt</th><th>Priority</th></tr></thead>
            <tbody>
            {% for n in wpa_file_networks %}
              <tr class="ssid-row" data-ssid="{{ n.ssid|e }}" onclick="document.getElementById('ssidField').value=this.dataset.ssid;">
                <td class="mono">{{ n.ssid }}</td>
                <td>{{ n.psk }}</td>
                <td>{{ n.key_mgmt }}</td>
                <td class="mono">{{ n.priority }}</td>
              </tr>
            {% endfor %}
            </tbody>
          </table>
          {% endif %}

          {% if saved_networks and saved_networks|length > 0 %}
          <div class="gap"></div>
          <div class="muted">Redes salvas (wpa_cli)</div>
          <table class="table">
            <thead><tr><th>ID</th><th>SSID</th><th>Flags</th></tr></thead>
            <tbody>
            {% for n in saved_networks %}
              <tr>
                <td class="mono">{{ n.id }}</td>
                <td class="mono">{{ n.ssid }}</td>
                <td>{{ n.flags }}</td>
              </tr>
            {% endfor %}
            </tbody>
          </table>
          {% endif %}

          {% if scan %}
          <div class="gap"></div>
          <table class="table">
            <thead><tr><th>SSID</th><th>Signal</th><th>Freq</th><th>Segurança</th></tr></thead>
            <tbody>
            {% for n in scan %}
              <tr class="ssid-row" data-ssid="{{ n.ssid|e }}" onclick="document.getElementById('ssidField').value=this.dataset.ssid;">
                <td class="mono">{{ n.ssid }}</td><td>{{ n.signal }}</td><td>{{ n.freq }}</td><td>{{ n.security }}</td>
              </tr>
            {% endfor %}
            </tbody>
          </table>
          {% elif scan_dbg %}
            <div class="muted"><small>{{ scan_dbg }}</small></div>
          {% endif %}
        </div>
      </div>

      <!-- Modem -->
      <div class="card">
        <div class="hd">Modem 3G/PPP ({{PPP_IF}})</div>
        <div class="bd">
          <div class="grid">
            <form method="post" action="{{ url_for('modem_connect_route') }}"><button class="btn ok">Conectar modem (pppd call {{PPP_PEER}})</button></form>
            <form method="post" action="{{ url_for('modem_disconnect_route') }}"><button class="btn warn">Desconectar modem (poff {{PPP_PEER}})</button></form>
            <form method="post" action="{{ url_for('modem_auto_dial_route') }}">
              <div class="switch">
                <input type="checkbox" id="autoDialToggle" name="auto_dial" value="1" {% if auto_dial_enabled %}checked{% endif %} onchange="this.form.submit()">
                <label for="autoDialToggle">Discagem automática (3G)</label>
              </div>
            </form>
          </div>
          <div class="gap"></div>
          <div class="muted">IPv4 ({{PPP_IF}})</div>
          <pre class="mono" id="ppp_ipv4">{{ ppp_ipv4 }}</pre>
        </div>
      </div>



    <!-- Tabelas de rede, rotas, DNS, DHCP, serviços -->
    <div class="gap"></div>
    <div class="grid">
      <div class="card">
        <div class="hd">Rede (estatísticas por interface)</div>
        <div class="bd">
          <table class="table" id="if_table">
            <thead><tr><th>Interface</th><th>Estado</th><th>IPv4</th><th>RX</th><th>TX</th></tr></thead>
            <tbody>
              {% for n in netlist %}
              <tr><td class="mono">{{ n.dev }}</td><td>{{ n.state }}</td><td class="mono">{{ n.ipv4 }}</td><td>{{ n.rx }}</td><td>{{ n.tx }}</td></tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
      </div>

<div class="card">
  <div class="hd">Rotas & DNS & DHCP</div>
  <div class="bd">
    <div class="row">
      <!-- COLUNA ESQUERDA: Rota padrão, Rotas e abaixo DHCP Leases -->
      <div class="col-8">
        <div class="muted">Rota padrão</div>
        <pre class="mono" id="def_route">{{ def_route }}</pre>

        <div class="muted">Rotas</div>
        <pre class="mono" id="all_routes">{{ all_routes }}</pre>

        <div class="muted">DHCP Leases{% if leases_path %} ({{ leases_path }}){% endif %}</div>
        {% if leases and leases|length>0 %}
        <table class="table" id="leases_table">
          <thead><tr><th>IP</th><th>Host</th><th>MAC</th><th>Expira</th></tr></thead>
          <tbody>
          {% for L in leases %}
            <tr>
              <td class="mono">{{ L.ip }}</td>
              <td class="mono">{{ L.hostname or "-" }}</td>
              <td class="mono">{{ L.mac }}</td>
              <td class="mono">{{ L.expiry }}</td>
            </tr>
          {% endfor %}
          </tbody>
        </table>
        {% else %}
        <pre class="mono" id="leases_empty">Sem leases ou arquivo não encontrado.</pre>
        {% endif %}
      </div>

      <!-- COLUNA DIREITA: DNS -->
      <div class="col-4">
        <div class="muted">DNS</div>
        <pre class="mono" id="dns_info">{{ dns }}</pre>
      </div>
    </div>
  </div>
</div>


<div class="card">


        <div class="hd">Serviços</div>
                <button id="toggle_services_btn" class="btn small outline" type="button" onclick="toggleServices()">Ver serviços</button>
        <div class="card hidden" id="services_card">
          <table class="table" id="svc_table">
            <thead><tr><th>Serviço</th><th>Status</th><th>Enabled</th><th>Ações</th></tr></thead>
            <tbody>
              {% for s in services %}
              <tr>
                <td class="mono">{{ s.name }}</td>
                <td><span class="pill {{ 'okpill' if s.active else '' }}">{{ 'ativo' if s.active else 'inativo' }}</span></td>
                <td><span class="pill {{ 'okpill' if s.enabled else '' }}">{{ 'habilitado' if s.enabled else 'desabilitado' }}</span></td>
                <td>
                  <form method="post" action="{{ url_for('svc_action_route') }}">
                    <input type="hidden" name="svc" value="{{ s.name }}">
                    <div class="btn group">
                      <button class="btn small ok" name="action" value="start">Start</button>
                      <button class="btn small warn" name="action" value="stop">Stop</button>
                      <button class="btn small primary" name="action" value="restart">Restart</button>
                      {% if s.enabled %}
                      <button class="btn small outline" name="action" value="disable">Disable</button>
                      {% else %}
                      <button class="btn small primary" name="action" value="enable">Enable</button>
                      {% endif %}
                    </div>
                  </form>
                </td>
              </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
      </div>
    </div>



    <!-- Gerenciador de Arquivos -->
    <div class="gap"></div>
    <div class="card">
      <div class="hd">Gerenciador de Arquivos (diretório /root)</div>
      <div class="bd">
        <form method="post" enctype="multipart/form-data" action="{{ url_for('file_upload_route') }}">
          <div class="input-row">
            <input type="file" name="file" required>
            <button class="btn primary">Enviar</button>
          </div>
        </form>

        {% if root_files and root_files|length > 0 %}
        <div class="gap"></div>
        <div class="muted">Arquivos em /root (clique para baixar)</div>
        <table class="table">
          <tbody>
            {% for f in root_files %}
            <tr>
              <td>
                <a href="{{ url_for('file_download', filename=f) }}" class="mono">{{ f }}</a>
              </td>
            </tr>
            {% endfor %}
          </tbody>
        </table>
        {% endif %}
      </div>
    </div>

    <!-- Terminal ao vivo -->
    <div class="gap"></div>
    <div class="card" id="terminal_card">
      <div class="hd" style="display:flex;justify-content:space-between;align-items:center;">
        <span>Terminal ao vivo</span>
        <div>
          <button type="button" class="btn small outline" onclick="prefill('dmesg -wT')">dmesg</button>
          <button type="button" class="btn small outline" onclick="prefill('top -b')">top</button>
          <button type="button" class="btn small outline" onclick="prefill('tcpdump -i {{WLAN_IF}} -n -vv -s 120')">tcpdump ({{WLAN_IF}})</button>
          <button type="button" class="btn small warn" onclick="stopCmd()">Ctrl+C</button>
          <button type="button" class="btn small outline" onclick="clearLog()">Limpar</button>
          <button type="button" class="btn small danger" onclick="rebootConfirm()">Reiniciar</button>
        </div>
      </div>
      <div class="bd">
        <div id="terminal_wrap" class="logbox"><pre id="terminal_out" class="mono"></pre></div>
        <div class="gap"></div>
        <div class="input-row">
          <span class="mono muted">$</span>
          <input id="terminal_cmd" placeholder="Digite um comando e pressione Enter">
          <button class="btn ok" type="button" id="terminal_run_btn" title="Executar (Enter)">Enter</button>
        </div>
        <div class="muted">Dica: use <span class="mono">top</span> — o backend usa modo batch automaticamente.</div>
      </div>
    </div>
  </div>

<script>
function togglePass(){
  var ps = document.getElementById('pskField');
  if(ps){ ps.type = (ps.type === 'password') ? 'text' : 'password'; }
}

/* ===== Atualização de STATUS a cada 15s ===== */
async function fetchStatus(){
  try{
    const r = await fetch('/status.json?ts=' + Date.now());
    if(!r.ok) return;
    const j = await r.json();

    setText('wf_mode_state', j.wifi.mode+' / '+j.wifi.state);
    setText('wf_ssid_bssid', j.wifi.ssid+' | '+j.wifi.bssid);
    setText('wf_chan_freq_txp', j.wifi.channel+' / '+j.wifi.freq_mhz+' / '+j.wifi.txpower);
    setText('wf_rssi', j.wifi.rssi);
    setText('wf_dist', j.wifi.distance_m);
    setText('wf_rates', j.wifi.tx_bitrate+' / '+j.wifi.rx_bitrate);
    setText('wf_clients', j.wifi.clients);
    setText('wf_bytes', 'TX: '+j.wifi.tx_bytes+' — RX: '+j.wifi.rx_bytes);
    setText('wf_bps', 'TX: '+j.wifi.tx_bps+' — RX: '+j.wifi.rx_bps);

    setText('sys_temp', j.cpu_temp);
    setText('sys_cpu', j.cpu_pct+'%');
    setText('sys_mem', j.mem.used+' / '+j.mem.total+' ('+j.mem.pct+'%)');
    setText('sys_disk', j.disk.used+' / '+j.disk.total+' ('+j.disk.pct+'%)');

    const iftbody = document.querySelector('#if_table tbody');
    if (iftbody){
      iftbody.innerHTML = '';
      j.netlist.forEach(n=>{
        const tr = document.createElement('tr');
        tr.innerHTML = '<td class="mono">'+n.dev+'</td><td>'+n.state+'</td><td class="mono">'+n.ipv4+'</td><td>'+n.rx+'</td><td>'+n.tx+'</td>';
        iftbody.appendChild(tr);
      });
    }

    setText('def_route', j.def_route);
    setText('all_routes', j.all_routes);
    setText('dns_info', j.dns);

    const leasesBody = document.querySelector('#leases_table tbody');
    const leasesEmpty = document.getElementById('leases_empty');
    if (j.leases && j.leases.length && leasesBody){
      if(leasesEmpty) leasesEmpty.style.display = 'none';
      leasesBody.innerHTML = '';
      j.leases.forEach(L=>{
        const tr = document.createElement('tr');
        tr.innerHTML = '<td class="mono">'+L.ip+'</td><td class="mono">'+(L.hostname||'-')+'</td><td class="mono">'+L.mac+'</td><td class="mono">'+L.expiry+'</td>';
        leasesBody.appendChild(tr);
      });
    }

    setText('ppp_ipv4', j.ppp_ipv4);

    const svtbody = document.querySelector('#svc_table tbody');
    if (svtbody){
      svtbody.innerHTML = '';
      j.services.forEach(s=>{
        const pillA = s.active ? 'okpill' : '';
        const pillE = s.enabled ? 'okpill' : '';
        const tr = document.createElement('tr');
        tr.innerHTML =
          '<td class="mono">'+s.name+'</td>'+
          '<td><span class="pill '+pillA+'">'+(s.active?'ativo':'inativo')+'</span></td>'+
          '<td><span class="pill '+pillE+'">'+(s.enabled?'habilitado':'desabilitado')+'</span></td>'+
          '<td>'+
            '<form method="post" action="/svc_action">'+
            '<input type="hidden" name="svc" value="'+s.name+'">'+
            '<div class="btn group">'+
              '<button class="btn small ok" name="action" value="start">Start</button>'+
              '<button class="btn small warn" name="action" value="stop">Stop</button>'+
              '<button class="btn small primary" name="action" value="restart">Restart</button>'+
              (s.enabled
                ? '<button class="btn small outline" name="action" value="disable">Disable</button>'
                : '<button class="btn small primary" name="action" value="enable">Enable</button>')+
            '</div>'+
            '</form>'+
          '</td>';
        svtbody.appendChild(tr);
      });
    }

  }catch(e){ /* silencioso */ }
}
function setText(id, txt){ var el=document.getElementById(id); if(el){ el.textContent = (txt!=null? String(txt): ''); } }
setInterval(fetchStatus, 15000); // 15s
fetchStatus();

/* ===== Terminal ===== */
function ansiToHtml(text){
  text = text.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
  const colors={30:'color:#777;',31:'color:#ff6b6b;',32:'color:#9be564;',33:'color:#ffd166;',34:'color:#6ab0ff;',35:'color:#d785ff;',36:'color:#74d3ea;',37:'color:#eeeeee;',90:'color:#999;',91:'color:#ff7b7b;',92:'color:#a8f07a;',93:'color:#ffe07a;',94:'color:#7abaff;',95:'color:#e19bff;',96:'color:#85e9ff;',97:'color:#ffffff;'};
  const bg={40:'background:#222;',41:'background:#5c1e1e;',42:'background:#294025;',43:'background:#4a3f1d;',44:'background:#1c2e4a;',45:'background:#3a2143;',46:'background:#1f3f45;',47:'background:#444;',100:'background:#333;',101:'background:#6b2a2a;',102:'background:#35552e;',103:'background:#5a4d24;',104:'background:#253c66;',105:'background:#4a2d54;',106:'background:#28545b;',107:'background:#666;'};
  return text.replace(/\x1b\[(\d+(?:;\d+)*)m/g,function(m,seq){
    const codes = seq.split(';').map(Number);
    if(codes.includes(0)) return '</span>';
    let style='';
    codes.forEach(function(c){
      if(c===1) style+='font-weight:bold;';
      else if(c===3) style+='font-style:italic;';
      else if(c===4) style+='text-decoration:underline;';
      else if(colors[c]) style+=colors[c];
      else if(bg[c]) style+=bg[c];
      else if(c===39) style+='color:inherit;';
      else if(c===49) style+='background:transparent;';
    });
    return '<span style="'+style+'">';
  });
}
let polling=null, didInitialScroll=false, userScrolledUp=false;
function prefill(cmd){
  const el=document.getElementById('terminal_cmd');
  if(el){ el.value=cmd; el.focus(); }
  const anchor=document.getElementById('terminal_card')||el;
  if(anchor) anchor.scrollIntoView({behavior:'smooth',block:'center'});
}
async function pullLog(){
  try{
    const r=await fetch('/shell/log?ts='+Date.now());
    const txt=await r.text();
    const out=document.getElementById('terminal_out');
    const wrap=document.getElementById('terminal_wrap');
    if(out&&wrap){
      const atBottom=(wrap.scrollTop + wrap.clientHeight) >= (wrap.scrollHeight - 10);
      out.innerHTML = ansiToHtml(txt);
      if(!didInitialScroll){ wrap.scrollTop=wrap.scrollHeight; didInitialScroll=true; }
      else if(atBottom && !userScrolledUp){ wrap.scrollTop=wrap.scrollHeight; }
    }
  }catch(e){}
}
function startPolling(){
  if(polling) clearInterval(polling);
  pullLog();
  polling=setInterval(pullLog, 900);
}
(function(){
  const wrap=document.getElementById('terminal_wrap');
  if(!wrap) return;
  wrap.addEventListener('scroll', function(){
    const nearBottom=(wrap.scrollTop + wrap.clientHeight) >= (wrap.scrollHeight - 10);
    userScrolledUp=!nearBottom;
  });
})();
async function runCmdFromInput(){
  const el=document.getElementById('terminal_cmd');
  const cmd=(el && el.value)?el.value.trim():'';
  if(!cmd) return;
  await fetch('/shell/run',{method:'POST',headers:{'Content-Type':'application/x-www-form-urlencoded'},body:new URLSearchParams({cmd:cmd})});
  didInitialScroll=false; userScrolledUp=false; startPolling();
}
async function stopCmd(){ await fetch('/shell/stop',{method:'POST'}); }
async function clearLog(){ await fetch('/shell/clear',{method:'POST'}); const out=document.getElementById('terminal_out'); if(out) out.innerHTML=''; didInitialScroll=false; userScrolledUp=false; }
async function rebootConfirm(){ if(!confirm('Reiniciar agora?')) return; await fetch('/reboot',{method:'POST'}); alert('Reiniciando...'); }
(function(){
  const el=document.getElementById('terminal_cmd'); if(el){ el.addEventListener('keydown', function(ev){ if(ev.key==='Enter'){ ev.preventDefault(); runCmdFromInput(); } }); }
  const btn=document.getElementById('terminal_run_btn'); if(btn){ btn.addEventListener('click', function(ev){ ev.preventDefault(); runCmdFromInput(); }); }
})();
startPolling();
</script>

<script>
// ---- Mostrar/Ocultar Serviços ----
function toggleServices(){
  const card = document.getElementById('services_card');
  const btn  = document.getElementById('toggle_services_btn');
  if(!card || !btn) return;
  const hidden = card.classList.toggle('hidden');
  btn.textContent = hidden ? 'Ver serviços' : 'Ocultar serviços';
  try { localStorage.setItem('svc_hidden', hidden ? '1' : '0'); } catch(e){}
}

// Aplica estado salvo ao carregar a página
(function(){
  const card = document.getElementById('services_card');
  const btn  = document.getElementById('toggle_services_btn');
  if(!card || !btn) return;
  let hidden = false;
  try { hidden = (localStorage.getItem('svc_hidden') === '1'); } catch(e){}
  if(hidden) card.classList.add('hidden'); else card.classList.remove('hidden');
  btn.textContent = hidden ? 'Ver serviços' : 'Ocultar serviços';
})();
</script>


</body>
</html>
"""

# ========================== Rotas ==========================
def list_root_files() -> List[str]:
    try:
        return [f for f in os.listdir("/root") if not f.startswith(".")]
    except Exception:
        return []

@app.route("/", methods=["GET"])
def index() -> Any:
    t = cpu_temp_c()
    cpu_pct = round(cpu_usage_pct(), 1)
    mem = mem_stats()
    disk = disk_stats("/")
    netlist = [net_stats_for(i) for i in list_interfaces(include_virtual=True, include_lo=True)]
    leases, _, leases_path = read_dnsmasq_leases()
    context = dict(
        WLAN_IF=WLAN_IF, LAN_IF=LAN_IF, PPP_IF=PPP_IF, PPP_PEER=PPP_PEER,
        scan=[], scan_dbg=None,
        wifi=wifi_status_details(),
        wlan_ipv4=get_ipv4_list(WLAN_IF),
        ppp_ipv4=get_ipv4_list(PPP_IF),
        def_route=default_route(),
        all_routes=routes(),
        dns=dns_info(),
        leases=leases, leases_path=leases_path,
        cpu_temp=(f"{t:.1f} °C" if t is not None else "-"),
        cpu_pct=cpu_pct,
        mem_used=human_bytes(mem["used"]),
        mem_total=human_bytes(mem["total"]),
        mem_pct=f"{mem['pct']:.1f}",
        disk_total=human_bytes(disk["total"]),
        disk_used=human_bytes(disk["used"]),
        disk_pct=f"{disk['pct']:.1f}",
        procs=processes_top(20),
        netlist=netlist,
        services=list_services(),
        last_profile=get_last_profile(),
        saved_networks=get_saved_networks(),
        wpa_file_networks=read_wpa_conf_networks(),
        root_files=list_root_files(),
        auto_dial_enabled=is_auto_dial_enabled(),
    )
    return render_template_string(TEMPLATE, **context)

@app.post("/wifi/scan")
def wifi_scan_route():
    nets, dbg = wifi_scan()
    t = cpu_temp_c()
    cpu_pct = round(cpu_usage_pct(), 1)
    mem = mem_stats()
    disk = disk_stats("/")
    netlist = [net_stats_for(i) for i in list_interfaces(include_virtual=True, include_lo=True)]
    leases, _, leases_path = read_dnsmasq_leases()
    context = dict(
        WLAN_IF=WLAN_IF, LAN_IF=LAN_IF, PPP_IF=PPP_IF, PPP_PEER=PPP_PEER,
        scan=nets, scan_dbg=dbg,
        wifi=wifi_status_details(),
        wlan_ipv4=get_ipv4_list(WLAN_IF),
        ppp_ipv4=get_ipv4_list(PPP_IF),
        def_route=default_route(),
        all_routes=routes(),
        dns=dns_info(),
        leases=leases, leases_path=leases_path,
        cpu_temp=(f"{t:.1f} °C" if t is not None else "-"),
        cpu_pct=cpu_pct,
        mem_used=human_bytes(mem["used"]),
        mem_total=human_bytes(mem["total"]),
        mem_pct=f"{mem['pct']:.1f}",
        disk_total=human_bytes(disk["total"]),
        disk_used=human_bytes(disk["used"]),
        disk_pct=f"{disk['pct']:.1f}",
        procs=processes_top(20),
        netlist=netlist,
        services=list_services(),
        last_profile=get_last_profile(),
        auto_dial_enabled=is_auto_dial_enabled(),
        saved_networks=get_saved_networks(),
        wpa_file_networks=read_wpa_conf_networks(),
        root_files=list_root_files(),
    )
    return render_template_string(TEMPLATE, **context)

@app.post("/wifi/connect")
def wifi_connect_route():
    ssid = (request.form.get("ssid") or "").strip()
    psk = (request.form.get("psk") or "").strip()
    if not ssid:
        flash("Informe um SSID.")
        return redirect(url_for("index"))
    ok, msg = wifi_connect(ssid, psk if psk else None)
    flash(("Conectado" if ok else "Falha") + f" ({msg})")
    return redirect(url_for("index"))

@app.post("/wifi/disconnect")
def wifi_disconnect_route():
    ok, msg = wifi_disconnect()
    flash(("Desconectado" if ok else "Falha") + f" ({msg})")
    return redirect(url_for("index"))

@app.post("/setprofile")
def setprofile():
    profile = request.form.get("profile", "").strip()
    rc, out = profile_set(profile)
    try:
        os.makedirs("/var/lib/mirako", exist_ok=True)
        with open("/var/lib/mirako/last_profile", "w", encoding="utf-8") as f:
            f.write(profile.strip() or "ap")
            f.flush()
            os.fsync(f.fileno())
            os.sync()
    except Exception:
        pass
    flash(out if out else ("ok" if rc == 0 else "erro"))
    return redirect(url_for("index"))

@app.post("/modem/connect")
def modem_connect_route():
    ok, msg = modem_connect()
    flash(("pon enviado" if ok else "Falha") + f" ({msg})")
    return redirect(url_for("index"))

@app.post("/modem/disconnect")
def modem_disconnect_route():
    ok, msg = modem_disconnect()
    flash(("poff enviado" if ok else "Falha") + f" ({msg})")
    return redirect(url_for("index"))

@app.post("/modem/auto_dial")
def modem_auto_dial_route():
    val = (request.form.get("auto_dial") or "").strip()
    enabled = val == "1"
    set_auto_dial(enabled)
    flash("Discagem automática " + ("habilitada" if enabled else "desabilitada"))
    return redirect(url_for("index"))

@app.post("/file/upload")
def file_upload_route():
    uploaded = request.files.get("file")
    if uploaded and uploaded.filename:
        filename = os.path.basename(uploaded.filename)
        save_path = os.path.join("/root", filename)
        try:
            uploaded.save(save_path)
            flash(f"Arquivo '{filename}' enviado para /root")
        except Exception as e:
            flash(f"Erro ao salvar arquivo: {e}")
    else:
        flash("Nenhum arquivo selecionado.")
    return redirect(url_for("index"))

# ===== Download seguro de /root =====
@app.get("/file/download/<path:filename>")
def file_download(filename):
    fn = os.path.basename(filename)
    if not fn or fn.startswith("."):
        abort(404)
    path = os.path.join("/root", fn)
    if not os.path.isfile(path):
        abort(404)
    return send_from_directory("/root", fn, as_attachment=True, download_name=fn)

@app.post("/svc_action")
def svc_action_route():
    svc = (request.form.get("svc") or "").strip()
    action = (request.form.get("action") or "").strip()
    if not svc or not action:
        flash("Ação ou serviço inválido.")
        return redirect(url_for("index"))
    ok, msg = service_action(svc, action)
    flash(("Sucesso" if ok else "Falha") + f" ({msg})")
    return redirect(url_for("index"))

# --------- Terminal ---------
@app.post("/shell/run")
def shell_run_route():
    cmd = (
        request.form.get("cmd")
        or (request.json.get("cmd") if request.is_json else "")
        or ""
    ).strip()
    if not cmd:
        return {"ok": False, "err": "comando vazio"}, 400
    start_command(cmd)
    return {"ok": True}

@app.get("/shell/log")
def shell_log_route():
    data = read_log_tail()
    return app.response_class(data, mimetype="text/plain; charset=utf-8")

@app.post("/shell/stop")
def shell_stop_route():
    stop_command()
    return {"ok": True}

@app.post("/shell/clear")
def shell_clear_route():
    clear_log()
    return {"ok": True}

@app.post("/reboot")
def shell_reboot_route():
    try:
        subprocess.Popen(["/sbin/shutdown", "-r,", "now"])
    except Exception:
        try:
            subprocess.Popen(["/sbin/reboot"])
        except Exception as e:
            return {"ok": False, "err": str(e)}, 500
    return {"ok": True}

# --------- STATUS JSON (para atualização a cada 15s) ---------
@app.get("/status.json")
def status_json():
    t = cpu_temp_c()
    mem = mem_stats()
    disk = disk_stats("/")
    leases, _, _ = read_dnsmasq_leases()
    payload = dict(
        wifi=wifi_status_details(),
        cpu_temp=(f"{t:.1f} °C" if t is not None else "-"),
        cpu_pct=round(cpu_usage_pct(), 1),
        mem=dict(
            total=human_bytes(mem["total"]),
            used=human_bytes(mem["used"]),
            pct=f"{mem['pct']:.1f}",
        ),
        disk=dict(
            total=human_bytes(disk["total"]),
            used=human_bytes(disk["used"]),
            pct=f"{disk['pct']:.1f}",
        ),
        netlist=[net_stats_for(i) for i in list_interfaces(include_virtual=True, include_lo=True)],
        def_route=default_route(),
        all_routes=routes(),
        dns=dns_info(),
        leases=leases,
        ppp_ipv4=get_ipv4_list(PPP_IF),
        services=list_services(),
    )
    return jsonify(payload)

# --------- Entrypoint ---------
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=80)
EOF

sudo systemctl restart mirako-web














sudo tee /etc/systemd/system/mirako-web.service >/dev/null <<'EOF'
[Unit]
Description=Interface web de configuração do roteador
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
User=root
Group=root
WorkingDirectory=/opt/mirako_web
Environment=PYTHONUNBUFFERED=1
ExecStart=/usr/bin/python3 /opt/mirako_web/web_config.py
Restart=on-failure

[Install]
WantedBy=multi-user.target
EOF


sudo systemctl daemon-reload
sudo systemctl enable --now mirako-web.service


sudo systemctl restart mirako-web












sudo tee /etc/systemd/system/mirako-profile.service >/dev/null <<'UNIT'
[Unit]
Description=Aplicar perfil Mirako na inicialização (auto-seletor)
After=local-fs.target systemd-udev-settle.service network-online.target
Wants=network-online.target
# As diretivas StartLimit* pertencem a [Unit]
StartLimitIntervalSec=0
StartLimitBurst=0

[Service]
Type=oneshot
Environment=PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
Environment=WLAN_IF=wlan0
Environment=LAN_IF=end0
Environment=PPP_IF=ppp0
Environment=PPP_PEER=3g
Environment=PROFILES_SCRIPT=/usr/local/bin/profiles.sh
ExecStartPre=/bin/udevadm settle -t 20
ExecStart=/bin/bash -lc '/usr/local/bin/mirako-autoboot.sh'
Restart=on-failure
RestartSec=7s
TimeoutStartSec=180
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target

UNIT

sudo systemctl daemon-reload
sudo systemctl enable --now mirako-profile.service
sudo systemctl restart mirako-profile.service

sudo systemctl unmask hostapd dnsmasq













sudo tee /usr/local/bin/mirako-ppp-keepalive.sh >/dev/null <<'EOF'
#!/usr/bin/env bash
set -Eeuo pipefail

# PPP keep‑alive daemon.
# Monitors PPP interface connectivity and re-applies the 3G profile if the
# connection drops. This script is intended to run continuously under
# mirako-ppp-keepalive.service.

PROFILE_FILE=/var/lib/mirako/last_profile
PROFILES_SCRIPT=${PROFILES_SCRIPT:-/usr/local/bin/profiles.sh}
PPP_IF=${PPP_IF:-ppp0}
CHECK_IP=${PPP_CONNECT_CHECK_HOST:-8.8.8.8}
# Toggle auto dial via file. If the file exists, auto dial is enabled.
AUTO_DIAL_FILE=${AUTO_DIAL_FILE:-/var/lib/mirako/auto_dial_enabled}

log(){ echo "[ppp-keepalive] $*"; logger -t mirako-ppp-keepalive "$*"; }

# AP está ativo?
ap_is_up(){ iw dev "$WLAN_IF" info 2>/dev/null | grep -q "type AP"; }

# Rediscagem "suave" do PPP (sem mexer no AP)
redial_ppp(){
  pkill -x pppd 2>/dev/null || true
  rm -f /var/lock/LCK..ttyUSB* 2>/dev/null || true
  (pppd call "$PPP_PEER" >/dev/null 2>&1 &) || true
}



# Determine if PPP interface has an IPv4 address.
ppp_has_ipv4(){ ip -4 addr show dev "$PPP_IF" 2>/dev/null | grep -q 'inet '; }

# Determine if PPP connectivity is OK by pinging a known IP.
ppp_ok(){ ppp_has_ipv4 && ping -I "$PPP_IF" -c2 -W3 "$CHECK_IP" >/dev/null 2>&1; }

# Ensure 3G profile is applied via profiles.sh (activates NAT & AP).
ensure_3g(){
  # Só reaplica o perfil 3G se o AP não estiver de pé.
  if ! ap_is_up; then
    "$PROFILES_SCRIPT" 3g || true
  fi
}


while :; do
  # Skip auto dial unless explicitly enabled
  if [ ! -f "$AUTO_DIAL_FILE" ]; then
    sleep 30
    continue
  fi
  WANT="$(cat "$PROFILE_FILE" 2>/dev/null || echo '')"
  if [[ "$WANT" != "3g" && "$WANT" != "ppp" && "$WANT" != "ppp3g" ]]; then
    log "last_profile='$WANT' não é 3G. Aguardando 15s…"
    sleep 15
    continue
  fi

  # Guarantee 3G profile is active.
  # Garanta que o AP 3G está ativo (sem flapar se já estiver)
  ensure_3g

  # Se PPP ok, apenas monitore
  if ppp_ok; then
    log "PPP ok (conectividade via $PPP_IF). Monitorando…"
    for j in {1..60}; do
      if ! ppp_ok; then
        log "Conectividade PPP perdida — tentando rediscagem…"
        break
      fi
      sleep 5
    done
  else
    # PPP não está OK. Se discagem automática estiver habilitada, rediscamos.
    if [ -f "$AUTO_DIAL_FILE" ]; then
      log "PPP sem conectividade; iniciando rediscagem (sem reiniciar AP)…"
      redial_ppp
      # janela curta para o PPP nascer
      for i in {1..20}; do
        if ppp_has_ipv4; then break; fi
        sleep 1
      done
    else
      log "PPP sem conectividade e discagem automática desabilitada; mantendo AP."
    fi
  fi

  sleep 3

  # Wait briefly for PPP to obtain IPv4.
  for i in {1..20}; do
    if ppp_has_ipv4; then break; fi
    sleep 1
  done

  if ppp_ok; then
    log "PPP ok (conectividade via $PPP_IF). Monitorando…"
    # Monitor in 5s intervals, break if connectivity lost.
    for j in {1..60}; do
      if ! ppp_ok; then
        log "Conectividade perdida — tentando reerguer perfil 3G…"
        break
      fi
      sleep 5
    done
  else
    log "PPP sem conectividade; reerguendo perfil 3G…"
  fi

  # Small delay before next cycle.
  sleep 3
done
EOF
sudo chmod +x /usr/local/bin/mirako-ppp-keepalive.sh







sudo tee /etc/systemd/system/mirako-ppp-keepalive.service >/dev/null <<'UNIT'
[Unit]
Description=Mirako PPP keep-alive (auto-redial 3G + AP)
After=network-online.target mirako-profile.service
Wants=network-online.target

[Service]
Type=simple
Environment=WLAN_IF=wlan0
Environment=LAN_IF=end0
Environment=PPP_IF=ppp0
Environment=PPP_PEER=3g
Environment=PROFILES_SCRIPT=/usr/local/bin/profiles.sh
ExecStart=/usr/local/bin/mirako-ppp-keepalive.sh
Restart=always
RestartSec=5s
# Provide a safe PATH for scripts
Environment=PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

[Install]
WantedBy=multi-user.target
UNIT

sudo systemctl daemon-reload
sudo systemctl enable --now mirako-ppp-keepalive.service









sudo tee /etc/ppp/ip-down.d/99-mirako >/dev/null <<'EOF'
#!/bin/sh
# PPP ip-down hook for Mirako. Handles fallback when PPP drops.
# If the last profile was 3G, do not force AP: allow pppd to redial.
LP="/var/lib/mirako/last_profile"
if [ -r "$LP" ]; then
  LAST="$(cat "$LP" 2>/dev/null)"
else
  LAST=""
fi

if [ "$LAST" = "3g" ] || [ "$LAST" = "ppp" ] || [ "$LAST" = "ppp3g" ]; then
  logger -t mirako "PPP caiu; mantendo perfil 3G para rediscagem automática (persist)."
  exit 0
fi

# For other profiles, fallback to AP.
logger -t mirako "PPP caiu; comutando para perfil AP (fallback)"
exec /usr/local/bin/profiles.sh ap
EOF
sudo chmod +x /etc/ppp/ip-down.d/99-mirako




sudo tee /etc/ppp/ip-up.d/00-mirako-dns >/dev/null <<'SH'
#!/bin/sh
# PPP ip-up hook for Mirako. Applies DNS settings learned via pppd (usepeerdns).
if [ -r /etc/ppp/resolv.conf ]; then
  # If /etc/resolv.conf is a symlink, replace it with a regular file.
  [ -L /etc/resolv.conf ] && rm -f /etc/resolv.conf
  cp -f /etc/ppp/resolv.conf /etc/resolv.conf
fi
exit 0
SH
sudo chmod +x /etc/ppp/ip-up.d/00-mirako-dns



sudo tee /etc/sysctl.d/98-mirako-rpf.conf >/dev/null <<'SYS'
net.ipv4.conf.all.rp_filter=0
net.ipv4.conf.default.rp_filter=0
net.ipv4.conf.ppp0.rp_filter=0
SYS
sudo sysctl --system







sudo chmod +x /usr/local/bin/profiles.sh /usr/local/bin/mirako-autoboot.sh
sudo systemctl daemon-reload
sudo systemctl restart mirako-profile.service

# conferir rapidamente:
systemctl status mirako-profile.service --no-pager
journalctl -b -u mirako-profile.service -n 120 --no-pager






sudo journalctl -u mirako-web -f








sudo apt install samba
sudo mkdir -p /home/public
sudo chown nobody:nogroup /home/public    # Debian/Ubuntu; em CentOS pode ser nobody:nobody
sudo chmod 0777 /home/public
sudo chmod -R 0777 /home/public
sudo ufw allow samba




sudo tee /etc/samba/smb.conf >/dev/null <<'EOF'
[global]
   workgroup = WORKGROUP
   server string = MirakoSamba Server
   netbios name = MIRAKOSERVER
   security = user
   map to guest = Bad User
   log file = /var/log/samba/%m.log
   max log size = 50

   # Importante para aparecer na rede
   server role = standalone server
   local master = yes
   preferred master = yes
   os level = 255
   wins support = yes
   name resolve order = bcast host lmhosts wins

[Public]
   comment = Pasta pública - acesso guest
   path = /home/public
   browseable = yes
   guest ok = yes
   read only = no
   writable = yes
   public = yes
   force user = nobody
   create mask = 0777
   directory mask = 0777
   printable = no
EOF

















