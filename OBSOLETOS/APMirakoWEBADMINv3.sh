sudo tee /etc/update-motd.d/10-orangepi-header >/dev/null <<'EOF'
#!/bin/bash
#
# Copyright (c) Authors: https://www.armbian.com/authors
#
# This file is licensed under the terms of the GNU General Public
# License version 2. This program is licensed "as is" without any
# warranty of any kind, whether express or implied.

# DO NOT EDIT THIS FILE but add config options to /etc/default/orangepi-motd
# any changes will be lost on board support package update

THIS_SCRIPT="header"
MOTD_DISABLE=""

[[ -f /etc/default/orangepi-motd ]] && . /etc/default/orangepi-motd

for f in $MOTD_DISABLE; do
	[[ $f == $THIS_SCRIPT ]] && exit 0
done

. /etc/os-release
. /etc/orangepi-release

KERNELID=$(uname -r)
TERM=linux toilet -f standard -F metal $(echo 'Mirako.org')
echo -e "Welcome to \e[0;91mOrange Pi ${VERSION} ${DISTRIBUTION_CODENAME^}\x1B[0m with $([[ $BRANCH == edge ]] && echo -e "\e[0;91mbleeding\x1B[0m edge " )\e[0;91mLinux $KERNELID\x1B[0m\n \e[0;97m by SantoCyber\x1B[0m\n"

EOF

figlet "Mirako.ORG"
figlet "SantoCyber"






sudo apt update
sudo apt install -y hostapd dnsmasq ppp usb-modeswitch wpasupplicant iptables-persistent python3-flask python3-systemd traceroute tcpdump isc-dhcp-client iptables pppoeconf rfkill nftables python3-pip


sudo apt update
sudo apt install watchdog
sudo systemctl enable watchdog
sudo systemctl start watchdog


sudo sysctl --system
sudo tee /etc/sysctl.d/99-mirako.conf >/dev/null <<'CFG'
net.ipv4.ip_forward=1
net.ipv4.conf.all.rp_filter=0
net.ipv4.conf.default.rp_filter=0
net.ipv4.conf.ppp0.rp_filter=0
CFG
sudo sysctl --system


sudo netfilter-persistent save || sudo sh -c 'iptables-save > /etc/iptables/rules.v4'



sudo mkdir -p /etc/wpa_supplicant
sudo tee /etc/wpa_supplicant/wpa_supplicant-wlan0.conf >/dev/null <<'EOF'
ctrl_interface=/var/run/wpa_supplicant
update_config=1
country=BR
EOF
sudo systemctl enable wpa_supplicant@wlan0.service


# pare e desabilite tudo; masque para não voltar no boot
sudo systemctl disable --now NetworkManager || true
sudo systemctl disable --now "wpa_supplicant@wlan0.service" wpa_supplicant || true
sudo systemctl disable --now hostapd dnsmasq || true

# use o backend nft (padrão em Debian modernos)
sudo update-alternatives --set iptables /usr/sbin/iptables-nft || true

# evite que serviços “do sistema” façam concorrência com os seus
sudo systemctl disable --now hostapd dnsmasq wpa_supplicant 2>/dev/null || true

sudo systemctl mask NetworkManager || true
sudo systemctl mask "wpa_supplicant@.service" wpa_supplicant hostapd dnsmasq || true



# crie/garanta diretório de chats
sudo mkdir -p /etc/chatscripts

# (re)crie o chat de CONEXÃO

sudo install -d /etc/chatscripts

sudo tee /etc/chatscripts/3g.chat >/dev/null <<'EOF'
ABORT   'BUSY'
ABORT   'NO CARRIER'
ABORT   'NO DIALTONE'
ABORT   'NO ANSWER'
ABORT   'ERROR'
ABORT   'SIM PIN'
REPORT  CONNECT
TIMEOUT 45
''        AT
OK        ATE0
OK        ATZ
OK        AT+CFUN=1
OK        AT+CGDCONT=1,"IP","zap.vivo.com.br"
OK        ATD*99#
CONNECT   \d\c
EOF


# chat de DESCONEXÃO
sudo tee /etc/chatscripts/3g-disconnect.chat >/dev/null <<'EOF'
'' '+++'
'' 'ATH'
'' 'ATZ'
EOF

# permissões: leitura suficiente (chat só precisa ler)
sudo chmod 644 /etc/chatscripts/3g.chat /etc/chatscripts/3g-disconnect.chat

# peers do pppd
sudo mkdir -p /etc/ppp/peers
sudo tee /etc/ppp/peers/3g >/dev/null <<'EOF'
/dev/ttyUSB2 115200
connect "/usr/sbin/chat -v -f /etc/chatscripts/3g.chat"
crtscts
modem
lock
debug
noauth
defaultroute
replacedefaultroute
usepeerdns
persist
holdoff 5
maxfail 0
noipdefault
noipv6
lcp-echo-interval 5
lcp-echo-failure 6
connect-delay 1000


EOF



# PPP UP hook
sudo tee /etc/ppp/ip-up.d/99-mirako >/dev/null <<'EOF'
#!/bin/sh
# args: interface tty speed localIP remoteIP ipparam
/usr/local/bin/profiles.sh ppp-up
exit 0
EOF
sudo chmod +x /etc/ppp/ip-up.d/99-mirako

# PPP DOWN hook
sudo tee /etc/ppp/ip-down.d/99-mirako >/dev/null <<'EOF'
#!/bin/sh
/usr/local/bin/profiles.sh ppp-down
exit 0
EOF
sudo chmod +x /etc/ppp/ip-down.d/99-mirako


sudo tee /etc/ppp/ip-up.d/10-mirako-dns >/dev/null <<'SH'
#!/bin/sh
# Mirako: usa DNS estático ao subir o PPP (independe de DNS1/DNS2)
set -eu
# Se for symlink (resolvconf/systemd-resolved), remova pra controlar manualmente
[ -L /etc/resolv.conf ] && rm -f /etc/resolv.conf
cat >/etc/resolv.conf <<EOF
# Mirako static DNS (PPP up)
nameserver 1.1.1.1
nameserver 8.8.8.8
EOF
exit 0
SH
sudo chmod +x /etc/ppp/ip-up.d/10-mirako-dns

sudo tee /etc/ppp/ip-down.d/10-mirako-dns >/dev/null <<'SH'
#!/bin/sh
# Mirako: mantém DNS estático quando o PPP desce
set -eu
[ -L /etc/resolv.conf ] && rm -f /etc/resolv.conf
cat >/etc/resolv.conf <<EOF
# Mirako static DNS (PPP down)
nameserver 1.1.1.1
nameserver 8.8.8.8
EOF
exit 0
SH
sudo chmod +x /etc/ppp/ip-down.d/10-mirako-dns


sudo rm -f /etc/resolv.conf
printf "# Mirako static DNS (manual)\nnameserver 1.1.1.1\nnameserver 8.8.8.8\n" | sudo tee /etc/resolv.conf >/dev/null







sudo mkdir -p /opt/mirako_web 



sudo tee /opt/mirako_web/users.ini >/dev/null <<'EOF'
[users]
admin = qazwsx
EOF

sudo chmod 600 /opt/mirako_web/users.ini 
sudo chown root:root /opt/mirako_web/users.ini





sudo tee /opt/mirako_web/web_config.py >/dev/null <<'EOF'
#!/usr/bin/env python3
# coding: utf-8
"""
Mirako router configuration web application — versão compatível com profiles.sh
- UI sem Bootstrap (CSS embutido)
- Status do sistema a cada 15s via /status.json
- Lista Wi-Fi (scan + redes do wpa_supplicant)
- Card Perfis com SELECT + descrição e integração com /usr/local/bin/profiles.sh
- Terminal ao vivo
- Modem/PPP
- Gerenciador de arquivos em /root
- Lista de serviços systemd

Compatibilidade com profiles.sh (no-systemd):
- Wi-Fi connect tenta iniciar wpa_supplicant -B se o serviço systemd não estiver ativo.
- Perfis são aplicados via PROFILES_SCRIPT (default /usr/local/bin/profiles.sh).
"""

from __future__ import annotations

import os
import re
import time
import glob
import shutil
import subprocess
import threading
import signal
from typing import Any, List, Tuple, Dict

from flask import (
    Flask,
    render_template_string,
    request,
    redirect,
    url_for,
    flash,
    jsonify,
    send_from_directory,
    abort,
)


import configparser
from flask import jsonify, make_response


app = Flask(__name__)
app.secret_key = os.environ.get("MIRAKO_SECRET", "devkey")

# ========================== Config em runtime ==========================
WLAN_IF = os.environ.get("WLAN_IF", "wlan0")
LAN_IF = os.environ.get("LAN_IF", "end0")
PPP_IF = os.environ.get("PPP_IF", "ppp0")
PPP_PEER = os.environ.get("PPP_PEER", "3g")
PROFILES_SCRIPT = os.environ.get("PROFILES_SCRIPT", "/usr/local/bin/profiles.sh")
AUTO_DIAL_FILE = "/var/lib/mirako/auto_dial_enabled"
SSID = os.environ.get("SSID") or os.environ.get("AP_SSID") or "MirakoAP"
PASS = os.environ.get("PASS") or os.environ.get("AP_PASS") or "12345678"

def find_bin(name: str, fallbacks: List[str]) -> str:
    p = shutil.which(name)
    if p:
        return p
    for fb in fallbacks:
        if os.path.exists(fb) and os.access(fb, os.X_OK):
            return fb
    return name

PPPD_BIN = find_bin("pppd", ["/usr/sbin/pppd", "/sbin/pppd", "/usr/bin/pppd"])
IP_BIN = find_bin("ip", ["/usr/sbin/ip", "/sbin/ip", "/usr/bin/ip"])
IW_BIN = find_bin("iw", ["/usr/sbin/iw", "/sbin/iw", "/usr/bin/iw"])
IWLIST_BIN = find_bin("iwlist", ["/usr/sbin/iwlist", "/sbin/iwlist", "/usr/bin/iwlist"])
WPA_CLI_BIN = find_bin("wpa_cli", ["/usr/sbin/wpa_cli", "/sbin/wpa_cli", "/usr/bin/wpa_cli"])
WPA_SUPP_BIN = find_bin("wpa_supplicant", ["/usr/sbin/wpa_supplicant", "/sbin/wpa_supplicant", "/usr/bin/wpa_supplicant"])
RESOLVECTL_BIN = find_bin("resolvectl", ["/usr/bin/resolvectl", "/usr/sbin/resolvectl", "/bin/resolvectl"])

AUTH_INI = "/opt/mirako_web/users.ini"

WPA_SUPP_CONF_CAND = [
    f"/etc/wpa_supplicant/wpa_supplicant-{WLAN_IF}.conf",
    "/etc/wpa_supplicant/wpa_supplicant.conf",
]

# ========================== Terminal ao vivo ==========================
LOG_DIR = "/var/log/mirako"
os.makedirs(LOG_DIR, exist_ok=True)
TERM_LOG = os.path.join(LOG_DIR, "terminal.log")
RUN: Dict[str, Any] = {"proc": None, "pgid": None}
RUN_LOCK = threading.Lock()

def _write_line(text: str) -> None:
    try:
        with open(TERM_LOG, "a", encoding="utf-8", errors="ignore") as f:
            f.write(text)
            if not text.endswith("\n"):
                f.write("\n")
    except Exception:
        pass

def _pump_stdout(proc: subprocess.Popen) -> None:
    try:
        for line in iter(proc.stdout.readline, ""):
            _write_line(line.rstrip("\n"))
    except Exception as e:
        _write_line(f"[pump] erro: {e}")
    finally:
        code = proc.wait()
        _write_line(f"\n[processo finalizado] exit={code}")

def start_command(cmd: str) -> None:
    raw = cmd.strip()
    if not raw:
        return
    with RUN_LOCK:
        if RUN["proc"] is not None and RUN["proc"].poll() is None:
            try:
                os.killpg(RUN["pgid"], signal.SIGINT)
            except Exception:
                try:
                    RUN["proc"].terminate()
                except Exception:
                    pass
        try:
            with open(TERM_LOG, "w", encoding="utf-8", errors="ignore") as f:
                f.write(f"# {time.strftime('%Y-%m-%d %H:%M:%S')} — exec: {raw}\n")
        except Exception:
            pass
        proc = subprocess.Popen(
            raw,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1,
            preexec_fn=os.setsid,
        )
        RUN["proc"] = proc
        RUN["pgid"] = os.getpgid(proc.pid)
        t = threading.Thread(target=_pump_stdout, args=(proc,), daemon=True)
        t.start()

def stop_command() -> None:
    with RUN_LOCK:
        if RUN["proc"] is not None and RUN["proc"].poll() is None:
            try:
                os.killpg(RUN["pgid"], signal.SIGINT)
                _write_line("[SIGINT enviado]")
            except Exception as e:
                _write_line(f"[erro SIGINT] {e}")
                try:
                    RUN["proc"].terminate()
                except Exception:
                    pass

def clear_log() -> None:
    try:
        with open(TERM_LOG, "w", encoding="utf-8") as f:
            f.write("")
    except Exception:
        pass

def read_log_tail(max_bytes: int = 120_000) -> str:
    try:
        with open(TERM_LOG, "rb") as f:
            f.seek(0, os.SEEK_END)
            size = f.tell()
            off = max(0, size - max_bytes)
            f.seek(off, os.SEEK_SET)
            data = f.read().decode("utf-8", errors="ignore")
            return data
    except Exception:
        return "(sem saída ainda)"

# ========================== Helpers genéricos ==========================
def run(cmd: List[str], timeout: int = 10) -> Tuple[int, str]:
    try:
        out = subprocess.check_output(
            cmd, stderr=subprocess.STDOUT, text=True, timeout=timeout
        )
        return 0, out.strip()
    except subprocess.CalledProcessError as e:
        return e.returncode, (e.output or "").strip()
    except Exception as e:
        return 1, f"{type(e).__name__}: {e}"

def human_bytes(n: float) -> str:
    try:
        n = float(n)
    except Exception:
        return str(n)
    units = ["B", "KB", "MB", "GB", "TB"]
    i = 0
    while n >= 1024 and i < len(units) - 1:
        n /= 1024.0
        i += 1
    return f"{n:.1f} {units[i]}"

# ========================== Rede ==========================
def ensure_iface_up(dev: str) -> None:
    base = f"/sys/class/net/{dev}"
    if not os.path.exists(base):
        return
    try:
        state = open(os.path.join(base, "operstate")).read().strip().lower()
    except Exception:
        state = "unknown"
    if state != "up":
        run([IP_BIN, "link", "set", "dev", dev, "up"])

def get_ipv4_list(dev: str) -> str:
    rc, out = run([IP_BIN, "-4", "addr", "show", "dev", dev])
    if rc != 0:
        return "-"
    ips: List[str] = []
    for line in out.splitlines():
        s = line.strip()
        if s.startswith("inet "):
            parts = s.split()
            if len(parts) >= 2:
                ips.append(parts[1])
    return ", ".join(ips) if ips else "-"

def default_route() -> str:
    rc, out = run([IP_BIN, "-4", "route", "show", "default"])
    return out if rc == 0 and out else "<sem rota>"

def routes() -> str:
    rc, out = run([IP_BIN, "-4", "route"])
    return out if rc == 0 else f"(erro ip route rc={rc})"

def dns_info() -> str:
    if os.path.exists(RESOLVECTL_BIN):
        rc, out = run([RESOLVECTL_BIN, "status"], timeout=5)
        if rc == 0 and out:
            return out
    try:
        with open("/etc/resolv.conf", "r", encoding="utf-8", errors="ignore") as f:
            return f.read()
    except Exception as e:
        return f"# erro ao ler resolv.conf: {e}"

def read_dnsmasq_leases() -> Tuple[List[dict], str, str | None]:
    paths = ["/var/lib/misc/dnsmasq.leases", "/var/lib/dnsmasq/dnsmasq.leases"]
    for path in paths:
        if os.path.exists(path):
            leases: List[dict] = []
            raw = ""
            try:
                raw = open(path, "r", encoding="utf-8", errors="ignore").read()
                for line in raw.splitlines():
                    parts = line.split()
                    if len(parts) >= 5:
                        expiry, mac, ip, hostname, client_id = parts[:5]
                        try:
                            expi = int(expiry)
                            when = (
                                "infinito"
                                if expi == 0
                                else time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(expi))
                            )
                        except Exception:
                            when = expiry
                        leases.append(
                            {
                                "expiry": when,
                                "mac": mac,
                                "ip": ip,
                                "hostname": hostname if hostname != "*" else "",
                                "client_id": client_id,
                            }
                        )
            except Exception as e:
                raw = f"(erro ao ler {path}: {e})"
            return leases, raw, path
    return [], "(arquivo de leases não encontrado)", None

# ========================== Estado do sistema ==========================
def cpu_temp_c() -> float | None:
    temps: List[float] = []
    best: float | None = None
    for path in glob.glob("/sys/class/thermal/thermal_zone*/temp"):
        try:
            t = int(open(path).read().strip())
            c = t / 1000.0 if t > 1000 else float(t)
            ttype_path = path.replace("/temp", "/type")
            ttype = open(ttype_path).read().strip().lower() if os.path.exists(ttype_path) else ""
            if "cpu" in ttype or "soc" in ttype:
                best = c
            temps.append(c)
        except Exception:
            pass
    if best is not None:
        return best
    if temps:
        return sum(temps) / len(temps)
    try:
        c = int(open("/sys/class/thermal/thermal_zone0/temp").read().strip()) / 1000.0
        return c
    except Exception:
        return None

def cpu_usage_pct(sample_sec: float = 0.2) -> float:
    def read_cpu() -> Tuple[int, int]:
        with open("/proc/stat", "r") as f:
            for line in f:
                if line.startswith("cpu "):
                    parts = line.split()
                    vals = list(map(int, parts[1:]))
                    idle = vals[3] + (vals[4] if len(vals) > 4 else 0)
                    total = sum(vals)
                    return idle, total
        return 0, 1
    idle1, total1 = read_cpu()
    time.sleep(sample_sec)
    idle2, total2 = read_cpu()
    dtotal = total2 - total1
    didle = idle2 - idle1
    if dtotal <= 0:
        return 0.0
    busy = 100.0 * (1.0 - (didle / dtotal))
    if busy < 0:
        busy = 0.0
    max_pct = 100 * (os.cpu_count() or 1)
    return busy if busy <= max_pct else max_pct

def uptime_str() -> str:
    try:
        up_seconds = float(open("/proc/uptime").read().split()[0])
        days = int(up_seconds // 86400)
        hrs  = int((up_seconds % 86400) // 3600)
        mins = int((up_seconds % 3600) // 60)
        if days > 0:
            return f"{days}d {hrs}h {mins}m"
        return f"{hrs}h {mins}m"
    except Exception:
        return "-"
    

def mem_stats() -> Dict[str, float]:
    info: Dict[str, str] = {}
    with open("/proc/meminfo", "r") as f:
        for line in f:
            k, v = line.split(":", 1)
            info[k.strip()] = v.strip()
    def kB(name: str) -> int:
        val = info.get(name, "0").split()[0]
        return int(val)
    total = kB("MemTotal") * 1024
    avail = kB("MemAvailable") * 1024
    used = total - avail
    pct = (used / total * 100.0) if total > 0 else 0.0
    return dict(total=total, used=used, avail=avail, pct=pct)

def disk_stats(path: str = "/") -> Dict[str, float]:
    du = shutil.disk_usage(path)
    used = du.total - du.free
    pct = used / du.total * 100.0 if du.total else 0.0
    return dict(total=du.total, used=used, free=du.free, pct=pct)

def processes_top(n: int = 20) -> List[dict]:
    rc, out = run(["ps", "-eo", "pid,comm,%cpu,%mem", "--sort=-%cpu"])
    procs: List[dict] = []
    if rc == 0 and out:
        lines = out.splitlines()
        for line in lines[1 : 1 + n]:
            parts = line.split(None, 4)
            if len(parts) >= 4:
                pid, comm, pcpu, pmem = parts[:4]
                procs.append(dict(pid=pid, comm=comm, pcpu=pcpu, pmem=pmem))
    return procs

def net_stats_for(dev: str) -> dict:
    base = f"/sys/class/net/{dev}"
    if not os.path.exists(base):
        return dict(dev=dev, state="DOWN", ipv4="-", rx="-", tx="-")
    try:
        state = open(os.path.join(base, "operstate")).read().strip().upper()
    except Exception:
        state = "?"
    def read_num(p: str) -> int:
        try:
            return int(open(p).read().strip())
        except Exception:
            return 0
    rx = read_num(os.path.join(base, "statistics/rx_bytes"))
    tx = read_num(os.path.join(base, "statistics/tx_bytes"))
    return dict(
        dev=dev,
        state=state,
        ipv4=get_ipv4_list(dev),
        rx=human_bytes(rx),
        tx=human_bytes(tx),
    )

# ========================== Wi-Fi ==========================
def iw_info() -> dict:
    rc, out = run([IW_BIN, "dev", WLAN_IF, "info"])
    info: Dict[str, Any] = {"type": "-", "channel": "-", "freq_mhz": None, "txpower_dbm": "-"}
    if rc == 0 and out:
        for ln in out.splitlines():
            s = ln.strip()
            if s.startswith("type "):
                info["type"] = s.split(" ", 1)[1].strip()
            elif "channel" in s and "(" in s and "MHz" in s:
                try:
                    parts = s.split()
                    info["channel"] = parts[1]
                    mhz = s.split("(")[1].split("MHz")[0].strip()
                    info["freq_mhz"] = float(mhz)
                except Exception:
                    pass
            elif s.startswith("txpower "):
                try:
                    val = s.split()[1]
                    info["txpower_dbm"] = f"{float(val):.1f} dBm"
                except Exception:
                    pass
    return info

def get_ap_ssid() -> str:
    for path in glob.glob("/tmp/create_ap*.conf"):
        try:
            txt = open(path, "r", encoding="utf-8", errors="ignore").read()
            m = re.search(r"^\s*ssid\s*=\s*(.+)$", txt, re.M)
            if m:
                return m.group(1).strip()
        except Exception:
            pass
    rc, out = run([IW_BIN, "dev", WLAN_IF, "info"])
    if rc == 0 and out:
        for ln in out.splitlines():
            s = ln.strip()
            if s.lower().startswith("ssid "):
                return s.split(None, 1)[1].strip()
    return SSID

def iw_link() -> dict:
    rc, out = run([IW_BIN, "dev", WLAN_IF, "link"])
    d: Dict[str, Any] = {
        "connected": False,
        "ssid": "-",
        "bssid": "-",
        "signal_dbm": None,
        "rx_bitrate": "-",
        "tx_bitrate": "-",
        "rx": "-",
        "tx": "-",
        "clients": 0,
    }
    if rc == 0 and out:
        if "Not connected." in out:
            d["connected"] = True
            d["ssid"] = get_ap_ssid()
            rc2, st = run([IW_BIN, "dev", WLAN_IF, "station", "dump"])
            if rc2 == 0 and st:
                clients = 0
                rssi = None
                for ln in st.splitlines():
                    s = ln.strip().lower()
                    if s.startswith("station "):
                        clients += 1
                    if s.startswith("signal:"):
                        try:
                            rssi = float(s.split()[1])
                        except Exception:
                            pass
                d["clients"] = clients
                if rssi is not None:
                    d["signal_dbm"] = rssi
            return d
        else:
            d["connected"] = True
            for ln in out.splitlines():
                s = ln.strip()
                if s.startswith("SSID:"):
                    d["ssid"] = s.split(":", 1)[1].strip()
                elif s.startswith("Connected to "):
                    d["bssid"] = s.split()[2].strip()
                elif s.startswith("signal:"):
                    try:
                        d["signal_dbm"] = float(s.split()[1])
                    except Exception:
                        pass
                elif s.startswith("rx bitrate:"):
                    d["rx_bitrate"] = s.split(":", 1)[1].strip()
                elif s.startswith("tx bitrate:"):
                    d["tx_bitrate"] = s.split(":", 1)[1].strip()
                elif s.startswith("RX:"):
                    d["rx"] = s.split(":", 1)[1].strip()
                elif s.startswith("TX:"):
                    d["tx"] = s.split(":", 1)[1].strip()
    return d

def iface_byte_counters(dev: str) -> Tuple[int, int, int, int]:
    base = f"/sys/class/net/{dev}/statistics"
    try:
        rx1 = int(open(os.path.join(base, "rx_bytes")).read().strip())
        tx1 = int(open(os.path.join(base, "tx_bytes")).read().strip())
        time.sleep(0.25)
        rx2 = int(open(os.path.join(base, "rx_bytes")).read().strip())
        tx2 = int(open(os.path.join(base, "tx_bytes")).read().strip())
        rx_bps = (rx2 - rx1) * 8 * 4
        tx_bps = (tx2 - tx1) * 8 * 4
        return (rx2, tx2, rx_bps, tx_bps)
    except Exception:
        return (0, 0, 0, 0)

def wpa_status() -> dict:
    rc, out = run([WPA_CLI_BIN, "-i", WLAN_IF, "status"])
    d: Dict[str, Any] = {}
    if rc == 0:
        for line in out.splitlines():
            if "=" in line:
                k, v = line.split("=", 1)
                d[k] = v
    return d

def wifi_status_details() -> dict:
    st = wpa_status()
    ii = iw_info()
    lk = iw_link()
    rxB, txB, rxbps, txbps = iface_byte_counters(WLAN_IF)
    mode = ii.get("type", "-").upper()
    state = st.get("wpa_state", "-")
    channel = ii.get("channel", "-")
    freq_mhz = ii.get("freq_mhz")
    rssi = lk.get("signal_dbm")
    dist_m = None
    try:
        import math
        if (rssi is not None) and freq_mhz:
            dist_m = round(10 ** ((27.55 - (20 * math.log10(float(freq_mhz))) + abs(float(rssi))) / 20), 1)
    except Exception:
        pass
    return {
        "mode": mode,
        "state": state,
        "ssid": lk.get("ssid", "-"),
        "bssid": lk.get("bssid", "-"),
        "channel": channel,
        "freq_mhz": f"{freq_mhz:.0f} MHz" if freq_mhz else "-",
        "txpower": ii.get("txpower_dbm", "-"),
        "rssi": f"{rssi:.0f} dBm" if rssi is not None else "-",
        "tx_bitrate": lk.get("tx_bitrate", "-"),
        "rx_bitrate": lk.get("rx_bitrate", "-"),
        "rx_bytes": human_bytes(rxB),
        "tx_bytes": human_bytes(txB),
        "rx_bps": f"{rxbps/1e6:.2f} Mbit/s" if rxbps > 0 else "0",
        "tx_bps": f"{txbps/1e6:.2f} Mbit/s" if txbps > 0 else "0",
        "clients": lk.get("clients", 0),
        "distance_m": f"~{dist_m} m" if dist_m else "-",
    }

def wifi_scan() -> Tuple[List[dict], str | None]:
    ensure_iface_up(WLAN_IF)
    rc, out = run([IW_BIN, "dev", WLAN_IF, "scan"])
    if rc == 0 and out:
        bss: Dict[str, Any] | None = None
        nets: List[dict] = []
        for line in out.splitlines():
            s = line.strip()
            if s.startswith("BSS "):
                if bss:
                    nets.append(bss)
                bss = {"ssid": "", "signal": "", "freq": "", "security": "?"}
            elif s.startswith("SSID:"):
                if bss is None:
                    bss = {}
                bss["ssid"] = s[5:].strip()
            elif s.startswith("freq:"):
                if bss is None:
                    bss = {}
                bss["freq"] = s[5:].strip()
            elif s.startswith("signal:"):
                if bss is None:
                    bss = {}
                bss["signal"] = s[7:].strip()
            elif s.startswith("RSN:") or s.startswith("WPA:"):
                if bss is None:
                    bss = {}
                bss["security"] = "WPA/WPA2"
        if bss:
            nets.append(bss)
        nets = [n for n in nets if n.get("ssid")]
        uniq: Dict[str, dict] = {}
        for n in nets:
            ssid = n["ssid"]
            if ssid not in uniq or n.get("signal", "") > uniq[ssid].get("signal", ""):
                uniq[ssid] = n
        return list(uniq.values()), None
    rc2, out2 = run([IWLIST_BIN, WLAN_IF, "scan"])
    if rc2 == 0 and out2:
        nets = []
        for b in out2.split("Cell "):
            ssid_m = re.search(r'ESSID:"(.*)"', b)
            qual = re.search(r"Signal level=(-?\d+)", b) or re.search(r"Quality=([0-9/]+)", b)
            freq = re.search(r"Frequency:([0-9\.]+)", b)
            enc = "Open" if "Encryption key:off" in b else "WPA/WPA2"
            if ssid_m:
                nets.append(
                    {
                        "ssid": ssid_m.group(1),
                        "signal": (qual.group(1) if qual else "?"),
                        "freq": (freq.group(1) if freq else "?"),
                        "security": enc,
                    }
                )
        return nets, None
    return [], "iw scan falhou"

def get_saved_networks() -> List[Dict[str, str]]:
    rc, out = run([WPA_CLI_BIN, "-i", WLAN_IF, "list_networks"])
    nets: List[Dict[str, str]] = []
    if rc == 0 and out:
        lines = out.splitlines()[1:]
        for line in lines:
            parts = line.split("\t")
            if len(parts) >= 4:
                nets.append(
                    {"id": parts[0].strip(), "ssid": parts[1].strip(), "bssid": parts[2].strip(), "flags": parts[3].strip()}
                )
    return nets

def read_wpa_conf_networks() -> List[Dict[str, str]]:
    paths = [
        f"/etc/wpa_supplicant/wpa_supplicant-{WLAN_IF}.conf",
        "/etc/wpa_supplicant/wpa_supplicant.conf",
    ]
    items: List[Dict[str, str]] = []
    for path in paths:
        if not os.path.exists(path):
            continue
        try:
            txt = open(path, "r", encoding="utf-8", errors="ignore").read()
        except Exception:
            continue
        for block in re.findall(r'network=\{(.*?)\}', txt, flags=re.S | re.M):
            ssid_m = re.search(r'^\s*ssid\s*=\s*"(.*?)"\s*$', block, flags=re.M)
            psk_m  = re.search(r'^\s*psk\s*=\s*"(.*?)"\s*$', block, flags=re.M)
            keymgmt_m = re.search(r'^\s*key_mgmt\s*=\s*(.*?)\s*$', block, flags=re.M)
            prio_m = re.search(r'^\s*priority\s*=\s*(\d+)\s*$', block, flags=re.M)
            items.append({
                "ssid": ssid_m.group(1) if ssid_m else "(sem ssid)",
                "psk": ("(oculta)" if psk_m else ("OPEN" if (keymgmt_m and keymgmt_m.group(1).strip().upper()=="NONE") else "(?)")),
                "key_mgmt": (keymgmt_m.group(1).strip() if keymgmt_m else "-"),
                "priority": (prio_m.group(1) if prio_m else "-"),
            })
    uniq: Dict[str, Dict[str, str]] = {}
    for n in items:
        k = n["ssid"]
        if k not in uniq:
            uniq[k] = n
        else:
            try:
                if int(n.get("priority","0")) > int(uniq[k].get("priority","0")):
                    uniq[k] = n
            except Exception:
                pass
    out = list(uniq.values())
    try:
        out.sort(key=lambda x: int(x.get("priority","0")), reverse=True)
    except Exception:
        pass
    return out

def wifi_connect(ssid: str, psk: str | None = None) -> Tuple[bool, str]:
    """
    Agora: só persiste credenciais em /etc/mirako/wifi.env e delega
    a conexão ao profiles.sh client-wifi (para também voltar no boot).
    """
    try:
        os.makedirs("/etc/mirako", exist_ok=True)
        with open("/etc/mirako/wifi.env", "w", encoding="utf-8") as f:
            f.write(f'WIFI_SSID="{ssid}"\n')
            f.write(f'WIFI_PSK="{(psk or "").strip()}"\n')
        os.chmod("/etc/mirako/wifi.env", 0o600)
    except Exception as e:
        return False, f"falha ao salvar credenciais: {e}"

    # Aplica imediatamente o profile e grava como 'last_profile' para voltar após boot
    rc, out = profile_set("client-wifi")
    if rc != 0:
        return False, (out or "profiles.sh client-wifi falhou")

    # Pequena espera e verificação opcional do IP em wlan0 (somente informativo)
    time.sleep(2)
    ip = get_ipv4_list(WLAN_IF)
    return True, f"credenciais salvas e profile 'client-wifi' aplicado; IP wlan0={ip}"

def wifi_disconnect() -> Tuple[bool, str]:
    rc, out = run([PROFILES_SCRIPT, "stop"], timeout=60)
    return (rc == 0, out or "parado")


# ========================== Serviços & PPP ==========================
def list_services() -> List[dict]:
    services: List[dict] = []
    rc, out = run(["systemctl","list-unit-files","--type=service","--no-pager","--no-legend"])
    if rc != 0 or not out:
        return services
    for line in out.splitlines():
        parts = line.split()
        if not parts:
            continue
        name = parts[0]
        state = parts[1] if len(parts) > 1 else "disabled"
        rc_active, _ = run(["systemctl", "is-active", name])
        active = (rc_active == 0)
        enabled = state.startswith("enabled")
        services.append({"name": name, "active": active, "enabled": enabled})
    services.sort(key=lambda x: x["name"])
    return services

def service_action(service: str, action: str) -> Tuple[bool, str]:
    valid = {"start","stop","restart","enable","disable"}
    if action not in valid:
        return False, f"ação inválida: {action}"
    cmd = ["systemctl", action, service] if action in {"start","stop","restart"} else ["systemctl", action, service]
    rc, out = run(cmd, timeout=20)
    return (rc == 0, out)

def parse_dhclient_lease(iface: str) -> Tuple[List[str], List[str]]:
    path = f"/var/lib/dhcp/dhclient.{iface}.leases"
    routers: List[str] = []
    dns: List[str] = []
    try:
        if os.path.exists(path):
            txt = open(path, "r", encoding="utf-8", errors="ignore").read()
            m_dns = re.findall(r"option\s+domain-name-servers\s+([^;]+);", txt)
            m_rtr = re.findall(r"option\s+routers\s+([^;]+);", txt)
            if m_dns:
                dns = [i.strip() for i in re.split(r"[,\s]+", m_dns[-1].strip()) if i.strip()]
            if m_rtr:
                routers = [i.strip() for i in re.split(r"[,\s]+", m_rtr[-1].strip()) if i.strip()]
    except Exception:
        pass
    return routers, dns

def apply_dns(nameservers: List[str]) -> Tuple[bool, str]:
    try:
        if os.path.islink("/etc/resolv.conf"):
            os.unlink("/etc/resolv.conf")
        with open("/etc/resolv.conf", "w", encoding="utf-8") as f:
            f.write("# Generated by Mirako client-wifi\n")
            for ns in nameservers:
                if ns:
                    f.write(f"nameserver {ns}\n")
        return True, "resolv.conf atualizado"
    except Exception as e:
        return False, f"erro ao escrever resolv.conf: {e}"

def is_auto_dial_enabled() -> bool:
    try:
        return os.path.exists(AUTO_DIAL_FILE)
    except Exception:
        return False

def set_auto_dial(enabled: bool) -> None:
    try:
        if enabled:
            os.makedirs(os.path.dirname(AUTO_DIAL_FILE), exist_ok=True)
            with open(AUTO_DIAL_FILE, "w") as f:
                f.write("1")
        else:
            if os.path.exists(AUTO_DIAL_FILE):
                os.remove(AUTO_DIAL_FILE)
    except Exception:
        pass

def ensure_default_via(gw: str, dev: str) -> None:
    if not gw:
        return
    run([IP_BIN, "route", "replace", "default", "via", gw, "dev", dev])

def list_interfaces(include_virtual: bool = True, include_lo: bool = True) -> List[str]:
    try:
        names = sorted(os.listdir("/sys/class/net"))
    except Exception:
        names = []
    skip_prefix = ("veth", "br-", "docker", "virbr", "vnet", "vmnet", "vnet", "zt")
    out: List[str] = []
    for n in names:
        if not include_lo and n == "lo":
            continue
        if not include_virtual and n.startswith(skip_prefix):
            continue
        out.append(n)
    return out

def profile_set(profile: str) -> Tuple[int, str]:
    return run([PROFILES_SCRIPT, profile], timeout=180)

def modem_connect() -> Tuple[bool, str]:
    run(["pkill", "-x", "pppd"])
    run(["rm", "-f", "/var/lock/LCK..ttyUSB*"])
    try:
        subprocess.Popen([PPPD_BIN, "call", PPP_PEER], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
    except Exception as e:
        return False, f"erro ao iniciar pppd: {e}"
    deadline = time.time() + 20
    up = False
    while time.time() < deadline:
        rc, _ = run([IP_BIN, "link", "show", PPP_IF])
        if rc == 0:
            up = True
            break
        time.sleep(1.0)
    if up:
        return True, "pppd call enviado e ppp0 ativo"
    rc1, j1 = run(["journalctl", "-b", "-n", "50", "--no-pager"])
    last: List[str] = []
    if rc1 == 0 and j1:
        for ln in j1.splitlines():
            if ("pppd" in ln.lower()) or ("chat" in ln.lower()):
                last.append(ln)
    msg = "ppp0 não subiu. "
    if last:
        msg += "Logs recentes: " + ("\n".join(last[-8:]))
    else:
        msg += "Sem logs do pppd/chat."
    return False, msg

def modem_disconnect() -> Tuple[bool, str]:
    rc, out = run(["poff", PPP_PEER], timeout=20)
    msg = (out or "").strip()
    if rc != 0 and ("No pppd is running" in msg or "None stopped" in msg):
        return True, "pppd já estava parado"
    if rc != 0:
        run(["pkill", "-x", "pppd"])
        run(["rm", "-f", "/var/lock/LCK..ttyUSB*"])
        return True, "pppd finalizado"
    return True, msg or "poff enviado"

def get_last_profile() -> str:
    path = "/var/lib/mirako/last_profile"
    try:
        with open(path, "r", encoding="utf-8") as f:
            return f.read().strip() or "ap"
    except Exception:
        return "ap"

# ========================== Template ==========================
TEMPLATE = """
<!doctype html>
<html lang="pt-br">
<head>
<meta charset="utf-8">
<title>Mirako — Orange Pi Router</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  :root{
    --bg:#0b0d10; --panel:#12161b; --muted:#9aa4b2; --text:#e6e6e6; --acc:#25a0ff;
    --ok:#2ea043; --ok-b:#1f4726;
    --warn:#e0b84f; --warn-b:#4a3f1d;
    --pri:#2563eb; --pri-b:#1e3a8a;
    --danger:#ef4444; --danger-b:#7f1d1d;
    --line:#1e252d;
    --radius: 10px;
    --shadow: 0 4px 12px rgba(0,0,0,0.15);
  }
  *{box-sizing:border-box}
  html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif}
  a{color:var(--acc);text-decoration:none} a:hover{text-decoration:underline}
  
  .wrap{max-width:1400px;margin:0 auto;padding:16px}
  
  .topbar{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:16px 20px;
    background:linear-gradient(135deg, #0f141a, #131a22);
    border:1px solid var(--line);
    border-radius:var(--radius);
    margin-bottom:20px;
    box-shadow: var(--shadow);
  }
  .brand{font-weight:700;font-size:1.25rem;color:var(--text)}
  .topbar .muted{font-size:0.9rem}
  
  /* Grid System */
  .dashboard-grid{
    display:grid;
    grid-template-columns:repeat(auto-fit, minmax(300px, 1fr));
    gap:20px;
    margin-bottom:20px;
  }
  
  .main-grid{
    display:grid;
    grid-template-columns:repeat(auto-fit, minmax(350px, 1fr));
    gap:20px;
    margin-bottom:20px;
  }
  
  .full-width{
    grid-column:1/-1;
  }
  
  /* Nova estrutura para redes, rotas e arquivos */
  .network-section {
    display: grid;
    grid-template-columns: 2fr 1fr;
    gap: 20px;
    margin-bottom: 20px;
  }
  
  .services-terminal-section {
    display: grid;
    grid-template-rows: auto auto;
    gap: 20px;
  }
  
  /* Card Styles */
  .card{
    background:var(--panel);
    border:1px solid var(--line);
    border-radius:var(--radius);
    box-shadow: var(--shadow);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    overflow:hidden;
  }
  
  .card:hover{
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0,0,0,0.2);
  }
  
  .card .hd{
    padding:14px 16px;
    border-bottom:1px solid var(--line);
    font-weight:600;
    display:flex;
    justify-content:space-between;
    align-items:center;
    background:rgba(15, 20, 26, 0.6);
  }
  
  .card .bd{
    padding:16px;
  }
  
  .card-section{
    margin-bottom:16px;
  }
  
  .card-section:last-child{
    margin-bottom:0;
  }
  
  .card-section-title{
    font-size:0.9rem;
    color:var(--muted);
    margin-bottom:8px;
    font-weight:500;
  }
  
  /* Status Grid */
  .status-grid{
    display:grid;
    grid-template-columns:repeat(3, 1fr);
    gap:12px;
  }
  
  .status-item{
    text-align:center;
    padding:12px;
    background:rgba(15, 20, 26, 0.4);
    border-radius:8px;
    border:1px solid var(--line);
  }
  
  .status-item .value{
    font-size:1.1rem;
    font-weight:600;
    margin:4px 0;
  }
  
  .status-item .label{
    font-size:0.85rem;
    color:var(--muted);
  }
  
  /* Data Grid */
  .data-grid{
    display:grid;
    grid-template-columns:repeat(auto-fit, minmax(200px, 1fr));
    gap:12px;
  }
  
  .data-item{
    padding:8px 0;
  }
  
  .data-item .label{
    font-size:0.85rem;
    color:var(--muted);
    margin-bottom:4px;
  }
  
  .data-item .value{
    font-size:0.95rem;
    font-weight:500;
  }
  
  /* Buttons */
  .btn{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    padding:10px 16px;
    border:1px solid var(--line);
    border-radius:8px;
    background:#16212c;
    color:var(--text);
    cursor:pointer;
    transition:all .15s ease-in-out;
    font-weight:500;
    gap:6px;
  }
  
  .btn:hover{
    filter:brightness(1.1);
    transform:translateY(-1px);
    box-shadow:0 4px 8px rgba(0,0,0,0.15);
  }
  
  .btn.small{
    padding:6px 10px;
    font-size:0.85rem;
  }
  
  .btn.ok{background:linear-gradient(135deg, var(--ok), #238636);border-color:var(--ok-b)}
  .btn.warn{background:linear-gradient(135deg, var(--warn), #b5892e);border-color:var(--warn-b);color:#1b1407}
  .btn.primary{background:linear-gradient(135deg, var(--pri), #1d4ed8);border-color:var(--pri-b)}
  .btn.danger{background:linear-gradient(135deg, var(--danger), #b91c1c);border-color:var(--danger-b)}
  .btn.outline{background:transparent;border-color:var(--line)}
  
  .btn-group{
    display:flex;
    gap:8px;
    flex-wrap:wrap;
  }
  
  /* Form Elements */
  .form-group{
    margin-bottom:16px;
  }
  
  .form-group:last-child{
    margin-bottom:0;
  }
  
  .form-label{
    display:block;
    margin-bottom:6px;
    font-weight:500;
    font-size:0.9rem;
  }
  
  input[type=text],input[type=password],input[type=file],select{
    width:100%;
    padding:10px 12px;
    border:1px solid var(--line);
    border-radius:8px;
    background:#0e141a;
    color:#e6e6e6;
    font-size:0.95rem;
    transition:border-color 0.2s ease;
  }
  
  input[type=text]:focus,input[type=password]:focus,select:focus{
    outline:none;
    border-color:var(--acc);
  }
  
  .checkbox-group{
    display:flex;
    align-items:center;
    gap:8px;
  }
  
  /* Tables */
  .table{
    width:100%;
    border-collapse:collapse;
    font-size:0.9rem;
  }
  
  .table th,.table td{
    border-bottom:1px solid var(--line);
    padding:10px 8px;
    vertical-align:middle;
  }
  
  .table th{
    text-align:left;
    color:var(--muted);
    font-weight:600;
    font-size:0.85rem;
  }
  
  .table tr:hover{
    background:#131a22;
  }
  
  .table-compact th, .table-compact td{
    padding:6px 8px;
  }
  
  /* Utility Classes */
  .muted{color:var(--muted)}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,'Liberation Mono',monospace}
  .text-center{text-align:center}
  .hidden{display:none}
  
  .pill{
    display:inline-block;
    padding:4px 10px;
    border-radius:999px;
    background:#10151b;
    border:1px solid var(--line);
    font-size:.85rem;
    font-weight:500;
  }
  
  .okpill{background:#102216;border-color:#194d2b;color:#4ade80}
  .warnpill{background:#241f10;border-color:#4a3f1d;color:#facc15}
  .dangerpill{background:#2a1515;border-color:#7f1d1d;color:#f87171}
  
  .flash{
    padding:12px 16px;
    border:1px solid var(--line);
    border-radius:8px;
    background:#0f141a;
    margin-bottom:16px;
    box-shadow:0 2px 8px rgba(0,0,0,0.1);
  }
  
  .desc{
    background:#0f141a;
    border:1px dashed var(--line);
    border-radius:8px;
    padding:12px;
    font-size:0.9rem;
    line-height:1.4;
  }
  
  .logbox{
    background:#0b0d10;
    border:1px solid var(--line);
    border-radius:8px;
    padding:12px;
    height:50vh;
    overflow:auto;
    color:#d6d6d6;
    font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,'Liberation Mono',monospace;
    font-size:0.9rem;
    line-height:1.4;
  }
  
  pre{white-space:pre-wrap;word-wrap:break-word;margin:0}
  
  .ssid-row{cursor:pointer}
  
  /* Responsive */
  @media (max-width: 1024px) {
    .network-section {
      grid-template-columns: 1fr;
    }
    
    .status-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }
  
  @media (max-width: 768px) {
    .dashboard-grid, .main-grid {
      grid-template-columns:1fr;
    }
    
    .status-grid, .data-grid {
      grid-template-columns:repeat(2, 1fr);
    }
    
    .btn-group {
      flex-direction:column;
    }
    
    .btn-group .btn {
      width:100%;
    }
  }
  
  @media (max-width: 480px) {
    .status-grid, .data-grid {
      grid-template-columns:1fr;
    }
    
    .topbar {
      flex-direction:column;
      gap:8px;
      text-align:center;
    }
  }
</style>
</head>
<body>
<!-- LOGIN OVERLAY (mínimo) -->
<style>
  .login-overlay{
    position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
    background:rgba(0,0,0,.55); backdrop-filter: blur(2px); z-index:9999;
  }
  .login-card{
    width:min(420px, 92vw);
    background:var(--panel);
    border:1px solid var(--line);
    border-radius:var(--radius);
    box-shadow: var(--shadow);
    padding:18px;
  }
  .login-card h2{margin:0 0 12px 0; font-size:1.15rem}
  .login-error{margin-top:10px; color:#f87171; font-size:.9rem}
  .wrap.blurred{ filter: blur(3px) saturate(.8); }
</style>

<div id="login_overlay" class="login-overlay" style="display:flex" role="dialog" aria-modal="true" aria-labelledby="login_title">
  <div class="login-card">
    <h2 id="login_title">Mirako Router</h2>
    <form id="login_form" autocomplete="on">
      <div class="form-group">
        <label class="form-label" for="login_user">Usuário</label>
        <input type="text" id="login_user" autocomplete="username" required>
      </div>
      <div class="form-group">
        <label class="form-label" for="login_pass">Senha</label>
        <input type="password" id="login_pass" autocomplete="current-password" required>
      </div>
      <div class="form-group checkbox-group">
        <input type="checkbox" id="login_show">
        <label for="login_show">Mostrar senha</label>
      </div>
      <button type="submit" class="btn ok" style="width:100%">Entrar</button>
      <div id="login_err" class="login-error" style="display:none"></div>
    </form>
  </div>
</div>



  <div class="wrap">
    <!-- Top Bar -->
    <div class="topbar">
      <div class="brand">Mirako Router</div>
      <div class="muted">Orange Pi — Debian</div>
    </div>

    <!-- Flash Messages -->
    {% with messages = get_flashed_messages() %}
      {% if messages %}
        {% for msg in messages %}
          <div class="flash">{{ msg|safe }}</div>
        {% endfor %}
      {% endif %}
    {% endwith %}

    <!-- Dashboard Grid -->
    <div class="dashboard-grid">
      <!-- Perfis Card -->
      <div class="card">
        <div class="hd">
          <span>Perfis de Rede</span>
          <form method="post" action="{{ url_for('profiles_status_route') }}">
            <button class="btn small outline" title="profiles.sh status">Status</button>
          </form>
        </div>
        <div class="bd">
          <div class="card-section">
            <div class="card-section-title">Perfil Atual</div>
            <div class="pill mono">{{ last_profile }}</div>
          </div>
          
          <div class="card-section">
            <div class="card-section-title">Selecionar Perfil</div>
            <form method="post" action="{{ url_for('setprofile') }}">
              <div class="form-group">
                <select name="profile" id="profile_select" required>
                  <option value="ap">ap — AP em wlan0; uplink/NAT por end0</option>
                  <option value="wifi-router">wifi-router — Cliente Wi-Fi + LAN</option>
                  <option value="client-wifi">client-wifi — wlan0 cliente; end0 cliente</option>
                  <option value="client-lan">client-lan — apenas end0 cliente</option>
                  <option value="3g">3g — AP em wlan0 via ppp0</option>
                  <option value="3g-client">3g-client — AP via ppp0; end0 cliente</option>
                </select>
              </div>
              
              <div class="btn-group">
                <button class="btn primary" title="Aplicar perfil">Aplicar</button>
              </div>
            </form>
          </div>
          
          <div class="card-section">
            <div class="card-section-title">Descrição</div>
            <div id="profile_desc" class="desc mono"></div>
          </div>
        </div>
      </div>

      <!-- Sistema Card -->
      <div class="card">
        <div class="hd">Status do Sistema</div>
        <div class="bd">
          <div class="status-grid">
            <div class="status-item">
              <div class="label">Temp CPU</div>
              <div class="value mono" id="sys_temp">{{ cpu_temp }}</div>
            </div>
            <div class="status-item">
              <div class="label">Uso CPU</div>
              <div class="value mono" id="sys_cpu">{{ cpu_pct }}%</div>
            </div>
            <div class="status-item">
              <div class="label">Memória</div>
              <div class="value mono" id="sys_mem">{{ mem_pct }}%</div>
              <div class="value mono">{{ mem_used }} / {{ mem_total }}</div>
            </div>
            <div class="status-item">
              <div class="label">Disco (/)</div>
              <div class="value mono" id="sys_disk">{{ disk_pct }}%</div>
              <div class="value mono">{{ disk_used }} / {{ disk_total }}</div>
            </div>
            <div class="status-item">
              <div class="label">Uptime</div>
              <div class="value mono" id="sys_uptime">{{ uptime }}</div>
            </div>
            <div class="status-item">
<div class="label">Processadores</div>
<div class="value mono" id="sys_cpus">{{ cpu_used }} / {{ cpu_count }}</div>


            </div>
          </div>
          


          
        </div>
      </div>

      <!-- Modem Card -->
      <div class="card">
        <div class="hd">Modem 3G/PPP ({{PPP_IF}})</div>
        <div class="bd">
          <div class="card-section">
            <div class="btn-group">
              <form method="post" action="{{ url_for('modem_connect_route') }}">
                <button class="btn ok">Conectar</button>
              </form>
              <form method="post" action="{{ url_for('modem_disconnect_route') }}">
                <button class="btn warn">Desconectar</button>
              </form>
            </div>
          </div>
          
          <div class="card-section">
            <form method="post" action="{{ url_for('modem_auto_dial_route') }}">
              <div class="checkbox-group">
                <input type="checkbox" id="autoDialToggle" name="auto_dial" value="1" {% if auto_dial_enabled %}checked{% endif %} onchange="this.form.submit()">
                <label for="autoDialToggle">Discagem automática (3G)</label>
              </div>
            </form>
          </div>
          
          <div class="card-section">
            <div class="card-section-title">IPv4 ({{PPP_IF}})</div>
            <pre class="mono" id="ppp_ipv4">{{ ppp_ipv4 }}</pre>
          </div>
        </div>
      </div>
    </div>

    <!-- Wi-Fi Card (full width) -->
    <div class="card full-width">
      <div class="hd">
        <span>Wi-Fi ({{WLAN_IF}})</span>
        <form method="post" action="{{ url_for('wifi_scan_route') }}">
          <button class="btn small outline">Escanear Redes</button>
        </form>
      </div>
      <div class="bd">
        <div class="card-section">
          <div class="data-grid">
            <div class="data-item">
              <div class="label">Modo / Estado</div>
              <div class="value" id="wf_mode_state">{{ wifi.mode }} / {{ wifi.state }}</div>
            </div>
            <div class="data-item">
              <div class="label">SSID / BSSID</div>
              <div class="value mono" id="wf_ssid_bssid">{{ wifi.ssid }} | {{ wifi.bssid }}</div>
            </div>
            <div class="data-item">
              <div class="label">Canal / Freq / TX pwr</div>
              <div class="value" id="wf_chan_freq_txp">{{ wifi.channel }} / {{ wifi.freq_mhz }} / {{ wifi.txpower }}</div>
            </div>
            <div class="data-item">
              <div class="label">RSSI</div>
              <div class="value" id="wf_rssi">{{ wifi.rssi }}</div>
            </div>
            <div class="data-item">
              <div class="label">Distância (est.)</div>
              <div class="value" id="wf_dist">{{ wifi.distance_m }}</div>
            </div>
            <div class="data-item">
              <div class="label">Bitrate TX / RX</div>
              <div class="value" id="wf_rates">{{ wifi.tx_bitrate }} / {{ wifi.rx_bitrate }}</div>
            </div>
            <div class="data-item">
              <div class="label">Clientes (se AP)</div>
              <div class="value" id="wf_clients">{{ wifi.clients }}</div>
            </div>
            <div class="data-item">
              <div class="label">Tráfego (bytes)</div>
              <div class="value" id="wf_bytes">TX: {{ wifi.tx_bytes }} — RX: {{ wifi.rx_bytes }}</div>
            </div>
            <div class="data-item">
              <div class="label">Taxa instantânea</div>
              <div class="value" id="wf_bps">TX: {{ wifi.tx_bps }} — RX: {{ wifi.rx_bps }}</div>
            </div>
          </div>
        </div>
        
        <div class="card-section">
          <div class="card-section-title">Conectar a Rede Wi-Fi</div>
          <form method="post" action="{{ url_for('wifi_connect_route') }}">
            <div class="form-group">
              <label class="form-label" for="ssidField">SSID</label>
              <input type="text" name="ssid" id="ssidField" required>
            </div>
            
            <div class="form-group">
              <label class="form-label" for="pskField">Senha (vazio = aberta)</label>
              <input type="password" name="psk" id="pskField" autocomplete="off">
            </div>
            
            <div class="form-group">
              <div class="checkbox-group">
                <input type="checkbox" id="showPass" onchange="togglePass()">
                <label for="showPass">Mostrar senha</label>
              </div>
            </div>
            
            <div class="btn-group">
              <button class="btn ok">Conectar</button>
            </div>
          </form>
          
          <div class="card-section">
            <form method="post" action="{{ url_for('wifi_disconnect_route') }}">
              <button class="btn warn">Desconectar Wi-Fi</button>
            </form>
          </div>
        </div>
        
        {% if wpa_file_networks and wpa_file_networks|length > 0 %}
        <div class="card-section">
          <div class="card-section-title">Redes do wpa_supplicant</div>
          <table class="table table-compact">
            <thead>
              <tr>
                <th>SSID</th>
                <th>Auth</th>
                <th>Key mgmt</th>
                <th>Priority</th>
              </tr>
            </thead>
            <tbody>
              {% for n in wpa_file_networks %}
              <tr class="ssid-row" data-ssid="{{ n.ssid|e }}" onclick="document.getElementById('ssidField').value=this.dataset.ssid;">
                <td class="mono">{{ n.ssid }}</td>
                <td>{{ n.psk }}</td>
                <td>{{ n.key_mgmt }}</td>
                <td class="mono">{{ n.priority }}</td>
              </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
        {% endif %}
        
        {% if saved_networks and saved_networks|length > 0 %}
        <div class="card-section">
          <div class="card-section-title">Redes salvas (wpa_cli)</div>
          <table class="table table-compact">
            <thead>
              <tr>
                <th>ID</th>
                <th>SSID</th>
                <th>Flags</th>
              </tr>
            </thead>
            <tbody>
              {% for n in saved_networks %}
              <tr>
                <td class="mono">{{ n.id }}</td>
                <td class="mono">{{ n.ssid }}</td>
                <td>{{ n.flags }}</td>
              </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
        {% endif %}
        
        {% if scan %}
        <div class="card-section">
          <div class="card-section-title">Redes Disponíveis</div>
          <table class="table table-compact">
            <thead>
              <tr>
                <th>SSID</th>
                <th>Signal</th>
                <th>Freq</th>
                <th>Segurança</th>
              </tr>
            </thead>
            <tbody>
              {% for n in scan %}
              <tr class="ssid-row" data-ssid="{{ n.ssid|e }}" onclick="document.getElementById('ssidField').value=this.dataset.ssid;">
                <td class="mono">{{ n.ssid }}</td>
                <td>{{ n.signal }}</td>
                <td>{{ n.freq }}</td>
                <td>{{ n.security }}</td>
              </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
        {% elif scan_dbg %}
        <div class="card-section">
          <div class="muted"><small>{{ scan_dbg }}</small></div>
        </div>
        {% endif %}
      </div>
    </div>

    <!-- Nova Seção: Redes, Rotas DNS, DHCP e Arquivos -->
    <div class="network-section">
      <!-- Coluna da Esquerda: Interfaces de Rede e DHCP Leases -->
      <div>
        <!-- Interfaces de Rede Card -->
        <div class="card">
          <div class="hd">Interfaces de Rede</div>
          <div class="bd">
            <table class="table table-compact">
              <thead>
                <tr>
                  <th>Interface</th>
                  <th>Estado</th>
                  <th>IPv4</th>
                  <th>RX</th>
                  <th>TX</th>
                </tr>
              </thead>
              <tbody id="if_table_body">
                {% for n in netlist %}
                <tr>
                  <td class="mono">{{ n.dev }}</td>
                  <td>{{ n.state }}</td>
                  <td class="mono">{{ n.ipv4 }}</td>
                  <td>{{ n.rx }}</td>
                  <td>{{ n.tx }}</td>
                </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        </div>

        <!-- DHCP Card (movido para baixo das Interfaces) -->
        <div class="card">
          <div class="hd">DHCP Leases</div>
          <div class="bd">
            {% if leases and leases|length>0 %}
            <table class="table table-compact">
              <thead>
                <tr>
                  <th>IP</th>
                  <th>Host</th>
                  <th>MAC</th>
                  <th>Expira</th>
                </tr>
              </thead>
              <tbody id="leases_table_body">
                {% for L in leases %}
                <tr>
                  <td class="mono">{{ L.ip }}</td>
                  <td class="mono">{{ L.hostname or "-" }}</td>
                  <td class="mono">{{ L.mac }}</td>
                  <td class="mono">{{ L.expiry }}</td>
                </tr>
                {% endfor %}
              </tbody>
            </table>
            {% else %}
            <div class="text-center muted">Sem leases ou arquivo não encontrado.</div>
            {% endif %}
          </div>
        </div>
      </div>

      <!-- Coluna da Direita: Rotas DNS e Gerenciador de Arquivos -->
      <div>
        <!-- Rotas & DNS Card -->
        <div class="card">
          <div class="hd">Rotas & DNS</div>
          <div class="bd">
            <div class="card-section">
              <div class="card-section-title">Rota Padrão</div>
              <pre class="mono" id="def_route">{{ def_route }}</pre>
            </div>
            
            <div class="card-section">
              <div class="card-section-title">Todas as Rotas</div>
              <pre class="mono" id="all_routes">{{ all_routes }}</pre>
            </div>
            
            <div class="card-section">
              <div class="card-section-title">Servidores DNS</div>
              <pre class="mono" id="dns_info">{{ dns }}</pre>
            </div>
          </div>
        </div>

        <!-- Gerenciador de Arquivos Card -->
        <div class="card">
          <div class="hd">Gerenciador de Arquivos</div>
          <div class="bd">
            <div class="card-section">
              <div class="card-section-title">Enviar Arquivo</div>
              <form method="post" enctype="multipart/form-data" action="{{ url_for('file_upload_route') }}">
                <div class="form-group">
                  <input type="file" name="file" required>
                </div>
                <button class="btn primary">Enviar</button>
              </form>
            </div>
            
            {% if root_files and root_files|length > 0 %}
            <div class="card-section">
              <div class="card-section-title">Arquivos em /root</div>
              <table class="table table-compact">
                <tbody>
                  {% for f in root_files %}
                  <tr>
                    <td><a href="{{ url_for('file_download', filename=f) }}" class="mono">{{ f }}</a></td>
                  </tr>
                  {% endfor %}
                </tbody>
              </table>
            </div>
            {% endif %}
          </div>
        </div>
      </div>
    </div>

    <!-- Seção Terminal e Serviços -->
    <div class="services-terminal-section">
      <!-- Terminal Card -->
      <div class="card full-width" id="terminal_card">
        <div class="hd">
          <span>Terminal ao vivo</span>
          <div class="btn-group">
            <button type="button" class="btn small outline" onclick="prefill('dmesg -wT')">dmesg</button>
            <button type="button" class="btn small outline" onclick="prefill('journalctl -f')">journalctl</button>
            <button type="button" class="btn small outline" onclick="prefill('top -b')">top</button>
            <button type="button" class="btn small outline" onclick="prefill('tcpdump -i {{WLAN_IF}} -n -vv -s 120')">tcpdump</button>
            <button type="button" class="btn small warn" onclick="stopCmd()">Ctrl+C</button>
            <button type="button" class="btn small outline" onclick="clearLog()">Limpar</button>
            <button type="button" class="btn small danger" onclick="rebootConfirm()">Reiniciar</button>
          </div>
        </div>
        <div class="bd">
          <div id="terminal_wrap" class="logbox">
            <pre id="terminal_out" class="mono"></pre>
          </div>
          
          <div class="card-section">
            <div class="form-group">
              <div class="input-group" style="display:flex;gap:8px;align-items:center;">
                <span class="mono muted">$</span>
                <input id="terminal_cmd" placeholder="Digite um comando e pressione Enter" style="flex:1;">
                <button class="btn ok" type="button" id="terminal_run_btn">Executar</button>
              </div>
            </div>
            <div class="muted">Dica: use <span class="mono">top</span> — o backend usa modo batch automaticamente.</div>
          </div>
        </div>
      </div>

      <!-- Serviços Card -->
      <div class="card full-width">
        <div class="hd">
          <span>Serviços do Sistema</span>
          <button id="toggle_services_btn" class="btn small outline" type="button" onclick="toggleServices()">Ver serviços</button>
        </div>
        <div class="card hidden" id="services_card">
          <div class="bd">
            <table class="table table-compact">
              <thead>
                <tr>
                  <th>Serviço</th>
                  <th>Status</th>
                  <th>Enabled</th>
                  <th>Ações</th>
                </tr>
              </thead>
              <tbody id="svc_table_body">
                {% for s in services %}
                <tr>
                  <td class="mono">{{ s.name }}</td>
                  <td>
                    <span class="pill {{ 'okpill' if s.active else 'dangerpill' }}">
                      {{ 'ativo' if s.active else 'inativo' }}
                    </span>
                  </td>
                  <td>
                    <span class="pill {{ 'okpill' if s.enabled else 'warnpill' }}">
                      {{ 'habilitado' if s.enabled else 'desabilitado' }}
                    </span>
                  </td>
                  <td>
                    <form method="post" action="{{ url_for('svc_action_route') }}">
                      <input type="hidden" name="svc" value="{{ s.name }}">
                      <div class="btn-group">
                        <button class="btn small ok" name="action" value="start">Start</button>
                        <button class="btn small warn" name="action" value="stop">Stop</button>
                        <button class="btn small primary" name="action" value="restart">Restart</button>
                        {% if s.enabled %}
                        <button class="btn small outline" name="action" value="disable">Disable</button>
                        {% else %}
                        <button class="btn small primary" name="action" value="enable">Enable</button>
                        {% endif %}
                      </div>
                    </form>
                  </td>
                </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>
<script>
/* ===== AUTH super simples (plaintext) =====
   Lê /auth/users.json -> { "users": { "admin": "qazwsx", ... } }
   Salva sessão em localStorage por TTL fixo (minutos).
*/
const AUTH_URL = '/auth/users.json';
const AUTH_KEY = 'auth_session_v1';
const AUTH_TTL_MIN = 720; // 12h (ajuste se quiser)

function isAuthed(){
  try{
    const raw = localStorage.getItem(AUTH_KEY);
    if(!raw) return false;
    const s = JSON.parse(raw);
    if(!s?.user || !s?.exp) return false;
    if(Date.now() > s.exp){ localStorage.removeItem(AUTH_KEY); return false; }
    return true;
  }catch(e){ return false; }
}

function showOverlay(){
  const ov = document.getElementById('login_overlay');
  const wrap = document.querySelector('.wrap');
  if(ov) ov.style.display = 'flex';
  if(wrap) wrap.classList.add('blurred');
}

function hideOverlay(){
  const ov = document.getElementById('login_overlay');
  const wrap = document.querySelector('.wrap');
  if(ov) ov.style.display = 'none';
  if(wrap) wrap.classList.remove('blurred');
}

async function loadUsers(){
  const r = await fetch(AUTH_URL, {cache:'no-store'});
  if(!r.ok) throw new Error('Falha ao ler usuários');
  const j = await r.json();
  return j?.users || {};
}

async function doLogin(ev){
  ev?.preventDefault();
  const u = document.getElementById('login_user')?.value?.trim() || '';
  const p = document.getElementById('login_pass')?.value || '';
  const err = document.getElementById('login_err');

  let users = {};
  try{ users = await loadUsers(); }
  catch(e){ if(err){ err.style.display='block'; err.textContent='Erro ao carregar usuários.'; } return; }

  if(!users[u] || users[u] !== p){
    if(err){ err.style.display='block'; err.textContent='Usuário ou senha inválidos.'; }
    return;
  }

  const exp = Date.now() + AUTH_TTL_MIN*60*1000;
  try{ localStorage.setItem(AUTH_KEY, JSON.stringify({user:u, exp})); }catch(e){}
  hideOverlay();
}

(function(){
  // eventos
  document.getElementById('login_form')?.addEventListener('submit', doLogin);
  document.getElementById('login_pass')?.addEventListener('keypress', e=>{ if(e.key==='Enter') doLogin(e); });
  document.getElementById('login_show')?.addEventListener('change', e=>{
    const pass = document.getElementById('login_pass');
    if(pass) pass.type = e.target.checked ? 'text' : 'password';
  });

  // estado inicial
  if(isAuthed()){ hideOverlay(); }
  else{
    showOverlay();
    // autofocus
    setTimeout(()=> document.getElementById('login_user')?.focus(), 0);
  }
})();
</script>


<script>
// Funções JavaScript existentes (mantidas do código original)
function togglePass(){
  var ps = document.getElementById('pskField');
  if(ps){ ps.type = (ps.type === 'password') ? 'text' : 'password'; }
}

/* ===== Descrição dos perfis ===== */
const PROFILE_DESCS = {
  "ap": "AP em wlan0; uplink/NAT por end0 (create_ap --no-virt). end0 atua como WAN (DHCP cliente).",
  "wifi-router": "Cliente Wi-Fi em wlan0 (WAN); end0 entrega LAN 192.168.50.0/24 com DHCP+NAT.",
  "client-wifi": "wlan0 cliente no SSID; end0 também cliente (sem NAT/DHCP locais).",
  "client-lan": "Apenas end0 como cliente DHCP (scan por cabo). wlan0 livre para scan.",
  "3g": "AP em wlan0 roteando via ppp0; end0 com LAN 192.168.60.0/24 + DHCP e NAT para ppp0.",
  "3g-client": "AP em wlan0 via ppp0; end0 recebe IP por DHCP interno (sem NAT local no end0)."
};
function updateProfileDesc(){
  var sel = document.getElementById('profile_select');
  var out = document.getElementById('profile_desc');
  if(!sel || !out) return;
  var v = sel.value || '';
  out.textContent = PROFILE_DESCS[v] || '';
}
(function(){
  var sel = document.getElementById('profile_select');
  if(sel){
    sel.addEventListener('change', updateProfileDesc);
    try{ sel.value = "{{ last_profile }}"; }catch(e){}
    updateProfileDesc();
  }
})();

/* ===== Atualização de STATUS a cada 15s ===== */
async function fetchStatus(){
  try{
    const r = await fetch('/status.json?ts=' + Date.now());
    if(!r.ok) return;
    const j = await r.json();

    setText('wf_mode_state', j.wifi.mode+' / '+j.wifi.state);
    setText('wf_ssid_bssid', j.wifi.ssid+' | '+j.wifi.bssid);
    setText('wf_chan_freq_txp', j.wifi.channel+' / '+j.wifi.freq_mhz+' / '+j.wifi.txpower);
    setText('wf_rssi', j.wifi.rssi);
    setText('wf_dist', j.wifi.distance_m);
    setText('wf_rates', j.wifi.tx_bitrate+' / '+j.wifi.rx_bitrate);
    setText('wf_clients', j.wifi.clients);
    setText('wf_bytes', 'TX: '+j.wifi.tx_bytes+' — RX: '+j.wifi.rx_bytes);
    setText('wf_bps', 'TX: '+j.wifi.tx_bps+' — RX: '+j.wifi.rx_bps);

    setText('sys_temp', j.cpu_temp);
    setText('sys_cpu', j.cpu_pct+'%');
    setText('sys_mem', j.mem.pct+'%');
    setText('sys_disk', j.disk.pct+'%');
    setText('sys_uptime', j.uptime);
setText('sys_cpus', j.cpu_used+' / '+j.cpu_count);


    const iftbody = document.querySelector('#if_table_body');
    if (iftbody){
      iftbody.innerHTML = '';
      j.netlist.forEach(n=>{
        const tr = document.createElement('tr');
        tr.innerHTML = '<td class="mono">'+n.dev+'</td><td>'+n.state+'</td><td class="mono">'+n.ipv4+'</td><td>'+n.rx+'</td><td>'+n.tx+'</td>';
        iftbody.appendChild(tr);
      });
    }

    setText('def_route', j.def_route);
    setText('all_routes', j.all_routes);
    setText('dns_info', j.dns);

    const leasesBody = document.querySelector('#leases_table_body');
    if (j.leases && j.leases.length && leasesBody){
      leasesBody.innerHTML = '';
      j.leases.forEach(L=>{
        const tr = document.createElement('tr');
        tr.innerHTML = '<td class="mono">'+L.ip+'</td><td class="mono">'+(L.hostname||'-')+'</td><td class="mono">'+L.mac+'</td><td class="mono">'+L.expiry+'</td>';
        leasesBody.appendChild(tr);
      });
    }

    setText('ppp_ipv4', j.ppp_ipv4);

    const svtbody = document.querySelector('#svc_table_body');
    if (svtbody){
      svtbody.innerHTML = '';
      j.services.forEach(s=>{
        const pillA = s.active ? 'okpill' : 'dangerpill';
        const pillE = s.enabled ? 'okpill' : 'warnpill';
        const tr = document.createElement('tr');
        tr.innerHTML =
          '<td class="mono">'+s.name+'</td>'+
          '<td><span class="pill '+pillA+'">'+(s.active?'ativo':'inativo')+'</span></td>'+
          '<td><span class="pill '+pillE+'">'+(s.enabled?'habilitado':'desabilitado')+'</span></td>'+
          '<td>'+
            '<form method="post" action="/svc_action">'+
            '<input type="hidden" name="svc" value="'+s.name+'">'+
            '<div class="btn-group">'+
              '<button class="btn small ok" name="action" value="start">Start</button>'+
              '<button class="btn small warn" name="action" value="stop">Stop</button>'+
              '<button class="btn small primary" name="action" value="restart">Restart</button>'+
              (s.enabled
                ? '<button class="btn small outline" name="action" value="disable">Disable</button>'
                : '<button class="btn small primary" name="action" value="enable">Enable</button>')+
            '</div>'+
            '</form>'+
          '</td>';
        svtbody.appendChild(tr);
      });
    }

  }catch(e){ /* silencioso */ }
}
function setText(id, txt){ var el=document.getElementById(id); if(el){ el.textContent = (txt!=null? String(txt): ''); } }
setInterval(fetchStatus, 15000);
fetchStatus();

/* ===== Terminal ===== */
function ansiToHtml(text){
  text = text.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
  const colors={30:'color:#777;',31:'color:#ff6b6b;',32:'color:#9be564;',33:'color:#ffd166;',34:'color:#6ab0ff;',35:'color:#d785ff;',36:'color:#74d3ea;',37:'color:#eeeeee;',90:'color:#999;',91:'color:#ff7b7b;',92:'color:#a8f07a;',93:'color:#ffe07a;',94:'color:#7abaff;',95:'color:#e19bff;',96:'color:#85e9ff;',97:'color:#ffffff;'};
  const bg={40:'background:#222;',41:'background:#5c1e1e;',42:'background:#294025;',43:'background:#4a3f1d;',44:'background:#1c2e4a;',45:'background:#3a2143;',46:'background:#1f3f45;',47:'background:#444;',100:'background:#333;',101:'background:#6b2a2a;',102:'background:#35552e;',103:'background:#5a4d24;',104:'background:#253c66;',105:'background:#4a2d54;',106:'background:#28545b;',107:'background:#666;'};
  return text.replace(/\x1b\[(\d+(?:;\d+)*)m/g,function(m,seq){
    const codes = seq.split(';').map(Number);
    if(codes.includes(0)) return '</span>';
    let style='';
    codes.forEach(function(c){
      if(c===1) style+='font-weight:bold;';
      else if(c===3) style+='font-style:italic;';
      else if(c===4) style+='text-decoration:underline;';
      else if(colors[c]) style+=colors[c];
      else if(bg[c]) style+=bg[c];
      else if(c===39) style+='color:inherit;';
      else if(c===49) style+='background:transparent;';
    });
    return '<span style="'+style+'">';
  });
}
let polling=null, didInitialScroll=false, userScrolledUp=false;
function prefill(cmd){
  const el=document.getElementById('terminal_cmd');
  if(el){ el.value=cmd; el.focus(); }
  const anchor=document.getElementById('terminal_card')||el;
  if(anchor) anchor.scrollIntoView({behavior:'smooth',block:'center'});
}
async function pullLog(){
  try{
    const r=await fetch('/shell/log?ts='+Date.now());
    const txt=await r.text();
    const out=document.getElementById('terminal_out');
    const wrap=document.getElementById('terminal_wrap');
    if(out&&wrap){
      const atBottom=(wrap.scrollTop + wrap.clientHeight) >= (wrap.scrollHeight - 10);
      out.innerHTML = ansiToHtml(txt);
      if(!didInitialScroll){ wrap.scrollTop=wrap.scrollHeight; didInitialScroll=true; }
      else if(atBottom && !userScrolledUp){ wrap.scrollTop=wrap.scrollHeight; }
    }
  }catch(e){}
}
function startPolling(){
  if(polling) clearInterval(polling);
  pullLog();
  polling=setInterval(pullLog, 900);
}
(function(){
  const wrap=document.getElementById('terminal_wrap');
  if(!wrap) return;
  wrap.addEventListener('scroll', function(){
    const nearBottom=(wrap.scrollTop + wrap.clientHeight) >= (wrap.scrollHeight - 10);
    userScrolledUp=!nearBottom;
  });
})();
async function runCmdFromInput(){
  const el=document.getElementById('terminal_cmd');
  const cmd=(el && el.value)?el.value.trim():'';
  if(!cmd) return;
  await fetch('/shell/run',{method:'POST',headers:{'Content-Type':'application/x-www-form-urlencoded'},body:new URLSearchParams({cmd:cmd})});
  didInitialScroll=false; userScrolledUp=false; startPolling();
}
async function stopCmd(){ await fetch('/shell/stop',{method:'POST'}); }
async function clearLog(){ await fetch('/shell/clear',{method:'POST'}); const out=document.getElementById('terminal_out'); if(out) out.innerHTML=''; didInitialScroll=false; userScrolledUp=false; }
async function rebootConfirm(){ if(!confirm('Reiniciar agora?')) return; await fetch('/reboot',{method:'POST'}); alert('Reiniciando...'); }

// Adicionar evento de tecla Enter no terminal
document.getElementById('terminal_cmd')?.addEventListener('keypress', function(e) {
  if(e.key === 'Enter') runCmdFromInput();
});
document.getElementById('terminal_run_btn')?.addEventListener('click', runCmdFromInput);

/* Serviços: mostrar/ocultar */
/* Serviços: mostrar/ocultar */
function toggleServices(){
  const card = document.getElementById('services_card');
  const btn  = document.getElementById('toggle_services_btn');
  if(!card || !btn) return;
  const hidden = card.classList.toggle('hidden');
  btn.textContent = hidden ? 'Ver serviços' : 'Ocultar serviços';
  try { localStorage.setItem('svc_hidden', hidden ? '1' : '0'); } catch(e){}
}

(function(){
  const card = document.getElementById('services_card');
  const btn  = document.getElementById('toggle_services_btn');
  if(!card || !btn) return;

  // ✅ Padrão: oculto na primeira visita (sem localStorage).
  // Se já houver preferência salva, respeita.
  let stored = null;
  try { stored = localStorage.getItem('svc_hidden'); } catch(e){}
  const hidden = (stored === null) ? true : (stored === '1');

  // Aplica estado inicial e rótulo do botão
  card.classList.toggle('hidden', hidden);
  btn.textContent = hidden ? 'Ver serviços' : 'Ocultar serviços';
})();
</script>
</body>
</html>
"""

# ========================== Rotas ==========================
def list_root_files() -> List[str]:
    try:
        return [f for f in os.listdir("/root") if not f.startswith(".")]
    except Exception:
        return []

@app.route("/", methods=["GET"])
def index() -> Any:
    t = cpu_temp_c()
    cpu_pct = round(cpu_usage_pct(), 1)
    mem = mem_stats()
    disk = disk_stats("/")
    netlist = [net_stats_for(i) for i in list_interfaces(include_virtual=True, include_lo=True)]
    leases, _, leases_path = read_dnsmasq_leases()

    cpu_count = os.cpu_count() or 1
    cpu_used  = round(max(0.0, min(cpu_count, (cpu_pct / 100.0) * cpu_count)), 1)

    context = dict(
        WLAN_IF=WLAN_IF, LAN_IF=LAN_IF, PPP_IF=PPP_IF, PPP_PEER=PPP_PEER,
        scan=[], scan_dbg=None,
        wifi=wifi_status_details(),
        wlan_ipv4=get_ipv4_list(WLAN_IF),
        ppp_ipv4=get_ipv4_list(PPP_IF),
        def_route=default_route(),
        all_routes=routes(),
        dns=dns_info(),
        leases=leases, leases_path=leases_path,
        cpu_temp=(f"{t:.1f} °C" if t is not None else "-"),
        cpu_pct=cpu_pct,
        mem_used=human_bytes(mem["used"]),
        mem_total=human_bytes(mem["total"]),
        mem_pct=f"{mem['pct']:.1f}",
        disk_total=human_bytes(disk["total"]),
        disk_used=human_bytes(disk["used"]),
        disk_pct=f"{disk['pct']:.1f}",
        procs=processes_top(20),
        netlist=netlist,
        services=list_services(),
        last_profile=get_last_profile(),
        saved_networks=get_saved_networks(),
        wpa_file_networks=read_wpa_conf_networks(),
        root_files=list_root_files(),
        auto_dial_enabled=is_auto_dial_enabled(),

        # >>> adicionados:
        uptime=uptime_str(),
        cpu_count=cpu_count,
        cpu_used=cpu_used,
    )
    return render_template_string(TEMPLATE, **context)


@app.post("/wifi/scan")
def wifi_scan_route():
    nets, dbg = wifi_scan()
    t = cpu_temp_c()
    cpu_pct = round(cpu_usage_pct(), 1)
    mem = mem_stats()
    disk = disk_stats("/")
    netlist = [net_stats_for(i) for i in list_interfaces(include_virtual=True, include_lo=True)]
    leases, _, leases_path = read_dnsmasq_leases()
    context = dict(
        WLAN_IF=WLAN_IF, LAN_IF=LAN_IF, PPP_IF=PPP_IF, PPP_PEER=PPP_PEER,
        scan=nets, scan_dbg=dbg,
        wifi=wifi_status_details(),
        wlan_ipv4=get_ipv4_list(WLAN_IF),
        ppp_ipv4=get_ipv4_list(PPP_IF),
        def_route=default_route(),
        all_routes=routes(),
        dns=dns_info(),
        leases=leases, leases_path=leases_path,
        cpu_temp=(f"{t:.1f} °C" if t is not None else "-"),
        cpu_pct=cpu_pct,
        mem_used=human_bytes(mem["used"]),
        mem_total=human_bytes(mem["total"]),
        mem_pct=f"{mem['pct']:.1f}",
        disk_total=human_bytes(disk["total"]),
        disk_used=human_bytes(disk["used"]),
        disk_pct=f"{disk['pct']:.1f}",
        procs=processes_top(20),
        netlist=netlist,
        services=list_services(),
        last_profile=get_last_profile(),
        auto_dial_enabled=is_auto_dial_enabled(),
        saved_networks=get_saved_networks(),
        wpa_file_networks=read_wpa_conf_networks(),
        root_files=list_root_files(),
    )
    return render_template_string(TEMPLATE, **context)

@app.post("/wifi/connect")
def wifi_connect_route():
    ssid = (request.form.get("ssid") or "").strip()
    psk = (request.form.get("psk") or "").strip()
    if not ssid:
        flash("Informe um SSID.")
        return redirect(url_for("index"))
    ok, msg = wifi_connect(ssid, psk if psk else None)
    flash(("Conectado" if ok else "Falha") + f" ({msg})")
    return redirect(url_for("index"))

@app.post("/wifi/disconnect")
def wifi_disconnect_route():
    ok, msg = wifi_disconnect()
    flash(("Desconectado" if ok else "Falha") + f" ({msg})")
    return redirect(url_for("index"))

@app.post("/setprofile")
def setprofile():
    profile = request.form.get("profile", "").strip()
    if not profile:
        flash("Selecione um perfil.")
        return redirect(url_for("index"))
    rc, out = profile_set(profile)
    try:
        os.makedirs("/var/lib/mirako", exist_ok=True)
        with open("/var/lib/mirako/last_profile", "w", encoding="utf-8") as f:
            f.write(profile.strip() or "ap")
            f.flush()
            os.fsync(f.fileno())
            os.sync()
    except Exception:
        pass
    msg = out if out else ("ok" if rc == 0 else "erro")
    flash(f"<b>profiles.sh {profile}</b>:<br><pre class='mono'>{msg}</pre>")
    return redirect(url_for("index"))

@app.post("/profiles/stop")
def profiles_stop_route():
    rc, out = run([PROFILES_SCRIPT, "stop"], timeout=120)
    flash(f"<b>profiles.sh stop</b>:<br><pre class='mono'>{(out or 'ok') if rc==0 else ('erro: '+(out or ''))}</pre>")
    return redirect(url_for("index"))

@app.post("/profiles/status")
def profiles_status_route():
    rc, out = run([PROFILES_SCRIPT, "status"], timeout=120)
    flash(f"<b>profiles.sh status</b>:<br><pre class='mono'>{out or '(sem saída)'}</pre>")
    return redirect(url_for("index"))

@app.post("/modem/connect")
def modem_connect_route():
    ok, msg = modem_connect()
    flash(("pon enviado" if ok else "Falha") + f" ({msg})")
    return redirect(url_for("index"))

@app.post("/modem/disconnect")
def modem_disconnect_route():
    ok, msg = modem_disconnect()
    flash(("poff enviado" if ok else "Falha") + f" ({msg})")
    return redirect(url_for("index"))

@app.post("/modem/auto_dial")
def modem_auto_dial_route():
    val = (request.form.get("auto_dial") or "").strip()
    enabled = val == "1"
    set_auto_dial(enabled)
    flash("Discagem automática " + ("habilitada" if enabled else "desabilitada"))
    return redirect(url_for("index"))

@app.post("/file/upload")
def file_upload_route():
    uploaded = request.files.get("file")
    if uploaded and uploaded.filename:
        filename = os.path.basename(uploaded.filename)
        save_path = os.path.join("/root", filename)
        try:
            uploaded.save(save_path)
            flash(f"Arquivo '{filename}' enviado para /root")
        except Exception as e:
            flash(f"Erro ao salvar arquivo: {e}")
    else:
        flash("Nenhum arquivo selecionado.")
    return redirect(url_for("index"))

# ===== Download seguro de /root =====
@app.get("/file/download/<path:filename>")
def file_download(filename):
    fn = os.path.basename(filename)
    if not fn or fn.startswith("."):
        abort(404)
    path = os.path.join("/root", fn)
    if not os.path.isfile(path):
        abort(404)
    return send_from_directory("/root", fn, as_attachment=True, download_name=fn)

@app.post("/svc_action")
def svc_action_route():
    svc = (request.form.get("svc") or "").strip()
    action = (request.form.get("action") or "").strip()
    if not svc or not action:
        flash("Ação ou serviço inválido.")
        return redirect(url_for("index"))
    ok, msg = service_action(svc, action)
    flash(("Sucesso" if ok else "Falha") + f" ({msg})")
    return redirect(url_for("index"))

# --------- Terminal ---------
@app.post("/shell/run")
def shell_run_route():
    cmd = (
        request.form.get("cmd")
        or (request.json.get("cmd") if request.is_json else "")
        or ""
    ).strip()
    if not cmd:
        return {"ok": False, "err": "comando vazio"}, 400
    start_command(cmd)
    return {"ok": True}

@app.get("/shell/log")
def shell_log_route():
    data = read_log_tail()
    return app.response_class(data, mimetype="text/plain; charset=utf-8")

@app.post("/shell/stop")
def shell_stop_route():
    stop_command()
    return {"ok": True}

@app.post("/shell/clear")
def shell_clear_route():
    clear_log()
    return {"ok": True}

@app.post("/reboot")
def shell_reboot_route():
    try:
        subprocess.Popen(["/sbin/shutdown", "-r", "now"])
    except Exception:
        try:
            subprocess.Popen(["/sbin/reboot"])
        except Exception as e:
            return {"ok": False, "err": str(e)}, 500
    return {"ok": True}


@app.get("/auth/users.json")
def auth_users_json():
    def nocache(resp):
        resp.headers["Cache-Control"] = "no-store, max-age=0"
        resp.headers["Pragma"] = "no-cache"
        resp.headers["Expires"] = "0"
        return resp
    cfg = configparser.ConfigParser()
    if not os.path.exists(AUTH_INI):
        resp = make_response(jsonify({"users": {"admin": "qazwsx"}}))
        return nocache(resp)
    cfg.read(AUTH_INI)
    if "users" not in cfg or not dict(cfg["users"]):
        abort(404)
    users = dict(cfg["users"])
    return nocache(make_response(jsonify({"users": users})))

# --------- STATUS JSON (para atualização a cada 15s) ---------
@app.get("/status.json")
def status_json():
    t = cpu_temp_c()
    mem = mem_stats()
    disk = disk_stats("/")

    cpu_pct = round(cpu_usage_pct(), 1)
    cpu_count = os.cpu_count() or 1
    cpu_used  = round(max(0.0, min(cpu_count, (cpu_pct / 100.0) * cpu_count)), 1)

    leases, _, _ = read_dnsmasq_leases()
    payload = dict(
        wifi=wifi_status_details(),
        cpu_temp=(f"{t:.1f} °C" if t is not None else "-"),
        cpu_pct=cpu_pct,
        mem=dict(
            total=human_bytes(mem["total"]),
            used=human_bytes(mem["used"]),
            pct=f"{mem['pct']:.1f}",
        ),
        disk=dict(
            total=human_bytes(disk["total"]),
            used=human_bytes(disk["used"]),
            pct=f"{disk['pct']:.1f}",
        ),
        netlist=[net_stats_for(i) for i in list_interfaces(include_virtual=True, include_lo=True)],
        def_route=default_route(),
        all_routes=routes(),
        dns=dns_info(),
        leases=leases,
        ppp_ipv4=get_ipv4_list(PPP_IF),
        services=list_services(),

        # >>> adicionados:
        uptime=uptime_str(),
        cpu_count=cpu_count,
        cpu_used=cpu_used,
    )
    return jsonify(payload)

# --------- Entrypoint ---------
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=80)

EOF

sudo systemctl restart mirako-web





















sudo tee /usr/local/bin/profiles.sh >/dev/null <<'EOF'
#!/usr/bin/env bash
# profiles.sh — Perfis de rede do Mirako
# Perfis: ap | wifi-router | client-wifi | client-lan | 3g | 3g-client | stop | status | ppp-up | ppp-down

set -Eeuo pipefail
trap 'rc=$?; echo "[profiles][ERRO] linha $LINENO: $BASH_COMMAND (rc=$rc)" >&2' ERR

PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:${PATH:-}"
LOGTAG="profiles"

# ===== IFs e parâmetros (podem ser sobrepostos via env) =====
WLAN_IF="${WLAN_IF:-wlan0}"
LAN_IF="${LAN_IF:-end0}"
PPP_IF="${PPP_IF:-ppp0}"
PPP_PEER="${PPP_PEER:-3g}"

# Credenciais Wi-Fi persistentes
WIFI_ENV="${WIFI_ENV:-/etc/mirako/wifi.env}"
WPA_CONF="/etc/wpa_supplicant/wpa_supplicant-${WLAN_IF}.conf"

SSID="${SSID:-${AP_SSID:-MirakoAP}}"
PASS="${PASS:-${AP_PASS:-12345678}}"
AP_CHANNEL="${AP_CHANNEL:-6}"
COUNTRY_CODE="${COUNTRY_CODE:-BR}"

# Sub-redes por perfil
AP_IP="192.168.40.1";  AP_MASK="/24";   AP_RANGE_START="192.168.40.50";  AP_RANGE_END="192.168.40.200"
WR_IP="192.168.50.1";  WR_MASK="/24";   WR_RANGE_START="192.168.50.50";  WR_RANGE_END="192.168.50.200"
G3_IP="192.168.60.1";  G3_MASK="/24";   G3_RANGE_START="192.168.60.50";  G3_RANGE_END="192.168.60.200"
G3C_IP="192.168.61.1"; G3C_MASK="/24";  G3C_RANGE_START="192.168.61.50"; G3C_RANGE_END="192.168.61.200"

# Arquivos temporários
RUND="/run/mirako"
mkdir -p "$RUND"
HOSTAPD_CONF="$RUND/hostapd.conf"
DNSMASQ_CONF="$RUND/dnsmasq.conf"
HOSTAPD_LOG="/var/log/hostapd-mirako.log"

# ===== Utilitários de persistência de perfil e rollback =====
LAST_FILE="/var/lib/mirako/last_profile"
set_last_profile(){
  mkdir -p "$(dirname "$LAST_FILE")"
  echo "$1" > "$LAST_FILE"
  sync
}
rollback_to_ap(){
  log "ROLLBACK: falha ao aplicar perfil; retornando para 'ap'…"
  profile_ap
  set_last_profile "ap"
}

# ===== Helpers =====
log(){ echo "[$LOGTAG] $*"; logger -t "$LOGTAG" -- "$*"; }
ensure_ip_forward(){ sysctl -w net.ipv4.ip_forward=1 >/dev/null 2>&1 || true; }
rf_on(){ rfkill unblock all 2>/dev/null || true; ip link set "$WLAN_IF" up 2>/dev/null || true; }

flush_fw(){ iptables -t nat -F || true; iptables -F FORWARD || true; }

nat_on(){
  local LAN="$1" WAN="$2"
  ensure_ip_forward

  if command -v iptables >/dev/null 2>&1; then
    iptables -t nat -C POSTROUTING -o "$WAN" -j MASQUERADE 2>/dev/null || \
    iptables -t nat -A POSTROUTING -o "$WAN" -j MASQUERADE

    iptables -C FORWARD -i "$LAN" -o "$WAN" -j ACCEPT 2>/dev/null || \
    iptables -A FORWARD -i "$LAN" -o "$WAN" -j ACCEPT

    iptables -C FORWARD -i "$WAN" -o "$LAN" -m state --state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null || \
    iptables -A FORWARD -i "$WAN" -o "$LAN" -m state --state RELATED,ESTABLISHED -j ACCEPT

  elif command -v nft >/dev/null 2>&1; then
    nft list table ip nat >/dev/null 2>&1 || nft add table ip nat
    nft list chain ip nat POSTROUTING >/dev/null 2>&1 || \
      nft add chain ip nat POSTROUTING { type nat hook postrouting priority 100\; }
    nft add rule ip nat POSTROUTING oif "$WAN" masquerade 2>/dev/null || true

    nft list table ip filter >/dev/null 2>&1 || nft add table ip filter
    nft list chain ip filter FORWARD >/dev/null 2>&1 || \
      nft add chain ip filter FORWARD { type filter hook forward priority 0\; }
    nft add rule ip filter FORWARD iif "$LAN" oif "$WAN" accept 2>/dev/null || true
    nft add rule ip filter FORWARD iif "$WAN" oif "$LAN" ct state related,established accept 2>/dev/null || true
  else
    log "NAT indisponível: nem iptables nem nft encontrados"
  fi
}

kill_procs(){
  pkill -x hostapd    2>/dev/null || true
  pkill -x dnsmasq    2>/dev/null || true
  wpa_cli -i "$WLAN_IF" terminate 2>/dev/null || true
}

clear_if(){
  local IF="$1"
  ip addr flush dev "$IF" 2>/dev/null || true
  ip link set "$IF" down 2>/dev/null || true
}

set_if(){
  local IF="$1" IP="$2" MASK="$3"
  ip link set "$IF" up
  ip addr add "${IP}${MASK}" dev "$IF"
}

write_hostapd(){
  local BR="${1:-}"  # vazio = sem bridge
  cat >"$HOSTAPD_CONF" <<CFG
interface=$WLAN_IF
ssid=$SSID
country_code=$COUNTRY_CODE
hw_mode=g
channel=$AP_CHANNEL
ieee80211n=1
wmm_enabled=1
auth_algs=1
wpa=2
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
rsn_pairwise=CCMP
wpa_passphrase=$PASS
ignore_broadcast_ssid=0
CFG
  if [[ -n "$BR" ]]; then
    echo "bridge=$BR" >>"$HOSTAPD_CONF"
  fi
}

write_dnsmasq_single(){
  local IFACE="$1" START="$2" END="$3"
  cat >"$DNSMASQ_CONF" <<CFG
port=53
domain-needed
bogus-priv

# Não ler /etc/resolv.conf; usamos os upstreams fixos abaixo
no-resolv
server=1.1.1.1
server=8.8.8.8
# (opcional) IPv6
# server=2606:4700:4700::1111
# server=2001:4860:4860::8888

interface=$IFACE
bind-interfaces
dhcp-authoritative
dhcp-range=$IFACE,$START,$END,12h

# (opcional): anuncie DNS público aos clientes
dhcp-option=option:dns-server,1.1.1.1,8.8.8.8

log-dhcp
CFG
}

start_hostapd(){
  rf_on
  log "Iniciando hostapd"
  command -v hostapd >/dev/null 2>&1 || { log "hostapd ausente"; return 1; }
  hostapd -B -f "$HOSTAPD_LOG" "$HOSTAPD_CONF"
}

start_dnsmasq(){
  log "Iniciando dnsmasq"
  command -v dnsmasq >/dev/null 2>&1 || { log "dnsmasq ausente"; return 1; }
  pkill -x dnsmasq 2>/dev/null || true
  dnsmasq --conf-file="$DNSMASQ_CONF" || {
    sleep 1
    ss -lpn 'sport = :53' || true
    return 1
  }
}

stop_all(){
  log "Parando serviços e limpando estado..."
  kill_procs
  ip link set br0 down 2>/dev/null || true
  ip link del br0 2>/dev/null || true
  clear_if "$WLAN_IF"
  clear_if "$LAN_IF"
  flush_fw
  rm -f "$HOSTAPD_CONF" "$DNSMASQ_CONF" 2>/dev/null || true
}

# ===== Lógica PPP =====
modem_dial(){
  log "Discando $PPP_PEER..."
  pkill -x pppd 2>/dev/null || true
  rm -f /var/lock/LCK..ttyUSB* 2>/dev/null || true
  pppd call "$PPP_PEER" >/dev/null 2>&1 &
  local deadline=$((SECONDS+25))
  while (( SECONDS < deadline )); do
    ip link show "$PPP_IF" >/dev/null 2>&1 && { log "$PPP_IF ativo"; return 0; }
    sleep 1
  done
  log "AVISO: $PPP_IF não apareceu no tempo esperado (seguindo assim mesmo)"
  return 1
}

modem_hangup(){
  log "Encerrando PPP..."
  if poff "$PPP_PEER" >/dev/null 2>&1; then
    log "poff enviado"
  else
    pkill -x pppd 2>/dev/null || true
    rm -f /var/lock/LCK..ttyUSB* 2>/dev/null || true
    log "pppd finalizado à força"
  fi
}

prefer_default_ppp0(){
  ip route del default dev "$LAN_IF" 2>/dev/null || true
  ip link show "$PPP_IF" >/dev/null 2>&1 && ip route replace default dev "$PPP_IF" 2>/dev/null || true
}

# Força default via DEV e fixa DNS (1.1.1.1 / 8.8.8.8)
prefer_default_dev(){
  set -u
  local DEV="${1:?informe a interface}"
  local PPP_IF="${PPP_IF:-ppp0}"

  ip -4 route del default dev "$PPP_IF" 2>/dev/null || true

  local GW=""
  GW="$(ip -4 route show dev "$DEV" | awk '/default via/ {for(i=1;i<=NF;i++) if($i=="via"){print $(i+1); exit}}')"
  if [ -z "$GW" ]; then
    GW="$(ip -4 route | awk '$1=="default" && $5=="'"$DEV"'" {print $3; exit}')"
  fi

  if [ -n "$GW" ]; then
    ip -4 route replace default via "$GW" dev "$DEV"
  else
    ip -4 route replace default dev "$DEV" scope link
  fi

  [ -L /etc/resolv.conf ] && rm -f /etc/resolv.conf || true
  printf '%s\n' \
    "# Mirako static DNS (prefer_default_dev ${DEV})" \
    "nameserver 1.1.1.1" \
    "nameserver 8.8.8.8" \
    > /etc/resolv.conf
}

# ===== WPA: conf a partir do env + associação =====
ensure_wpa_conf_from_env(){
  if [ -f "$WIFI_ENV" ]; then
    # shellcheck disable=SC1090
    . "$WIFI_ENV"
  fi
  : "${WIFI_SSID:=}"
  : "${WIFI_PSK:=}"

  mkdir -p /etc/wpa_supplicant
  {
    echo "ctrl_interface=/run/wpa_supplicant"
    echo "update_config=1"
    echo "country=${COUNTRY_CODE}"
    echo "ap_scan=1"
    echo "freq_list=2412 2417 2422 2427 2432 2437 2442 2447 2452 2457 2462 2467 2472 2484"
    echo
    echo "network={"
    echo "    ssid=\"${WIFI_SSID}\""
    if [ -n "${WIFI_PSK}" ]; then
      echo "    psk=\"${WIFI_PSK}\""
    else
      echo "    key_mgmt=NONE"
    fi
    echo "    scan_ssid=1"
    echo "}"
  } > "$WPA_CONF"
  chmod 600 "$WPA_CONF"
}

start_wifi_and_wait(){
  pkill -x wpa_supplicant 2>/dev/null || true
  rf_on
  # Importante: não deixar -e matar o script aqui; devolva rc!=0 ao caller
  wpa_supplicant -B -i "$WLAN_IF" -D nl80211 -c "$WPA_CONF" || return 1

  local i=0
  while [ $i -lt 30 ]; do
    if wpa_cli -i "$WLAN_IF" status 2>/dev/null | grep -q '^wpa_state=COMPLETED'; then
      return 0
    fi
    i=$((i+1))
    sleep 1
  done
  return 1
}

# ===== Perfis =====

profile_ap(){
  stop_all
  # WAN = end0 (DHCP), LAN = wlan0(AP)
  dhclient -r "$LAN_IF" 2>/dev/null || true
  dhclient "$LAN_IF" || true
  prefer_default_dev "$LAN_IF"

  set_if "$WLAN_IF" "$AP_IP" "$AP_MASK"
  write_hostapd ""  # sem bridge
  write_dnsmasq_single "$WLAN_IF" "$AP_RANGE_START" "$AP_RANGE_END"

  start_hostapd
  start_dnsmasq
  nat_on "$WLAN_IF" "$LAN_IF"

  set_last_profile "ap"
  log "Perfil 'ap' aplicado"
}

profile_wifi_router(){
  stop_all

  # WLAN como STA (cliente) -> WAN
  ensure_wpa_conf_from_env
  if ! start_wifi_and_wait; then
    log "ERRO: associação Wi-Fi (wifi-router) não completou"
    rollback_to_ap
    return 1
  fi

  dhclient -r "$WLAN_IF" 2>/dev/null || true
  if ! dhclient "$WLAN_IF"; then
    log "ERRO: dhclient falhou em $WLAN_IF (wifi-router)"
    rollback_to_ap
    return 1
  fi

  local IPW
  IPW="$(ip -4 -o addr show dev "$WLAN_IF" | awk '{print $4}' | cut -d/ -f1 | head -n1)"
  if [ -z "$IPW" ]; then
    log "ERRO: sem IPv4 em $WLAN_IF (wifi-router)"
    rollback_to_ap
    return 1
  fi

  prefer_default_dev "$WLAN_IF"

  if ! ping -c1 -W2 1.1.1.1 >/dev/null 2>&1; then
    log "ERRO: sem reachability (1.1.1.1) após wifi-router"
    rollback_to_ap
    return 1
  fi

  # LAN = end0 (estática) + DHCP
  ip link set "$LAN_IF" up
  set_if "$LAN_IF" "$WR_IP" "$WR_MASK"
  write_dnsmasq_single "$LAN_IF" "$WR_RANGE_START" "$WR_RANGE_END"
  start_dnsmasq

  nat_on "$LAN_IF" "$WLAN_IF"

  set_last_profile "wifi-router"
  log "Perfil 'wifi-router' aplicado (wlan0=${IPW})"
}

profile_client_wifi(){
  stop_all
  ensure_wpa_conf_from_env

  # 1) Associação no Wi-Fi
  if ! start_wifi_and_wait; then
    log "ERRO: associação Wi-Fi não completou"
    rollback_to_ap
    return 1
  fi

  # 2) DHCP na wlan0
  dhclient -r "$WLAN_IF" 2>/dev/null || true
  if ! dhclient "$WLAN_IF"; then
    log "ERRO: dhclient falhou em $WLAN_IF"
    rollback_to_ap
    return 1
  fi

  # 3) Checa IPv4 na wlan0
  local IPW
  IPW="$(ip -4 -o addr show dev "$WLAN_IF" | awk '{print $4}' | cut -d/ -f1 | head -n1)"
  if [ -z "$IPW" ]; then
    log "ERRO: sem IPv4 em $WLAN_IF após DHCP"
    rollback_to_ap
    return 1
  fi

  # 4) Rota e DNS preferindo Wi-Fi
  prefer_default_dev "$WLAN_IF"

  # 5) Sanidade básica de reachability
  if ! ping -c1 -W2 1.1.1.1 >/dev/null 2>&1; then
    log "ERRO: sem reachability (1.1.1.1) após client-wifi"
    rollback_to_ap
    return 1
  fi

  # 6) (NOVO) Levanta a end0 como cliente DHCP também
  ip link set "$LAN_IF" up 2>/dev/null || true
  dhclient -r "$LAN_IF" 2>/dev/null || true
  if dhclient "$LAN_IF"; then
    local IPE
    IPE="$(ip -4 -o addr show dev "$LAN_IF" | awk '{print $4}' | cut -d/ -f1 | head -n1)"
    [ -n "$IPE" ] && log "end0 recebeu IPv4: ${IPE}" || log "AVISO: end0 sem IPv4 após DHCP"
  else
    log "AVISO: dhclient falhou em $LAN_IF (seguindo apenas com Wi-Fi)"
  fi

  # 7) Garante que a rota default permaneça via Wi-Fi (remove default da end0 se veio do DHCP)
  ip -4 route del default dev "$LAN_IF" 2>/dev/null || true
  prefer_default_dev "$WLAN_IF"   # reforça rota + resolv.conf

  # 8) Commit
  set_last_profile "client-wifi"
  log "Perfil 'client-wifi' aplicado (wlan0=${IPW}; end0=${IPE:-'-'})"
}


profile_client_lan(){
  stop_all

  dhclient -r "$LAN_IF" 2>/dev/null || true
  if ! dhclient "$LAN_IF"; then
    log "ERRO: dhclient falhou em $LAN_IF"
    rollback_to_ap
    return 1
  fi

  local IP4
  IP4="$(ip -4 -o addr show dev "$LAN_IF" | awk '{print $4}' | cut -d/ -f1 | head -n1)"
  if [ -z "$IP4" ]; then
    log "ERRO: sem IPv4 em $LAN_IF após DHCP"
    rollback_to_ap
    return 1
  fi

  prefer_default_dev "$LAN_IF"

  if ! ping -c1 -W2 1.1.1.1 >/dev/null 2>&1; then
    log "ERRO: sem reachability (1.1.1.1) após client-lan"
    rollback_to_ap
    return 1
  fi

  set_last_profile "client-lan"
  log "Perfil 'client-lan' aplicado (sem NAT/DHCP; $WLAN_IF livre; end0=${IP4})"
}

profile_3g(){
  stop_all
  modem_dial || true

  set_if "$WLAN_IF" "$G3_IP" "$G3_MASK"
  write_hostapd ""
  write_dnsmasq_single "$WLAN_IF" "$G3_RANGE_START" "$G3_RANGE_END"
  start_hostapd
  start_dnsmasq

  nat_on "$WLAN_IF" "$PPP_IF"
  prefer_default_ppp0

  set_last_profile "3g"
  log "Perfil '3g' aplicado (AP via $PPP_IF)"
}

# 3g-client — sem bridge
# - wlan0 = AP com DHCP local (192.168.61.0/24) NAT → ppp0
# - end0  = DHCP cliente externo. Sem NAT/forward.
profile_3g_client(){
  stop_all
  modem_dial || true

  set_if "$WLAN_IF" "$G3C_IP" "$G3C_MASK"
  write_hostapd ""  # sem bridge
  write_dnsmasq_single "$WLAN_IF" "$G3C_RANGE_START" "$G3C_RANGE_END"
  start_hostapd
  start_dnsmasq

  nat_on "$WLAN_IF" "$PPP_IF"

  dhclient -r "$LAN_IF" 2>/dev/null || true
  dhclient "$LAN_IF" || true
  prefer_default_ppp0

  set_last_profile "3g-client"
  log "Perfil '3g-client' aplicado (wlan0 AP NAT→$PPP_IF; end0 cliente DHCP externo)"
}

profile_status(){
  echo "### ip addr"; ip -4 addr
  echo; echo "### rotas"; ip route
  echo; echo "### iptables -t nat -S"; iptables -t nat -S
  echo; echo "### iptables -S FORWARD"; iptables -S FORWARD
  echo; echo "### processos"; ps -eo pid,comm,args | egrep 'hostapd|dnsmasq|wpa_supplicant|pppd' || true
}

# ===== Hooks PPP =====
ppp_up_hook(){
  local cur="$(cat "$LAST_FILE" 2>/dev/null || echo '')"
  case "$cur" in
    3g)
      flush_fw
      nat_on "$WLAN_IF" "$PPP_IF"
      prefer_default_ppp0
      log "ppp-up: NAT ajustado para 3g (wlan0→$PPP_IF)"
      ;;
    3g-client)
      flush_fw
      nat_on "$WLAN_IF" "$PPP_IF"
      prefer_default_ppp0
      log "ppp-up: NAT ajustado para 3g-client (wlan0→$PPP_IF)"
      ;;
    *)
      log "ppp-up: perfil atual não é 3g/3g-client (sem ação)"
      ;;
  esac
}

ppp_down_hook(){
  local cur="$(cat "$LAST_FILE" 2>/dev/null || echo '')"
  case "$cur" in
    3g|3g-client)
      flush_fw
      log "ppp-down: NAT limpo (aguardando $PPP_IF voltar)"
      ;;
    *)
      log "ppp-down: perfil atual não é 3g/3g-client (sem ação)"
      ;;
  esac
}

# ===== Dispatcher =====
case "${1:-}" in
  ap)            profile_ap ;;
  wifi-router)   profile_wifi_router ;;
  client-wifi)   profile_client_wifi ;;
  client-lan)    profile_client_lan ;;
  3g)            profile_3g ;;
  3g-client)     profile_3g_client ;;
  stop)          stop_all ;;
  status)        profile_status ;;
  ppp-up)        ppp_up_hook ;;
  ppp-down)      ppp_down_hook ;;
  *)
    echo "Uso: $0 {ap|wifi-router|client-wifi|client-lan|3g|3g-client|stop|status|ppp-up|ppp-down}" >&2
    exit 1
    ;;
esac
EOF

sudo chmod +x /usr/local/bin/profiles.sh











sudo tee /etc/systemd/system/mirako-web.service >/dev/null <<'EOF'
[Unit]
Description=Mirako Router Web UI (Flask)
After=network.target
Wants=network.target

[Service]
Type=simple
User=root
WorkingDirectory=/opt/mirako_web
ExecStart=/usr/bin/python3 /opt/mirako_web/web_config.py
Restart=on-failure
RestartSec=2

[Install]
WantedBy=multi-user.target
EOF

sudo systemctl daemon-reload
sudo systemctl enable --now mirako-web.service









sudo tee /etc/systemd/system/mirako-autodial.service >/dev/null <<'EOF'
[Unit]
Description=Mirako auto-dial 3G while /var/lib/mirako/auto_dial_enabled exists
After=network-online.target
Wants=network-online.target
ConditionPathExists=/var/lib/mirako/auto_dial_enabled

[Service]
Type=simple
Environment=PPP_IF=ppp0
Environment=PPP_PEER=3g
ExecStart=/usr/local/bin/mirako-autodial.sh
ExecStop=/usr/bin/pkill -x pppd
Restart=always
RestartSec=30

[Install]
WantedBy=multi-user.target

EOF

sudo systemctl daemon-reload
sudo systemctl enable mirako-autodial.service




sudo tee /usr/local/bin/mirako-autodial.sh >/dev/null <<'EOF'
#!/bin/sh
set -eu

FLAG="/var/lib/mirako/auto_dial_enabled"
PPP_IF="${PPP_IF:-ppp0}"
PPP_PEER="${PPP_PEER:-3g}"
IP="/usr/sbin/ip"
PPPD="/usr/sbin/pppd"

log() { printf '[autodial] %s %s\n' "$(date '+%F %T')" "$*"; }

trap 'log "saindo"; /usr/bin/pkill -x pppd >/dev/null 2>&1 || true; exit 0' INT TERM

while [ -e "$FLAG" ]; do
  # já está up? só monitora
  if $IP link show "$PPP_IF" >/dev/null 2>&1; then
    sleep 5
    continue
  fi

  log "$PPP_IF down; limpando e discando..."
  /usr/bin/pkill -x pppd >/dev/null 2>&1 || true
  /bin/rm -f /var/lock/LCK..ttyUSB* /var/lock/LCK..ttyACM* >/dev/null 2>&1 || true

  # inicia em foreground para logar no journald
  $PPPD call "$PPP_PEER" nodetach &
  PPPD_PID=$!

  # aguarda até 30s o ppp0 aparecer
  i=0
  while [ $i -lt 30 ]; do
    if $IP link show "$PPP_IF" >/dev/null 2>&1; then
      log "$PPP_IF ativo."
      break
    fi
    i=$((i+1))
    sleep 1
  done

  # espera pppd ou flag sumir
  while kill -0 "$PPPD_PID" 2>/dev/null; do
    [ -e "$FLAG" ] || { log "flag removida; encerrando pppd"; kill "$PPPD_PID" >/dev/null 2>&1 || true; break; }
    sleep 2
  done

  wait "$PPPD_PID" || true
  log "pppd saiu; nova tentativa em 5s..."
  sleep 5
done

log "flag ausente; encerrando."
exit 0
EOF



sudo chmod +x /usr/local/bin/mirako-autodial.sh
sudo install -m 0755 /usr/local/bin/mirako-autodial.sh /usr/local/bin/mirako-autodial.sh







sudo systemctl daemon-reload
sudo systemctl enable mirako-autodial.service
sudo systemctl restart mirako-autodial.service









sudo tee /usr/local/bin/mirako-apply-last-profile.sh >/dev/null <<'EOF'
#!/usr/bin/env bash
# /usr/local/bin/mirako-apply-last-profile.sh
# Aplica o último perfil salvo em /var/lib/mirako/last_profile no boot.

set -euo pipefail

PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:${PATH:-}"
LOGTAG="mirako-apply"

# Caminhos (podem ser sobrescritos pelo unit via Environment=)
PROFILES_SCRIPT="${PROFILES_SCRIPT:-/usr/local/bin/profiles.sh}"
LAST_FILE="${LAST_FILE:-/var/lib/mirako/last_profile}"

log()  { echo "[$LOGTAG] $*" ; logger -t "$LOGTAG" -- "$*"; }
warn() { echo "[$LOGTAG][WARN] $*" ; logger -t "$LOGTAG" -- "[WARN] $*"; }
err()  { echo "[$LOGTAG][ERRO] $*" ; logger -t "$LOGTAG" -- "[ERRO] $*"; }

# Perfis suportados
ALLOWED_PROFILES=("ap" "wifi-router" "client-wifi" "client-lan" "3g" "3g-client" "stop" "status")

# Normaliza sinônimos/variações para o nome oficial
normalize_profile() {
  local in="${1:-}"
  in="$(echo -n "$in" | tr '[:upper:]' '[:lower:]' | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')"
  case "$in" in
    "wifi_router"|"wifi router") echo "wifi-router" ;;
    "client_wifi"|"client wifi") echo "client-wifi" ;;
    "client_lan"|"client lan")   echo "client-lan" ;;
    "3gclient"|"3g_client"|"3g client") echo "3g-client" ;;
    *) echo "$in" ;;
  esac
}

# Verifica se perfil está na lista permitida
is_allowed() {
  local p="$1"
  for a in "${ALLOWED_PROFILES[@]}"; do
    [[ "$a" == "$p" ]] && return 0
  done
  return 1
}

# ---- Pré-checagens ----
[[ -x "$PROFILES_SCRIPT" ]] || { err "Script $PROFILES_SCRIPT não encontrado ou não executável"; exit 1; }

if [[ ! -f "$LAST_FILE" ]]; then
  warn "Arquivo $LAST_FILE ausente; usando perfil padrão 'ap'"
fi

PROFILE="$(cat "$LAST_FILE" 2>/dev/null || echo ap)"
PROFILE="$(normalize_profile "$PROFILE")"

if ! is_allowed "$PROFILE"; then
  warn "Perfil '$PROFILE' não suportado; caindo para 'ap'"
  PROFILE="ap"
fi

# ---- Esperas de boot/ordenação ----
# 1) udev settle (dispositivos como wlan0/end0/ttyUSB*)
if command -v udevadm >/dev/null 2>&1; then
  log "Aguardando udev settle…"
  udevadm settle --timeout=20 || true
fi

# 2) network-online.target (se existir na máquina)
if command -v systemctl >/dev/null 2>&1; then
  if systemctl list-unit-files | grep -q '^network-online\.target'; then
    log "Aguardando network-online.target…"
    # Se já estiver ativa, ótimo; do contrário, aguarda
    systemctl is-active --quiet network-online.target || \
      systemctl --no-pager --quiet wait network-online.target || true
  fi

  # 3) netfilter-persistent (ou equivalente) — não bloqueia se ausente
  if systemctl list-unit-files | grep -q '^netfilter-persistent\.service'; then
    # Apenas registra estado; não há 'wait' padrão
    if systemctl is-failed --quiet netfilter-persistent.service; then
      warn "netfilter-persistent.service falhou (seguindo assim mesmo)"
    else
      log "netfilter-persistent.service presente"
    fi
  fi
fi

# Buffer final para serviços que sobem logo após online
sleep 2

# ---- Aplicação do perfil ----
log "Aplicando perfil: $PROFILE"
if "$PROFILES_SCRIPT" "$PROFILE"; then
  log "Perfil '$PROFILE' aplicado com sucesso"
  exit 0
else
  err "Falha ao aplicar perfil '$PROFILE'"
  exit 1
fi

EOF

sudo chmod +x /usr/local/bin/mirako-apply-last-profile.sh



sudo tee /etc/systemd/system/mirako-apply-last-profile.service >/dev/null <<'EOF'
[Unit]
Description=Mirako: aplicar último perfil após o boot
After=systemd-udev-settle.service network-online.target netfilter-persistent.service mirako-autodial.service
Wants=systemd-udev-settle.service network-online.target
# Só executa se estes caminhos existirem/forem válidos:
ConditionPathExists=/usr/local/bin/mirako-apply-last-profile.sh
ConditionPathIsExecutable=/usr/local/bin/mirako-apply-last-profile.sh
ConditionPathExists=/var/lib/mirako/last_profile

[Service]
Type=oneshot
# Opcional: expõe caminhos usados pelo script (caso ele leia via env)
Environment="PROFILES_SCRIPT=/usr/local/bin/profiles.sh" "LAST_FILE=/var/lib/mirako/last_profile"
ExecStart=/usr/local/bin/mirako-apply-last-profile.sh
# perfis podem levar um pouco; combine com seu profiles.sh
TimeoutStartSec=180
RemainAfterExit=yes
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF

sudo systemctl daemon-reload
sudo systemctl enable --now mirako-apply-last-profile.service










