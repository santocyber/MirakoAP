sudo tee /etc/update-motd.d/10-orangepi-header >/dev/null <<'EOF'
#!/bin/bash
#
# Copyright (c) Authors: https://www.armbian.com/authors
#
# This file is licensed under the terms of the GNU General Public
# License version 2. This program is licensed "as is" without any
# warranty of any kind, whether express or implied.

# DO NOT EDIT THIS FILE but add config options to /etc/default/orangepi-motd
# any changes will be lost on board support package update

THIS_SCRIPT="header"
MOTD_DISABLE=""

[[ -f /etc/default/orangepi-motd ]] && . /etc/default/orangepi-motd

for f in $MOTD_DISABLE; do
	[[ $f == $THIS_SCRIPT ]] && exit 0
done

. /etc/os-release
. /etc/orangepi-release

KERNELID=$(uname -r)
TERM=linux toilet -f standard -F metal $(echo 'Mirako.org')
echo -e "Welcome to \e[0;91mOrange Pi ${VERSION} ${DISTRIBUTION_CODENAME^}\x1B[0m with $([[ $BRANCH == edge ]] && echo -e "\e[0;91mbleeding\x1B[0m edge " )\e[0;91mLinux $KERNELID\x1B[0m\n \e[0;97m by SantoCyber\x1B[0m\n"

EOF

figlet "Mirako.ORG"
figlet "SantoCyber"




sudo apt update
sudo apt install -y hostapd dnsmasq ppp usb-modeswitch wpasupplicant iptables-persistent python3-flask python3-systemd traceroute tcpdump





echo 'net.ipv4.ip_forward=1' | sudo tee /etc/sysctl.d/99-iptables.conf
sudo sysctl -p /etc/sysctl.d/99-iptables.conf




sudo tee /etc/wpa_supplicant/wpa_supplicant-wlan0.conf >/dev/null <<'EOF'
ctrl_interface=/var/run/wpa_supplicant
update_config=1
country=BR
ap_scan=1
# redes serão adicionadas pela sua UI via wpa_cli (save_config grava aqui)
EOF

sudo systemctl enable --now wpa_supplicant@wlan0.service





sudo tee /etc/hostapd/hostapd.conf >/dev/null <<'EOF'
# /etc/hostapd/hostapd.conf
interface=wlan0
driver=nl80211
ssid=MirakoAP
country_code=BR
ieee80211d=1

# 2.4 GHz
hw_mode=g
channel=6
wmm_enabled=1
ieee80211n=1
# (opcional) algumas placas precisam disso para estabilidade:
# ht_capab=[SHORT-GI-20][SHORT-GI-40]

# WPA2-PSK CCMP
auth_algs=1
ignore_broadcast_ssid=0
wpa=2
wpa_key_mgmt=WPA-PSK
rsn_pairwise=CCMP
wpa_pairwise=CCMP
wpa_passphrase=12345678

# interface de controle (útil para debug)
ctrl_interface=/var/run/hostapd
logger_syslog=-1
logger_syslog_level=2


EOF



sudo tee /etc/default/hostapd >/dev/null <<'EOF' 
DAEMON_CONF="/etc/hostapd/hostapd.conf"
EOF


sudo tee /etc/dnsmasq.d/mirako.conf >/dev/null <<'EOF' 
interface=wlan0,end0        # serve DHCP nas interfaces LAN/AP
dhcp-range=192.168.7.50,192.168.7.240,12h
domain=mirako.local
dhcp-option=3,192.168.7.1   # gateway padrão (endereço da Pi)
dhcp-option=6,8.8.8.8,8.8.4.4  # servidores DNS
log-queries
log-dhcp
EOF


sudo systemctl disable --now hostapd dnsmasq
sudo systemctl mask hostapd dnsmasq

sudo systemctl disable --now wpa_supplicant@wlan0.service
sudo systemctl disable --now NetworkManager.service



# crie/garanta diretório de chats
sudo mkdir -p /etc/chatscripts

# (re)crie o chat de CONEXÃO

sudo install -d /etc/chatscripts

sudo tee /etc/chatscripts/3g.chat >/dev/null <<'EOF'
ABORT   'BUSY'
ABORT   'NO CARRIER'
ABORT   'NO DIALTONE'
ABORT   'NO ANSWER'
ABORT   'ERROR'
ABORT   'SIM PIN'
REPORT  CONNECT
TIMEOUT 30
''        AT
OK        ATE0
OK        AT+CFUN=1
OK        AT+CREG?
OK        AT+CGDCONT=1,"IP","zap.vivo.com.br"
OK        ATD*99#
CONNECT   \c
EOF

# chat de DESCONEXÃO
sudo tee /etc/chatscripts/3g-disconnect.chat >/dev/null <<'EOF'
'' '+++'
'' 'ATH'
'' 'ATZ'
EOF

# permissões: leitura suficiente (chat só precisa ler)
sudo chmod 644 /etc/chatscripts/3g.chat /etc/chatscripts/3g-disconnect.chat

# peers do pppd
sudo mkdir -p /etc/ppp/peers
sudo tee /etc/ppp/peers/3g >/dev/null <<'EOF'
/dev/ttyUSB2 115200
connect "/usr/sbin/chat -v -f /etc/chatscripts/3g.chat"
crtscts
modem
noauth
defaultroute
replacedefaultroute
usepeerdns
persist
holdoff 5
maxfail 0
noipdefault
noipv6
lcp-echo-interval 5
lcp-echo-failure 6

EOF




sudo tee /usr/local/bin/profiles.sh >/dev/null <<'EOF'
#!/usr/bin/env bash
set -uo pipefail

PROFILE_FILE=/var/lib/mirako/last_profile
DEF=ap
want="$(cat "$PROFILE_FILE" 2>/dev/null || echo "$DEF")"

export WLAN_IF="${WLAN_IF:-wlan0}"
export LAN_IF="${LAN_IF:-end0}"
export PPP_IF="${PPP_IF:-ppp0}"
export PPP_PEER="${PPP_PEER:-3g}"
export PROFILES_SCRIPT="${PROFILES_SCRIPT:-/usr/local/bin/profiles.sh}"

log(){ echo "[autoboot] $*"; }

# Garante que, se o perfil não for cliente Wi-Fi, o wpa_supplicant não roube o modo da interface
disable_sta_daemon(){
  systemctl stop "wpa_supplicant@${WLAN_IF}.service" >/dev/null 2>&1 || true
  systemctl disable "wpa_supplicant@${WLAN_IF}.service" >/dev/null 2>&1 || true
  pkill -f "wpa_supplicant.*${WLAN_IF}" >/dev/null 2>&1 || true
}

case "$want" in
  ap)
    log "Boot: aplicando AP e fixando modo AP (sem wpa_supplicant)."
    disable_sta_daemon
    "$PROFILES_SCRIPT" ap || true
    exit 0
    ;;

  3g|ppp|ppp3g)
    log "Boot: aplicando 3G + AP; rediscagem ficará a cargo do keepalive."
    disable_sta_daemon
    "$PROFILES_SCRIPT" 3g || true
    exit 0
    ;;

  client-lan|lan-client)
    log "Boot: cliente LAN."
    "$PROFILES_SCRIPT" client-lan || true
    exit 0
    ;;

  client-wifi|wifi-client|sta)
    log "Boot: cliente Wi-Fi com fallback interno do profiles.sh."
    "$PROFILES_SCRIPT" client-wifi || true
    exit 0
    ;;

  *)
    log "Boot: perfil desconhecido '$want' — caindo em AP."
    disable_sta_daemon
    "$PROFILES_SCRIPT" ap || true
    exit 0
    ;;
esac



EOF

sudo chmod +x /usr/local/bin/profiles.sh










mkdir /opt/mirako_web

sudo tee /opt/mirako_web/web_config.py >/dev/null <<'EOF'
#!/usr/bin/env python3
"""
Revised Mirako router configuration web application.

This version cleans up unused helpers, fixes DNS handling when
switching profiles, exposes DHCP lease information reliably and
adds several requested UI features:

* A password field for Wi‑Fi connections now includes a toggle to
  reveal the password.
* The currently saved operation profile is displayed alongside the
  profile selection buttons.
* A new "Serviços" card lists the key systemd services used by the
  router (hostapd, dnsmasq, wpa_supplicant for wlan0, create_ap and
  NetworkManager).  Each service row shows whether the service is
  active and enabled and provides buttons to start, stop, restart,
  enable or disable the unit.
* Template style assets no longer depend solely on external CDNs.
  The Bootstrap JavaScript already falls back to a local copy.  A
  similar pattern is used for CSS: the page attempts to load a
  local static file ``/static/css/bootstrap.min.css`` when the
  remote CDN is unavailable.

The original functionality (Wi‑Fi scanning/connection, PPP modem
control, network statistics, logs) is preserved.
"""

from __future__ import annotations

import os
import re
import time
import glob
import shutil
import subprocess
from typing import Any, List, Tuple, Dict

from flask import (
    Flask,
    render_template_string,
    request,
    redirect,
    url_for,
    flash,
)

import threading
import signal

app = Flask(__name__)
app.secret_key = os.environ.get("MIRAKO_SECRET", "devkey")

###############################################################################
# Runtime configuration
###############################################################################
# Interfaces and scripts may be overridden via environment variables to make the
# web app flexible for different hardware.  These defaults mirror the install
# scripts used on Orange Pi Zero boards.
WLAN_IF = os.environ.get("WLAN_IF", "wlan0")
LAN_IF = os.environ.get("LAN_IF", "end0")
PPP_IF = os.environ.get("PPP_IF", "ppp0")
PPP_PEER = os.environ.get("PPP_PEER", "3g")
PROFILES_SCRIPT = os.environ.get("PROFILES_SCRIPT", "/usr/local/bin/profiles.sh")

# When using the 3G/PPP profile, the router can automatically attempt to
# connect/disconnect the modem if this flag file exists.  The keepalive
# daemon (mirako-ppp-keepalive.sh) checks for its presence before
# redialing.  The web UI can toggle this flag.
AUTO_DIAL_FILE = "/var/lib/mirako/auto_dial_enabled"

# Default SSID/passphrase used when creating an AP.  Keep these in sync
# with the values in profiles.sh.
SSID = os.environ.get("SSID") or os.environ.get("AP_SSID") or "MirakoAP"
PASS = os.environ.get("PASS") or os.environ.get("AP_PASS") or "12345678"

###############################################################################
# Executable discovery
###############################################################################
def find_bin(name: str, fallbacks: List[str]) -> str:
    """Return the path of an executable, falling back to known locations."""
    p = shutil.which(name)
    if p:
        return p
    for fb in fallbacks:
        if os.path.exists(fb) and os.access(fb, os.X_OK):
            return fb
    return name  # hope it's on PATH

PPPD_BIN = find_bin("pppd", ["/usr/sbin/pppd", "/sbin/pppd", "/usr/bin/pppd"])
IP_BIN = find_bin("ip", ["/usr/sbin/ip", "/sbin/ip", "/usr/bin/ip"])
IW_BIN = find_bin("iw", ["/usr/sbin/iw", "/sbin/iw", "/usr/bin/iw"])
IWLIST_BIN = find_bin("iwlist", ["/usr/sbin/iwlist", "/sbin/iwlist", "/usr/bin/iwlist"])
WPA_CLI_BIN = find_bin("wpa_cli", ["/usr/sbin/wpa_cli", "/sbin/wpa_cli", "/usr/bin/wpa_cli"])
RESOLVECTL_BIN = find_bin(
    "resolvectl", ["/usr/bin/resolvectl", "/usr/sbin/resolvectl", "/bin/resolvectl"]
)

###############################################################################
# Terminal / Live Shell Helpers
###############################################################################
# We provide a simple live shell environment accessible via the web UI.
# Commands run in their own process group to allow Ctrl+C to stop them.
# Output is written to a log file which is tailed by the front‑end via AJAX.

# Prepare directory and file for terminal logs
LOG_DIR = "/var/log/mirako"
os.makedirs(LOG_DIR, exist_ok=True)
TERM_LOG = os.path.join(LOG_DIR, "terminal.log")

# Maintain a single running process at a time
RUN: Dict[str, Any] = {"proc": None, "pgid": None}
RUN_LOCK = threading.Lock()

def _write_line(text: str) -> None:
    """Append a line of text to the terminal log."""
    try:
        with open(TERM_LOG, "a", encoding="utf-8", errors="ignore") as f:
            f.write(text)
            if not text.endswith("\n"):
                f.write("\n")
    except Exception:
        pass


def _pump_stdout(proc: subprocess.Popen) -> None:
    """Background thread: read stdout/stderr from a process and append to log."""
    try:
        for line in iter(proc.stdout.readline, ""):
            _write_line(line.rstrip("\n"))
    except Exception as e:
        _write_line(f"[pump] erro: {e}")
    finally:
        code = proc.wait()
        _write_line(f"\n[processo finalizado] exit={code}")


def start_command(cmd: str) -> None:
    """Start a shell command, stopping any existing one."""
    raw = cmd.strip()
    if not raw:
        return
    with RUN_LOCK:
        # If a process is already running, send SIGINT to its group
        if RUN["proc"] is not None and RUN["proc"].poll() is None:
            try:
                os.killpg(RUN["pgid"], signal.SIGINT)
            except Exception:
                try:
                    RUN["proc"].terminate()
                except Exception:
                    pass
        # Reset the log and note the command
        try:
            with open(TERM_LOG, "w", encoding="utf-8", errors="ignore") as f:
                f.write(f"# {time.strftime('%Y-%m-%d %H:%M:%S')} — exec: {raw}\n")
        except Exception:
            pass
        # Spawn new process in its own process group
        proc = subprocess.Popen(
            raw,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1,
            preexec_fn=os.setsid,
        )
        RUN["proc"] = proc
        RUN["pgid"] = os.getpgid(proc.pid)
        # Start thread to pump stdout
        t = threading.Thread(target=_pump_stdout, args=(proc,), daemon=True)
        t.start()


def stop_command() -> None:
    """Send SIGINT to the running command (if any)."""
    with RUN_LOCK:
        if RUN["proc"] is not None and RUN["proc"].poll() is None:
            try:
                os.killpg(RUN["pgid"], signal.SIGINT)
                _write_line("[SIGINT enviado]")
            except Exception as e:
                _write_line(f"[erro SIGINT] {e}")
                try:
                    RUN["proc"].terminate()
                except Exception:
                    pass


def clear_log() -> None:
    """Clear the terminal log file."""
    try:
        with open(TERM_LOG, "w", encoding="utf-8") as f:
            f.write("")
    except Exception:
        pass


def read_log_tail(max_bytes: int = 120_000) -> str:
    """Return the last part of the terminal log (up to max_bytes)."""
    try:
        with open(TERM_LOG, "rb") as f:
            f.seek(0, os.SEEK_END)
            size = f.tell()
            off = max(0, size - max_bytes)
            f.seek(off, os.SEEK_SET)
            data = f.read().decode("utf-8", errors="ignore")
            return data
    except Exception:
        return "(sem saída ainda)"

###############################################################################
# Generic helpers
###############################################################################
def run(cmd: List[str], timeout: int = 10) -> Tuple[int, str]:
    """Run a command and return (exit_code, output)."""
    try:
        out = subprocess.check_output(
            cmd, stderr=subprocess.STDOUT, text=True, timeout=timeout
        )
        return 0, out.strip()
    except subprocess.CalledProcessError as e:
        return e.returncode, (e.output or "").strip()
    except Exception as e:
        return 1, f"{type(e).__name__}: {e}"


def human_bytes(n: float) -> str:
    """Convert a byte count into a human-readable string."""
    try:
        n = float(n)
    except Exception:
        return str(n)
    units = ["B", "KB", "MB", "GB", "TB"]
    i = 0
    while n >= 1024 and i < len(units) - 1:
        n /= 1024.0
        i += 1
    return f"{n:.1f} {units[i]}"


###############################################################################
# Network helpers
###############################################################################
def ensure_iface_up(dev: str) -> None:
    """Ensure a network interface is up."""
    base = f"/sys/class/net/{dev}"
    if not os.path.exists(base):
        return
    try:
        state = open(os.path.join(base, "operstate")).read().strip().lower()
    except Exception:
        state = "unknown"
    if state != "up":
        run([IP_BIN, "link", "set", "dev", dev, "up"])


def get_ipv4_list(dev: str) -> str:
    rc, out = run([IP_BIN, "-4", "addr", "show", "dev", dev])
    if rc != 0:
        return "-"
    ips: List[str] = []
    for line in out.splitlines():
        s = line.strip()
        if s.startswith("inet "):
            parts = s.split()
            if len(parts) >= 2:
                ips.append(parts[1])
    return ", ".join(ips) if ips else "-"


def default_route() -> str:
    rc, out = run([IP_BIN, "-4", "route", "show", "default"])
    return out if rc == 0 and out else "<sem rota>"


def routes() -> str:
    rc, out = run([IP_BIN, "-4", "route"])
    return out if rc == 0 else f"(erro ip route rc={rc})"


def dns_info() -> str:
    # Prefer systemd-resolved if available
    if os.path.exists(RESOLVECTL_BIN):
        rc, out = run([RESOLVECTL_BIN, "status"], timeout=5)
        if rc == 0 and out:
            return out
    try:
        with open("/etc/resolv.conf", "r", encoding="utf-8", errors="ignore") as f:
            return f.read()
    except Exception as e:
        return f"# erro ao ler resolv.conf: {e}"


def read_dnsmasq_leases() -> Tuple[List[dict], str, str | None]:
    """Parse dnsmasq lease file.  Returns a list of leases and raw text."""
    paths = ["/var/lib/misc/dnsmasq.leases", "/var/lib/dnsmasq/dnsmasq.leases"]
    for path in paths:
        if os.path.exists(path):
            leases: List[dict] = []
            raw = ""
            try:
                raw = open(path, "r", encoding="utf-8", errors="ignore").read()
                for line in raw.splitlines():
                    parts = line.split()
                    if len(parts) >= 5:
                        expiry, mac, ip, hostname, client_id = parts[:5]
                        # expiry is epoch seconds (0 means infinite)
                        try:
                            expi = int(expiry)
                            when = (
                                "infinito"
                                if expi == 0
                                else time.strftime(
                                    "%Y-%m-%d %H:%M:%S", time.localtime(expi)
                                )
                            )
                        except Exception:
                            when = expiry
                        leases.append(
                            {
                                "expiry": when,
                                "mac": mac,
                                "ip": ip,
                                "hostname": hostname if hostname != "*" else "",
                                "client_id": client_id,
                            }
                        )
            except Exception as e:
                raw = f"(erro ao ler {path}: {e})"
            return leases, raw, path
    return [], "(arquivo de leases não encontrado)", None


###############################################################################
# System state helpers
###############################################################################
def cpu_temp_c() -> float | None:
    temps: List[float] = []
    best: float | None = None
    for path in glob.glob("/sys/class/thermal/thermal_zone*/temp"):
        try:
            t = int(open(path).read().strip())
            c = t / 1000.0 if t > 1000 else float(t)
            ttype_path = path.replace("/temp", "/type")
            ttype = (
                open(ttype_path).read().strip().lower()
                if os.path.exists(ttype_path)
                else ""
            )
            if "cpu" in ttype or "soc" in ttype:
                best = c
            temps.append(c)
        except Exception:
            pass
    if best is not None:
        return best
    if temps:
        return sum(temps) / len(temps)
    try:
        c = int(open("/sys/class/thermal/thermal_zone0/temp").read().strip()) / 1000.0
        return c
    except Exception:
        return None


def cpu_usage_pct(sample_sec: float = 0.2) -> float:
    def read_cpu() -> Tuple[int, int]:
        with open("/proc/stat", "r") as f:
            for line in f:
                if line.startswith("cpu "):
                    parts = line.split()
                    vals = list(map(int, parts[1:]))
                    idle = vals[3] + (vals[4] if len(vals) > 4 else 0)
                    total = sum(vals)
                    return idle, total
        return 0, 1

    idle1, total1 = read_cpu()
    time.sleep(sample_sec)
    idle2, total2 = read_cpu()
    dtotal = total2 - total1
    didle = idle2 - idle1
    if dtotal <= 0:
        return 0.0
    busy = 100.0 * (1.0 - (didle / dtotal))
    if busy < 0:
        busy = 0.0
    # Cap at 100% per CPU
    max_pct = 100 * os.cpu_count()
    return busy if busy <= max_pct else max_pct


def mem_stats() -> Dict[str, float]:
    info: Dict[str, str] = {}
    with open("/proc/meminfo", "r") as f:
        for line in f:
            k, v = line.split(":", 1)
            info[k.strip()] = v.strip()

    def kB(name: str) -> int:
        val = info.get(name, "0").split()[0]
        return int(val)

    total = kB("MemTotal") * 1024
    avail = kB("MemAvailable") * 1024
    used = total - avail
    pct = (used / total * 100.0) if total > 0 else 0.0
    return dict(total=total, used=used, avail=avail, pct=pct)


def disk_stats(path: str = "/") -> Dict[str, float]:
    du = shutil.disk_usage(path)
    used = du.total - du.free
    pct = used / du.total * 100.0 if du.total else 0.0
    return dict(total=du.total, used=used, free=du.free, pct=pct)


def processes_top(n: int = 20) -> List[dict]:
    rc, out = run(["ps", "-eo", "pid,comm,%cpu,%mem", "--sort=-%cpu"])
    procs: List[dict] = []
    if rc == 0 and out:
        lines = out.splitlines()
        for line in lines[1 : 1 + n]:
            parts = line.split(None, 3)
            if len(parts) == 4:
                pid, comm, pcpu, pmem = parts
                procs.append(dict(pid=pid, comm=comm, pcpu=pcpu, pmem=pmem))
    return procs


###############################################################################
# Network statistics per interface
###############################################################################
def net_stats_for(dev: str) -> dict:
    base = f"/sys/class/net/{dev}"
    if not os.path.exists(base):
        return dict(dev=dev, state="DOWN", ipv4="-", rx="-", tx="-")
    try:
        state = open(os.path.join(base, "operstate")).read().strip().upper()
    except Exception:
        state = "?"

    def read_num(p: str) -> int:
        try:
            return int(open(p).read().strip())
        except Exception:
            return 0

    rx = read_num(os.path.join(base, "statistics/rx_bytes"))
    tx = read_num(os.path.join(base, "statistics/tx_bytes"))
    return dict(
        dev=dev,
        state=state,
        ipv4=get_ipv4_list(dev),
        rx=human_bytes(rx),
        tx=human_bytes(tx),
    )


###############################################################################
# Wi‑Fi helpers
###############################################################################
def estimate_distance_m(rssi_dbm: float, freq_mhz: float) -> float | None:
    """
    Very rough free‑space estimate of client distance.
    d(m) ≈ 10 ^ ((27.55 - 20*log10(f_MHz) + |RSSI|) / 20)
    """
    try:
        return round(
            10 ** ((27.55 - (20 * math.log10(float(freq_mhz))) + abs(float(rssi_dbm))) / 20), 1
        )
    except Exception:
        return None


def iw_info() -> dict:
    rc, out = run([IW_BIN, "dev", WLAN_IF, "info"])
    info: Dict[str, Any] = {
        "type": "-",
        "channel": "-",
        "freq_mhz": None,
        "txpower_dbm": "-",
    }
    if rc == 0 and out:
        for ln in out.splitlines():
            s = ln.strip()
            if s.startswith("type "):
                info["type"] = s.split(" ", 1)[1].strip()
            elif "channel" in s and "(" in s and "MHz" in s:
                # e.g. "channel 6 (2437 MHz)"
                try:
                    parts = s.split()
                    info["channel"] = parts[1]
                    mhz = s.split("(")[1].split("MHz")[0].strip()
                    info["freq_mhz"] = float(mhz)
                except Exception:
                    pass
            elif s.startswith("txpower "):
                try:
                    val = s.split()[1]
                    info["txpower_dbm"] = f"{float(val):.1f} dBm"
                except Exception:
                    pass
    return info


def get_ap_ssid() -> str:
    # Try to read temporary create_ap hostapd config if present
    for path in glob.glob("/tmp/create_ap*.conf"):
        try:
            txt = open(path, "r", encoding="utf-8", errors="ignore").read()
            m = re.search(r"^\s*ssid\s*=\s*(.+)$", txt, re.M)
            if m:
                return m.group(1).strip()
        except Exception:
            pass
    # Some drivers show the AP SSID in iw dev info
    rc, out = run([IW_BIN, "dev", WLAN_IF, "info"])
    if rc == 0 and out:
        for ln in out.splitlines():
            s = ln.strip()
            if s.lower().startswith("ssid "):
                return s.split(None, 1)[1].strip()
    # Fallback to configured SSID
    return SSID


def iw_link() -> dict:
    """
    Return detailed link information for wlan0.  When in AP mode, count
    connected stations; when in STA, return SSID/BSSID, RSSI and bitrates.
    """
    rc, out = run([IW_BIN, "dev", WLAN_IF, "link"])
    d: Dict[str, Any] = {
        "connected": False,
        "ssid": "-",
        "bssid": "-",
        "signal_dbm": None,
        "rx_bitrate": "-",
        "tx_bitrate": "-",
        "rx": "-",
        "tx": "-",
        "clients": 0,
    }
    if rc == 0 and out:
        if "Not connected." in out:
            # In AP mode – count stations
            d["connected"] = True
            d["ssid"] = get_ap_ssid()
            rc2, st = run([IW_BIN, "dev", WLAN_IF, "station", "dump"])
            if rc2 == 0 and st:
                clients = 0
                rssi = None
                for ln in st.splitlines():
                    s = ln.strip().lower()
                    if s.startswith("station "):
                        clients += 1
                    if s.startswith("signal:"):
                        try:
                            rssi = float(s.split()[1])
                        except Exception:
                            pass
                d["clients"] = clients
                if rssi is not None:
                    d["signal_dbm"] = rssi
            return d
        else:
            # Connected as STA
            d["connected"] = True
            for ln in out.splitlines():
                s = ln.strip()
                if s.startswith("SSID:"):
                    d["ssid"] = s.split(":", 1)[1].strip()
                elif s.startswith("Connected to "):
                    d["bssid"] = s.split()[2].strip()
                elif s.startswith("signal:"):
                    try:
                        d["signal_dbm"] = float(s.split()[1])
                    except Exception:
                        pass
                elif s.startswith("rx bitrate:"):
                    d["rx_bitrate"] = s.split(":", 1)[1].strip()
                elif s.startswith("tx bitrate:"):
                    d["tx_bitrate"] = s.split(":", 1)[1].strip()
                elif s.startswith("RX:"):
                    d["rx"] = s.split(":", 1)[1].strip()
                elif s.startswith("TX:"):
                    d["tx"] = s.split(":", 1)[1].strip()
    return d


def iface_byte_counters(dev: str) -> Tuple[int, int, int, int]:
    base = f"/sys/class/net/{dev}/statistics"
    try:
        rx1 = int(open(os.path.join(base, "rx_bytes")).read().strip())
        tx1 = int(open(os.path.join(base, "tx_bytes")).read().strip())
        time.sleep(0.25)
        rx2 = int(open(os.path.join(base, "rx_bytes")).read().strip())
        tx2 = int(open(os.path.join(base, "tx_bytes")).read().strip())
        rx_bps = (rx2 - rx1) * 8 * 4  # convert to bits/s
        tx_bps = (tx2 - tx1) * 8 * 4
        return (rx2, tx2, rx_bps, tx_bps)
    except Exception:
        return (0, 0, 0, 0)


def wpa_status() -> dict:
    rc, out = run([WPA_CLI_BIN, "-i", WLAN_IF, "status"])
    d: Dict[str, Any] = {}
    if rc == 0:
        for line in out.splitlines():
            if "=" in line:
                k, v = line.split("=", 1)
                d[k] = v
    return d


def wifi_status_details() -> dict:
    st = wpa_status()
    ii = iw_info()
    lk = iw_link()
    rxB, txB, rxbps, txbps = iface_byte_counters(WLAN_IF)
    mode = ii.get("type", "-").upper()
    state = st.get("wpa_state", "-")
    channel = ii.get("channel", "-")
    freq_mhz = ii.get("freq_mhz")
    rssi = lk.get("signal_dbm")
    dist_m = (
        estimate_distance_m(rssi, freq_mhz) if (rssi is not None and freq_mhz) else None
    )
    return {
        "mode": mode,
        "state": state,
        "ssid": lk.get("ssid", "-"),
        "bssid": lk.get("bssid", "-"),
        "channel": channel,
        "freq_mhz": f"{freq_mhz:.0f} MHz" if freq_mhz else "-",
        "txpower": ii.get("txpower_dbm", "-"),
        "rssi": f"{rssi:.0f} dBm" if rssi is not None else "-",
        "tx_bitrate": lk.get("tx_bitrate", "-"),
        "rx_bitrate": lk.get("rx_bitrate", "-"),
        "rx_bytes": human_bytes(rxB),
        "tx_bytes": human_bytes(txB),
        "rx_bps": f"{rxbps/1e6:.2f} Mbit/s" if rxbps > 0 else "0",
        "tx_bps": f"{txbps/1e6:.2f} Mbit/s" if txbps > 0 else "0",
        "clients": lk.get("clients", 0),
        "distance_m": f"~{dist_m} m" if dist_m else "-",
    }


def wifi_scan() -> Tuple[List[dict], str | None]:
    ensure_iface_up(WLAN_IF)
    rc, out = run([IW_BIN, "dev", WLAN_IF, "scan"])
    if rc == 0 and out:
        bss: Dict[str, Any] | None = None
        nets: List[dict] = []
        for line in out.splitlines():
            s = line.strip()
            if s.startswith("BSS "):
                if bss:
                    nets.append(bss)
                bss = {"ssid": "", "signal": "", "freq": "", "security": "?"}
            elif s.startswith("SSID:"):
                if bss is None:
                    bss = {}
                bss["ssid"] = s[5:].strip()
            elif s.startswith("freq:"):
                if bss is None:
                    bss = {}
                bss["freq"] = s[5:].strip()
            elif s.startswith("signal:"):
                if bss is None:
                    bss = {}
                bss["signal"] = s[7:].strip()
            elif s.startswith("RSN:") or s.startswith("WPA:"):
                if bss is None:
                    bss = {}
                bss["security"] = "WPA/WPA2"
        if bss:
            nets.append(bss)
        nets = [n for n in nets if n.get("ssid")]
        uniq: Dict[str, dict] = {}
        for n in nets:
            ssid = n["ssid"]
            if ssid not in uniq or n.get("signal", "") > uniq[ssid].get("signal", ""):
                uniq[ssid] = n
        return list(uniq.values()), None
    # fallback to iwlist
    rc2, out2 = run([IWLIST_BIN, WLAN_IF, "scan"])
    if rc2 == 0 and out2:
        nets = []
        for b in out2.split("Cell "):
            ssid_m = re.search(r'ESSID:"(.*)"', b)
            qual = re.search(r"Signal level=(-?\d+)", b) or re.search(r"Quality=([0-9/]+)", b)
            freq = re.search(r"Frequency:([0-9\.]+)", b)
            enc = "Open" if "Encryption key:off" in b else "WPA/WPA2"
            if ssid_m:
                nets.append(
                    {
                        "ssid": ssid_m.group(1),
                        "signal": (qual.group(1) if qual else "?"),
                        "freq": (freq.group(1) if freq else "?"),
                        "security": enc,
                    }
                )
        return nets, None


# ====================== Saved networks and file manager helpers =====================
def get_saved_networks() -> List[Dict[str, str]]:
    """
    Return a list of saved Wi‑Fi networks using wpa_cli. Each entry has keys:
    id, ssid, bssid and flags. Returns an empty list on error.
    """
    rc, out = run([WPA_CLI_BIN, "-i", WLAN_IF, "list_networks"])
    nets: List[Dict[str, str]] = []
    if rc == 0 and out:
        lines = out.splitlines()[1:]
        for line in lines:
            parts = line.split("\t")
            if len(parts) >= 4:
                nets.append(
                    {
                        "id": parts[0].strip(),
                        "ssid": parts[1].strip(),
                        "bssid": parts[2].strip(),
                        "flags": parts[3].strip(),
                    }
                )
    return nets

def list_root_files() -> List[str]:
    """List non-hidden files in /root for a simple file manager."""
    try:
        return [f for f in os.listdir("/root") if not f.startswith(".")]
    except Exception:
        return []
    return [], f"iw rc={rc} out={out} | iwlist rc={rc2} out={out2}"


def wifi_connect(ssid: str, psk: str | None = None) -> Tuple[bool, str]:
    # Ensure wpa_supplicant is active
    rc_svc, _ = run(["systemctl", "is-active", f"wpa_supplicant@{WLAN_IF}.service"])
    if rc_svc != 0:
        return False, "wpa_supplicant não está ativo (use o perfil Cliente Wi‑Fi)."
    # Find or create network
    rc, out = run([WPA_CLI_BIN, "-i", WLAN_IF, "list_networks"])
    existing_id: str | None = None
    if rc == 0 and out:
        for line in out.splitlines():
            parts = line.split("\t")
            if len(parts) >= 2 and parts[1] == ssid:
                existing_id = parts[0]
                break
    if existing_id is None:
        rc, out = run([WPA_CLI_BIN, "-i", WLAN_IF, "add_network"])
        if rc != 0:
            return False, f"add_network falhou: {out}"
        existing_id = out.strip()
    # Configure network
    rc1, out1 = run([WPA_CLI_BIN, "-i", WLAN_IF, "set_network", existing_id, "ssid", f'"{ssid}"'])
    if rc1 != 0:
        return False, f"set ssid falhou: {out1}"
    if psk and psk.strip():
        rc2, out2 = run([
            WPA_CLI_BIN,
            "-i",
            WLAN_IF,
            "set_network",
            existing_id,
            "psk",
            f'"{psk}"',
        ])
    else:
        rc2, out2 = run([
            WPA_CLI_BIN,
            "-i",
            WLAN_IF,
            "set_network",
            existing_id,
            "key_mgmt",
            "NONE",
        ])
    if rc2 != 0:
        return False, f"config segurança falhou: {out2}"
    rc3, out3 = run([WPA_CLI_BIN, "-i", WLAN_IF, "enable_network", existing_id])
    rc4, out4 = run([WPA_CLI_BIN, "-i", WLAN_IF, "select_network", existing_id])
    run([WPA_CLI_BIN, "-i", WLAN_IF, "save_config"])
    run([WPA_CLI_BIN, "-i", WLAN_IF, "reassociate"])
    if not (rc3 == 0 and rc4 == 0):
        return False, ("; ".join([out3, out4])).strip()
    # Wait for association
    deadline = time.time() + 30
    last_state = ""
    while time.time() < deadline:
        st = wpa_status()
        last_state = st.get("wpa_state", "")
        if last_state == "COMPLETED":
            break
        time.sleep(1)
    if last_state != "COMPLETED":
        return False, f"associação não completou (estado={last_state or 'desconhecido'})"
    # DHCP
    run(["dhclient", "-r", WLAN_IF])
    rc_dh, out_dh = run(["dhclient", WLAN_IF], timeout=25)
    ip = get_ipv4_list(WLAN_IF)
    if ip == "-" or rc_dh != 0:
        return False, f"associou, mas sem IP (dhclient rc={rc_dh}) {out_dh}"
    # Parse DHCP lease for DNS and routers
    routers, dns_servers = parse_dhclient_lease(WLAN_IF)
    if routers:
        ensure_default_via(routers[0], WLAN_IF)
    if dns_servers:
        apply_dns(dns_servers)
    return True, (
        f"conectado com IP {ip}; GW={routers[0] if routers else '?'}; DNS="
        + (", ".join(dns_servers) if dns_servers else "?")
    )


def wifi_disconnect() -> Tuple[bool, str]:
    rc, out = run([WPA_CLI_BIN, "-i", WLAN_IF, "disconnect"])
    return (rc == 0, out)


###############################################################################
# Service management helpers
###############################################################################
def list_services() -> List[dict]:
    """
    Return status information for **all** systemd services.  Each entry in the
    returned list contains the unit name, whether it is currently active and
    whether it is enabled.  To avoid excessive overhead this function uses
    ``systemctl list-unit-files`` to fetch the list of services and then
    individually queries each unit's active state.  In systems with hundreds of
    units this may take a moment.
    """
    services: List[dict] = []
    rc, out = run([
        "systemctl",
        "list-unit-files",
        "--type=service",
        "--no-pager",
        "--no-legend",
    ])
    if rc != 0 or not out:
        return services
    for line in out.splitlines():
        parts = line.split()
        if not parts:
            continue
        name = parts[0]
        state = parts[1] if len(parts) > 1 else "disabled"
        # Determine if the service is currently active (running)
        rc_active, _ = run(["systemctl", "is-active", name])
        active = (rc_active == 0)
        # Enabled states include "enabled" and "enabled-runtime"
        enabled = state.startswith("enabled")
        services.append({"name": name, "active": active, "enabled": enabled})
    # Sort alphabetically for readability
    services.sort(key=lambda x: x["name"])
    return services


def service_action(service: str, action: str) -> Tuple[bool, str]:
    """Perform a systemctl action on a given service."""
    valid_actions = {"start", "stop", "restart", "enable", "disable"}
    if action not in valid_actions:
        return False, f"ação inválida: {action}"
    if action in {"start", "stop", "restart"}:
        cmd = ["systemctl", action, service]
    elif action == "enable":
        cmd = ["systemctl", "enable", service]
    else:  # disable
        cmd = ["systemctl", "disable", service]
    rc, out = run(cmd, timeout=20)
    return (rc == 0, out)


###############################################################################
# DHCP helpers
###############################################################################
def parse_dhclient_lease(iface: str) -> Tuple[List[str], List[str]]:
    path = f"/var/lib/dhcp/dhclient.{iface}.leases"
    routers: List[str] = []
    dns: List[str] = []
    try:
        if os.path.exists(path):
            txt = open(path, "r", encoding="utf-8", errors="ignore").read()
            m_dns = re.findall(r"option\s+domain-name-servers\s+([^;]+);", txt)
            m_rtr = re.findall(r"option\s+routers\s+([^;]+);", txt)
            if m_dns:
                dns = [i.strip() for i in re.split(r"[,\s]+", m_dns[-1].strip()) if i.strip()]
            if m_rtr:
                routers = [i.strip() for i in re.split(r"[,\s]+", m_rtr[-1].strip()) if i.strip()]
    except Exception:
        pass
    return routers, dns


def apply_dns(nameservers: List[str]) -> Tuple[bool, str]:
    try:
        if os.path.islink("/etc/resolv.conf"):
            os.unlink("/etc/resolv.conf")
        with open("/etc/resolv.conf", "w", encoding="utf-8") as f:
            f.write("# Generated by Mirako client‑wifi\n")
            for ns in nameservers:
                if ns:
                    f.write(f"nameserver {ns}\n")
        return True, "resolv.conf atualizado"
    except Exception as e:
        return False, f"erro ao escrever resolv.conf: {e}"

# ----- Auto dial helpers -----
def is_auto_dial_enabled() -> bool:
    """Return True if automatic PPP dial is enabled."""
    try:
        return os.path.exists(AUTO_DIAL_FILE)
    except Exception:
        return False

def set_auto_dial(enabled: bool) -> None:
    """Enable or disable automatic PPP dialing by creating/removing a flag file."""
    try:
        if enabled:
            os.makedirs(os.path.dirname(AUTO_DIAL_FILE), exist_ok=True)
            with open(AUTO_DIAL_FILE, "w") as f:
                f.write("1")
        else:
            if os.path.exists(AUTO_DIAL_FILE):
                os.remove(AUTO_DIAL_FILE)
    except Exception:
        pass


def ensure_default_via(gw: str, dev: str) -> None:
    if not gw:
        return
    run([IP_BIN, "route", "replace", "default", "via", gw, "dev", dev])


###############################################################################
# Interface enumeration
###############################################################################
def list_interfaces(include_virtual: bool = True, include_lo: bool = True) -> List[str]:
    try:
        names = sorted(os.listdir("/sys/class/net"))
    except Exception:
        names = []
    skip_prefix = ("veth", "br-", "docker", "virbr", "vmnet", "vnet", "zt")
    out: List[str] = []
    for n in names:
        if not include_lo and n == "lo":
            continue
        if not include_virtual and n.startswith(skip_prefix):
            continue
        out.append(n)
    return out


###############################################################################
# Service for profiles
###############################################################################
def profile_set(profile: str) -> Tuple[int, str]:
    return run([PROFILES_SCRIPT, profile], timeout=90)


###############################################################################
# PPP modem helpers
###############################################################################
def modem_connect() -> Tuple[bool, str]:
    run(["pkill", "-x", "pppd"])
    run(["rm", "-f", "/var/lock/LCK..ttyUSB*"])
    try:
        subprocess.Popen([
            PPPD_BIN,
            "call",
            PPP_PEER,
        ], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
    except Exception as e:
        return False, f"erro ao iniciar pppd: {e}"
    # Wait up to 20 seconds for ppp0
    deadline = time.time() + 20
    up = False
    while time.time() < deadline:
        rc, _ = run([IP_BIN, "link", "show", PPP_IF])
        if rc == 0:
            up = True
            break
        time.sleep(1.0)
    if up:
        return True, "pppd call enviado e ppp0 ativo"
    # Collect recent journal logs for debugging
    rc1, j1 = run(["journalctl", "-b", "-n", "50", "--no-pager"])
    last: List[str] = []
    if rc1 == 0 and j1:
        for ln in j1.splitlines():
            if ("pppd" in ln.lower()) or ("chat" in ln.lower()):
                last.append(ln)
    msg = "ppp0 não subiu. "
    if last:
        msg += "Logs recentes: " + ("\n".join(last[-8:]))
    else:
        msg += "Sem logs do pppd/chat."
    return False, msg


def modem_disconnect() -> Tuple[bool, str]:
    rc, out = run(["poff", PPP_PEER], timeout=20)
    msg = (out or "").strip()
    if rc != 0 and ("No pppd is running" in msg or "None stopped" in msg):
        return True, "pppd já estava parado"
    if rc != 0:
        run(["pkill", "-x", "pppd"])
        run(["rm", "-f", "/var/lock/LCK..ttyUSB*"])
        return True, "pppd finalizado"
    return True, msg or "poff enviado"


###############################################################################
# Last profile helper
###############################################################################
def get_last_profile() -> str:
    path = "/var/lib/mirako/last_profile"
    try:
        with open(path, "r", encoding="utf-8") as f:
            return f.read().strip() or "ap"
    except Exception:
        return "ap"


###############################################################################
# Template
###############################################################################
TEMPLATE = """
<!doctype html>
<html lang="pt-br" data-bs-theme="dark">
  <head>
    <meta charset="utf-8">
    <title>Mirako — Orange Pi Router</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Attempt remote Bootstrap; if unavailable load local copy -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" onerror="this.onerror=null;this.href='/static/css/bootstrap.min.css';">
    <style>
      pre{white-space:pre-wrap;word-wrap:break-word}
      .ssid-row{cursor:pointer}
      .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,'Liberation Mono',monospace}
      .scroll{max-height:50vh; overflow:auto}
    </style>
  </head>
  <body class="bg-body text-body">
    <nav class="navbar navbar-expand-lg bg-dark border-bottom border-secondary mb-4">
      <div class="container">
        <span class="navbar-brand">Mirako Router</span>
        <span class="navbar-text small">Orange Pi — Debian</span>
      </div>
    </nav>

    <div class="container">
      {% with messages = get_flashed_messages() %}
        {% if messages %}
          {% for msg in messages %}
            <div class="alert alert-info alert-dismissible fade show" role="alert">
              {{ msg }} <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Fechar"></button>
            </div>
          {% endfor %}
        {% endif %}
      {% endwith %}

      <div class="row g-3">
        <!-- Perfis -->
        <div class="col-12 col-lg-4">
          <div class="card h-100">
            <div class="card-header">Perfis de operação (atual: {{ last_profile }})</div>
            <div class="card-body">
  <form method="post" action="{{ url_for('setprofile') }}" class="d-grid gap-2">
    <button class="btn btn-primary" name="profile" value="ap">Roteador AP (WAN={{LAN_IF}} → AP em {{WLAN_IF}})</button>
    <button class="btn btn-primary" name="profile" value="3g">Roteador 3G PPP (WAN={{PPP_IF}} → AP/LAN)</button>
    <button class="btn btn-primary" name="profile" value="client-wifi">Cliente Wi‑Fi (WAN={{WLAN_IF}} → LAN {{LAN_IF}})</button>
    <button class="btn btn-secondary" name="profile" value="client-lan">Cliente LAN (WAN={{LAN_IF}}; Wi‑Fi liberado p/ scan)</button>
  </form>
            </div>
          </div>
        </div>

        <!-- Wi‑Fi -->
        <div class="col-12 col-lg-8">
          <div class="card h-100">
            <div class="card-header d-flex justify-content-between align-items-center">
              <span>Wi‑Fi ({{WLAN_IF}})</span>
              <div class="d-flex gap-2">
                <form method="post" action="{{ url_for('wifi_scan_route') }}">
                  <button class="btn btn-sm btn-outline-light">Escanear redes</button>
                </form>
              </div>
            </div>
            <div class="card-body">
              <!-- STATUS DETALHADO -->
              <div class="row g-3">
                <div class="col-sm-4">
                  <div class="small text-secondary">Modo / Estado</div>
                  <div class="fs-6">{{ wifi.mode }} / {{ wifi.state }}</div>
                </div>
                <div class="col-sm-4">
                  <div class="small text-secondary">SSID / BSSID</div>
                  <div class="fs-6 mono">{{ wifi.ssid }}<br><span class="small">{{ wifi.bssid }}</span></div>
                </div>
                <div class="col-sm-4">
                  <div class="small text-secondary">Canal / Freq / TX pwr</div>
                  <div class="fs-6">{{ wifi.channel }} / {{ wifi.freq_mhz }} / {{ wifi.txpower }}</div>
                </div>
                <div class="col-sm-3">
                  <div class="small text-secondary">RSSI</div>
                  <div class="fs-6">{{ wifi.rssi }}</div>
                </div>
                <div class="col-sm-3">
                  <div class="small text-secondary">Distância (estim.)</div>
                  <div class="fs-6">{{ wifi.distance_m }}</div>
                </div>
                <div class="col-sm-3">
                  <div class="small text-secondary">Bitrate TX / RX</div>
                  <div class="fs-6">{{ wifi.tx_bitrate }} / {{ wifi.rx_bitrate }}</div>
                </div>
                <div class="col-sm-3">
                  <div class="small text-secondary">Clientes (se AP)</div>
                  <div class="fs-6">{{ wifi.clients }}</div>
                </div>
                <div class="col-sm-6">
                  <div class="small text-secondary">Tráfego (bytes)</div>
                  <div class="fs-6">TX: {{ wifi.tx_bytes }} — RX: {{ wifi.rx_bytes }}</div>
                </div>
                <div class="col-sm-6">
                  <div class="small text-secondary">Taxa instantânea</div>
                  <div class="fs-6">TX: {{ wifi.tx_bps }} — RX: {{ wifi.rx_bps }}</div>
                </div>
              </div>
              <hr>
              <!-- Formulário de conexão STA -->
              <form class="row gy-2 gx-2" method="post" action="{{ url_for('wifi_connect_route') }}">
                <div class="col-12">
                  <label class="form-label">SSID</label>
                  <input type="text" class="form-control" name="ssid" id="ssidField" required>
                </div>
                <div class="col-12">
                  <label class="form-label">Senha (vazio = rede aberta)</label>
                  <input type="password" class="form-control" name="psk" id="pskField" autocomplete="off">
                  <div class="form-check mt-1">
                    <input class="form-check-input" type="checkbox" id="showPass" onchange="togglePass()">
                    <label class="form-check-label small" for="showPass">Mostrar senha</label>
                  </div>
                </div>
                <div class="col-12 d-grid mt-2">
                  <button class="btn btn-success">Conectar</button>
                </div>
              </form>
              <form method="post" action="{{ url_for('wifi_disconnect_route') }}" class="mt-2">
                <button class="btn btn-outline-warning btn-sm">Desconectar Wi‑Fi</button>
              </form>

              {% if saved_networks and saved_networks|length > 0 %}
              <hr>
              <div class="small text-secondary">Redes salvas</div>
              <div class="table-responsive">
                <table class="table table-sm table-hover align-middle">
                  <thead><tr><th>ID</th><th>SSID</th><th>Flags</th></tr></thead>
                  <tbody>
                  {% for n in saved_networks %}
                    <tr>
                      <td class="mono">{{ n.id }}</td>
                      <td class="mono">{{ n.ssid }}</td>
                      <td>{{ n.flags }}</td>
                    </tr>
                  {% endfor %}
                  </tbody>
                </table>
              </div>
              {% endif %}
              {% if scan %}
              <hr>
              <div class="table-responsive">
                <table class="table table-sm table-hover align-middle">
                  <thead><tr><th>SSID</th><th>Signal</th><th>Freq</th><th>Segurança</th></tr></thead>
                  <tbody>
                  {% for n in scan %}
                    <tr class="ssid-row" data-ssid="{{ n.ssid|e }}" onclick="document.getElementById('ssidField').value=this.dataset.ssid;">
                      <td class="mono">{{n.ssid}}</td><td>{{n.signal}}</td><td>{{n.freq}}</td><td>{{n.security}}</td>
                    </tr>
                  {% endfor %}
                  </tbody>
                </table>
              </div>
              {% elif scan_dbg %}
                <div class="alert alert-secondary mt-3"><small>{{ scan_dbg }}</small></div>
              {% endif %}
            </div>
          </div>
        </div>

        <!-- Modem 3G -->
        <div class="col-12 col-lg-4">
          <div class="card h-100">
            <div class="card-header">Modem 3G/PPP ({{PPP_IF}})</div>
            <div class="card-body">
              <div class="d-grid gap-2">
                <form method="post" action="{{ url_for('modem_connect_route') }}">
                  <button class="btn btn-success">Conectar modem (pppd call {{PPP_PEER}})</button>
                </form>
                <form method="post" action="{{ url_for('modem_disconnect_route') }}">
                  <button class="btn btn-outline-warning">Desconectar modem (poff {{PPP_PEER}})</button>
                </form>
                <!-- Toggle auto dial when in 3G profile -->
                <form method="post" action="{{ url_for('modem_auto_dial_route') }}">
                  <div class="form-check form-switch mt-2">
                    <input class="form-check-input" type="checkbox" id="autoDialToggle" name="auto_dial" value="1" {% if auto_dial_enabled %}checked{% endif %} onchange="this.form.submit()">
                    <label class="form-check-label" for="autoDialToggle">Discagem automática (3G)</label>
                  </div>
                </form>
              </div>
              <hr>
              <div class="small text-secondary">IPv4 ({{PPP_IF}})</div>
              <pre class="mono">{{ ppp_ipv4 }}</pre>
            </div>
          </div>
        </div>

        <!-- SISTEMA -->
        <div class="col-12 col-lg-8">
          <div class="card h-100">
            <div class="card-header">Sistema</div>
            <div class="card-body">
              <div class="row g-3">
                <div class="col-md-3">
                  <div class="small text-secondary">Temp CPU</div>
                  <div class="fs-5">{{ cpu_temp }}</div>
                </div>
                <div class="col-md-3">
                  <div class="small text-secondary">Uso CPU</div>
                  <div class="fs-5">{{ cpu_pct }}%</div>
                </div>
                <div class="col-md-3">
                  <div class="small text-secondary">Memória</div>
                  <div class="fs-6">{{ mem_used }} / {{ mem_total }} ({{ mem_pct }}%)</div>
                </div>
                <div class="col-md-3">
                  <div class="small text-secondary">Disco (/)</div>
                  <div class="fs-6">{{ disk_used }} / {{ disk_total }} ({{ disk_pct }}%)</div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- REDE -->
        <div class="col-12">
          <div class="card h-100">
            <div class="card-header">Rede (estatísticas por interface)</div>
            <div class="card-body">
              <div class="table-responsive">
                <table class="table table-sm table-hover align-middle">
                  <thead><tr><th>Interface</th><th>Estado</th><th>IPv4</th><th>RX</th><th>TX</th></tr></thead>
                  <tbody>
                    {% for n in netlist %}
                      <tr><td class="mono">{{ n.dev }}</td><td>{{ n.state }}</td><td class="mono">{{ n.ipv4 }}</td><td>{{ n.rx }}</td><td>{{ n.tx }}</td></tr>
                    {% endfor %}
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>

        <!-- ROTAS & DNS & DHCP -->
        <div class="col-12">
          <div class="card h-100">
            <div class="card-header">Rotas & DNS & DHCP</div>
            <div class="card-body">
              <div class="row g-3">
                <div class="col-md-4">
                  <div class="small text-secondary">Rota padrão</div>
                  <pre class="mono">{{ def_route }}</pre>
                  <div class="small text-secondary mt-2">Rotas</div>
                  <pre class="mono">{{ all_routes }}</pre>
                </div>
                <div class="col-md-4">
                  <div class="small text-secondary">DNS</div>
                  <pre class="mono">{{ dns }}</pre>
                </div>
                <div class="col-md-4">
                  <div class="small text-secondary">DHCP Leases{% if leases_path %} ({{ leases_path }}){% endif %}</div>
                  {% if leases and leases|length>0 %}
                  <div class="table-responsive">
                    <table class="table table-sm table-hover align-middle">
                      <thead><tr><th>IP</th><th>Host</th><th>MAC</th><th>Expira</th></tr></thead>
                      <tbody>
                        {% for L in leases %}
                          <tr>
                            <td class="mono">{{ L.ip }}</td>
                            <td class="mono">{{ L.hostname or "-" }}</td>
                            <td class="mono">{{ L.mac }}</td>
                            <td class="mono">{{ L.expiry }}</td>
                          </tr>
                        {% endfor %}
                      </tbody>
                    </table>
                  </div>
                  {% else %}
                    <pre class="mono">Sem leases ou arquivo não encontrado.</pre>
                  {% endif %}
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- SERVIÇOS -->
        <div class="col-12">
          <div class="card h-100">
            <div class="card-header">Serviços</div>
            <div class="card-body">
              <div class="table-responsive">
                <table class="table table-sm table-hover align-middle">
                  <thead><tr><th>Serviço</th><th>Status</th><th>Enabled</th><th>Ações</th></tr></thead>
                  <tbody>
                    {% for s in services %}
                      <tr>
                        <td class="mono">{{ s.name }}</td>
                        <td>{{ 'ativo' if s.active else 'inativo' }}</td>
                        <td>{{ 'habilitado' if s.enabled else 'desabilitado' }}</td>
                        <td>
                          <form method="post" action="{{ url_for('svc_action_route') }}" class="d-inline">
                            <input type="hidden" name="svc" value="{{ s.name }}">
                            <div class="btn-group btn-group-sm" role="group">
                              <button class="btn btn-success" name="action" value="start">Start</button>
                              <button class="btn btn-warning" name="action" value="stop">Stop</button>
                              <button class="btn btn-info" name="action" value="restart">Restart</button>
                              {% if s.enabled %}
                              <button class="btn btn-secondary" name="action" value="disable">Disable</button>
                              {% else %}
                              <button class="btn btn-primary" name="action" value="enable">Enable</button>
                              {% endif %}
                            </div>
                          </form>
                        </td>
                      </tr>
                    {% endfor %}
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>

        <!-- Gerenciador de Arquivos -->
        <div class="col-12">
          <div class="card">
            <div class="card-header">Gerenciador de Arquivos (diretório root)</div>
            <div class="card-body">
              <form method="post" enctype="multipart/form-data" action="{{ url_for('file_upload_route') }}">
                <div class="row g-2 align-items-end">
                  <div class="col-sm-9">
                    <input class="form-control" type="file" name="file" required>
                  </div>
                  <div class="col-sm-3 d-grid">
                    <button class="btn btn-primary">Enviar</button>
                  </div>
                </div>
              </form>
              {% if root_files and root_files|length > 0 %}
              <hr>
              <div class="small text-secondary">Arquivos em /root</div>
              <ul class="list-group list-group-flush">
                {% for f in root_files %}
                  <li class="list-group-item">{{ f }}</li>
                {% endfor %}
              </ul>
              {% endif %}
            </div>
          </div>
        </div>

        <!-- TERMINAL AO VIVO -->
        <div class="col-12" id="terminal_card">
          <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
              <span>Terminal ao vivo</span>
              <div class="d-flex flex-wrap gap-2">
                <button type="button" class="btn btn-sm btn-outline-primary" onclick="prefill('dmesg -wT')">dmesg</button>
                <button type="button" class="btn btn-sm btn-outline-primary" onclick="prefill('top -b')">top</button>
                <button type="button" class="btn btn-sm btn-outline-info" onclick="prefill('tcpdump -i {{WLAN_IF}} -n -vv -s 120')">tcpdump ({{WLAN_IF}})</button>
                <button type="button" class="btn btn-sm btn-warning" onclick="stopCmd()">Ctrl+C</button>
                <button type="button" class="btn btn-sm btn-secondary" onclick="clearLog()">Limpar</button>
                <button type="button" class="btn btn-sm btn-danger" onclick="rebootConfirm()">Reiniciar</button>
              </div>
            </div>
            <div class="card-body">
              <div id="terminal_wrap" class="mono" style="background:#0b0d10;border:1px solid #222;border-radius:.25rem;padding:.5rem;height:50vh;overflow:auto;">
                <pre id="terminal_out" class="mono m-0" style="color:#d6d6d6;white-space:pre-wrap;"></pre>
              </div>
              <div class="input-group mt-2">
                <span class="input-group-text" style="background:#151a1f;color:#9ad;">$</span>
                <input id="terminal_cmd" class="form-control" placeholder="Digite um comando e pressione Enter">
                <button class="btn btn-success" type="button" id="terminal_run_btn" title="Executar (Enter)">Enter</button>
              </div>
              <div class="form-text">Dica: para usar o top ao vivo aqui, basta digitar <code>top</code> — eu ativo <code>-b</code> automaticamente.</div>
            </div>
          </div>
        </div>

      </div><!-- row -->
      <div class="py-4"></div>
    </div><!-- container -->

    <!-- Local bootstrap fallback JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ENjdO4Dr2bkBIFxQpeoDGLVYI3GXx3E4p+3nZl5Mq9UOz1pENhb4u91WTrQF3R9F" crossorigin="anonymous" onerror="loadLocalBootstrap()"></script>
    <script>
    function loadLocalBootstrap() {
      var s = document.createElement('script');
      s.src = '/static/js/bootstrap.bundle.min.js';
      document.head.appendChild(s);
      console.warn('Bootstrap CDN indisponível, carregando versão local...');
    }
    function togglePass() {
      var ps = document.getElementById('pskField');
      if (ps) {
        ps.type = ps.type === 'password' ? 'text' : 'password';
      }
    }
    </script>

    <!-- Terminal control scripts -->
    <script>
    // ===== ANSI → HTML =====
    function ansiToHtml(text) {
      // Escape HTML special characters
      text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      const colors = {
        30:'color:#777;',31:'color:#ff6b6b;',32:'color:#9be564;',33:'color:#ffd166;',34:'color:#6ab0ff;',35:'color:#d785ff;',36:'color:#74d3ea;',37:'color:#eeeeee;',
        90:'color:#999;',91:'color:#ff7b7b;',92:'color:#a8f07a;',93:'color:#ffe07a;',94:'color:#7abaff;',95:'color:#e19bff;',96:'color:#85e9ff;',97:'color:#ffffff;'
      };
      const bg = {
        40:'background:#222;',41:'background:#5c1e1e;',42:'background:#294025;',43:'background:#4a3f1d;',
        44:'background:#1c2e4a;',45:'background:#3a2143;',46:'background:#1f3f45;',47:'background:#444;',
        100:'background:#333;',101:'background:#6b2a2a;',102:'background:#35552e;',103:'background:#5a4d24;',
        104:'background:#253c66;',105:'background:#4a2d54;',106:'background:#28545b;',107:'background:#666;'
      };
      return text.replace(/\x1b\[(\d+(?:;\d+)*)m/g, function(m, seq) {
        const codes = seq.split(';').map(Number);
        if (codes.includes(0)) return '</span>';
        let style = '';
        codes.forEach(function(c) {
          if (c === 1) style += 'font-weight:bold;';
          else if (c === 3) style += 'font-style:italic;';
          else if (c === 4) style += 'text-decoration:underline;';
          else if (colors[c]) style += colors[c];
          else if (bg[c]) style += bg[c];
          else if (c === 39) style += 'color:inherit;';
          else if (c === 49) style += 'background:transparent;';
        });
        return '<span style="' + style + '">';
      });
    }
    // ===== Terminal live =====
    let polling = null;
    let didInitialScroll = false;
    let userScrolledUp = false;
    function prefill(cmd) {
      const el = document.getElementById('terminal_cmd');
      if (el) { el.value = cmd; el.focus(); }
      const anchor = document.getElementById('terminal_card') || el;
      if (anchor) anchor.scrollIntoView({behavior:'smooth', block:'center'});
    }
    async function pullLog() {
      try {
        const r = await fetch('/shell/log?ts=' + Date.now());
        const txt = await r.text();
        const out = document.getElementById('terminal_out');
        const wrap = document.getElementById('terminal_wrap');
        if (out && wrap) {
          const atBottom = (wrap.scrollTop + wrap.clientHeight) >= (wrap.scrollHeight - 10);
          out.innerHTML = ansiToHtml(txt);
          if (!didInitialScroll) {
            wrap.scrollTop = wrap.scrollHeight;
            didInitialScroll = true;
          } else if (atBottom && !userScrolledUp) {
            wrap.scrollTop = wrap.scrollHeight;
          }
        }
      } catch (e) {
        // ignore errors
      }
    }
    function startPolling() {
      if (polling) clearInterval(polling);
      pullLog();
      polling = setInterval(pullLog, 900);
    }
    (function() {
      const wrap = document.getElementById('terminal_wrap');
      if (!wrap) return;
      wrap.addEventListener('scroll', function() {
        const nearBottom = (wrap.scrollTop + wrap.clientHeight) >= (wrap.scrollHeight - 10);
        userScrolledUp = !nearBottom;
      });
    })();
    async function runCmdFromInput() {
      const el = document.getElementById('terminal_cmd');
      const cmd = (el && el.value) ? el.value.trim() : '';
      if (!cmd) return;
      await fetch('/shell/run', {
        method:'POST',
        headers:{'Content-Type':'application/x-www-form-urlencoded'},
        body: new URLSearchParams({cmd: cmd})
      });
      didInitialScroll = false;
      userScrolledUp = false;
      startPolling();
    }
    async function stopCmd() {
      await fetch('/shell/stop', {method:'POST'});
    }
    async function clearLog() {
      await fetch('/shell/clear', {method:'POST'});
      const out = document.getElementById('terminal_out');
      if (out) out.innerHTML = '';
      didInitialScroll = false;
      userScrolledUp = false;
    }
    async function rebootConfirm() {
      if (!confirm('Reiniciar agora?')) return;
      await fetch('/reboot', {method:'POST'});
      alert('Reiniciando...');
    }
    (function() {
      const el = document.getElementById('terminal_cmd');
      if (!el) return;
      el.addEventListener('keydown', function(ev) {
        if (ev.key === 'Enter') {
          ev.preventDefault();
          runCmdFromInput();
        }
      });
    })();
    (function() {
      const btn = document.getElementById('terminal_run_btn');
      if (!btn) return;
      btn.addEventListener('click', function(ev) {
        ev.preventDefault();
        runCmdFromInput();
      });
    })();
    startPolling();
    </script>
  </body>
</html>
"""

###############################################################################
# Routes
###############################################################################
@app.route("/", methods=["GET"])
def index() -> Any:
    t = cpu_temp_c()
    cpu_pct = round(cpu_usage_pct(), 1)
    mem = mem_stats()
    disk = disk_stats("/")
    netlist = [net_stats_for(i) for i in list_interfaces(include_virtual=True, include_lo=True)]
    leases, leases_raw, leases_path = read_dnsmasq_leases()
    context = dict(
        WLAN_IF=WLAN_IF,
        LAN_IF=LAN_IF,
        PPP_IF=PPP_IF,
        PPP_PEER=PPP_PEER,
        scan=[],
        scan_dbg=None,
        wifi=wifi_status_details(),
        wlan_ipv4=get_ipv4_list(WLAN_IF),
        ppp_ipv4=get_ipv4_list(PPP_IF),
        def_route=default_route(),
        all_routes=routes(),
        dns=dns_info(),
        leases=leases,
        leases_path=leases_path,
        cpu_temp=(f"{t:.1f} °C" if t is not None else "-"),
        cpu_pct=cpu_pct,
        mem_used=human_bytes(mem["used"]),
        mem_total=human_bytes(mem["total"]),
        mem_pct=f"{mem['pct']:.1f}",
        disk_total=human_bytes(disk["total"]),
        disk_used=human_bytes(disk["used"]),
        disk_pct=f"{disk['pct']:.1f}",
        procs=processes_top(20),
        netlist=netlist,
        services=list_services(),
        last_profile=get_last_profile(),
        saved_networks=get_saved_networks(),
        root_files=list_root_files(),
        auto_dial_enabled=is_auto_dial_enabled(),
    )
    return render_template_string(TEMPLATE, **context)


@app.post("/wifi/scan")
def wifi_scan_route():
    nets, dbg = wifi_scan()
    t = cpu_temp_c()
    cpu_pct = round(cpu_usage_pct(), 1)
    mem = mem_stats()
    disk = disk_stats("/")
    netlist = [net_stats_for(i) for i in list_interfaces(include_virtual=True, include_lo=True)]
    leases, leases_raw, leases_path = read_dnsmasq_leases()
    context = dict(
        WLAN_IF=WLAN_IF,
        LAN_IF=LAN_IF,
        PPP_IF=PPP_IF,
        PPP_PEER=PPP_PEER,
        scan=nets,
        scan_dbg=dbg,
        wifi=wifi_status_details(),
        wlan_ipv4=get_ipv4_list(WLAN_IF),
        ppp_ipv4=get_ipv4_list(PPP_IF),
        def_route=default_route(),
        all_routes=routes(),
        dns=dns_info(),
        leases=leases,
        leases_path=leases_path,
        cpu_temp=(f"{t:.1f} °C" if t is not None else "-"),
        cpu_pct=cpu_pct,
        mem_used=human_bytes(mem["used"]),
        mem_total=human_bytes(mem["total"]),
        mem_pct=f"{mem['pct']:.1f}",
        disk_total=human_bytes(disk["total"]),
        disk_used=human_bytes(disk["used"]),
        disk_pct=f"{disk['pct']:.1f}",
        procs=processes_top(20),
        netlist=netlist,
        services=list_services(),
        last_profile=get_last_profile(),
        auto_dial_enabled=is_auto_dial_enabled(),
        saved_networks=get_saved_networks(),
        root_files=list_root_files(),
    )
    return render_template_string(TEMPLATE, **context)


@app.post("/wifi/connect")
def wifi_connect_route():
    ssid = (request.form.get("ssid") or "").strip()
    psk = (request.form.get("psk") or "").strip()
    if not ssid:
        flash("Informe um SSID.")
        return redirect(url_for("index"))
    ok, msg = wifi_connect(ssid, psk if psk else None)
    flash(("Conectado" if ok else "Falha") + f" ({msg})")
    return redirect(url_for("index"))


@app.post("/wifi/disconnect")
def wifi_disconnect_route():
    ok, msg = wifi_disconnect()
    flash(("Desconectado" if ok else "Falha") + f" ({msg})")
    return redirect(url_for("index"))


@app.post("/setprofile")
def setprofile():
    profile = request.form.get("profile", "").strip()
    rc, out = profile_set(profile)
    # Save last profile regardless of rc
    try:
        os.makedirs("/var/lib/mirako", exist_ok=True)
        with open("/var/lib/mirako/last_profile", "w", encoding="utf-8") as f:
            f.write(profile.strip() or "ap")
            f.flush()
            os.fsync(f.fileno())
            os.sync()
    except Exception:
        pass
    flash(out if out else ("ok" if rc == 0 else "erro"))
    return redirect(url_for("index"))


@app.post("/modem/connect")
def modem_connect_route():
    ok, msg = modem_connect()
    flash(("pon enviado" if ok else "Falha") + f" ({msg})")
    return redirect(url_for("index"))


@app.post("/modem/disconnect")
def modem_disconnect_route():
    ok, msg = modem_disconnect()
    flash(("poff enviado" if ok else "Falha") + f" ({msg})")
    return redirect(url_for("index"))

@app.post("/modem/auto_dial")
def modem_auto_dial_route():
    """Toggle automatic PPP dialing.

    If the form field 'auto_dial' equals '1', enable auto dial; otherwise disable.
    The setting is persisted in AUTO_DIAL_FILE, read by mirako-ppp-keepalive.sh.
    """
    val = (request.form.get("auto_dial") or "").strip()
    enabled = val == "1"
    set_auto_dial(enabled)
    flash("Discagem automática " + ("habilitada" if enabled else "desabilitada"))
    return redirect(url_for("index"))

# File upload route for the root directory file manager
@app.post("/file/upload")
def file_upload_route():
    """Handle file uploads to the /root directory."""
    uploaded = request.files.get("file")
    if uploaded and uploaded.filename:
        filename = os.path.basename(uploaded.filename)
        save_path = os.path.join("/root", filename)
        try:
            uploaded.save(save_path)
            flash(f"Arquivo '{filename}' enviado para /root")
        except Exception as e:
            flash(f"Erro ao salvar arquivo: {e}")
    else:
        flash("Nenhum arquivo selecionado.")
    return redirect(url_for("index"))


@app.post("/svc_action")
def svc_action_route():
    svc = (request.form.get("svc") or "").strip()
    action = (request.form.get("action") or "").strip()
    if not svc or not action:
        flash("Ação ou serviço inválido.")
        return redirect(url_for("index"))
    ok, msg = service_action(svc, action)
    flash(("Sucesso" if ok else "Falha") + f" ({msg})")
    return redirect(url_for("index"))


# ---------------------------------------------------------------------------
# Shell & Terminal routes
# These endpoints allow the front‑end to start/stop commands, fetch log
# output and clear logs.  They return JSON for ease of use with fetch().

@app.post("/shell/run")
def shell_run_route():
    cmd = (
        request.form.get("cmd")
        or (request.json.get("cmd") if request.is_json else "")
        or ""
    ).strip()
    if not cmd:
        return {"ok": False, "err": "comando vazio"}, 400
    start_command(cmd)
    return {"ok": True}


@app.get("/shell/log")
def shell_log_route():
    data = read_log_tail()
    return app.response_class(data, mimetype="text/plain; charset=utf-8")


@app.post("/shell/stop")
def shell_stop_route():
    stop_command()
    return {"ok": True}


@app.post("/shell/clear")
def shell_clear_route():
    clear_log()
    return {"ok": True}


@app.post("/reboot")
def shell_reboot_route():
    # Attempt to reboot the machine.  Try shutdown first, fall back to reboot.
    try:
        subprocess.Popen(["/sbin/shutdown", "-r", "now"])
    except Exception:
        try:
            subprocess.Popen(["/sbin/reboot"])
        except Exception as e:
            return {"ok": False, "err": str(e)}, 500
    return {"ok": True}


###############################################################################
# Application entrypoint
###############################################################################
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=80)
EOF

sudo systemctl restart mirako-web









sudo tee /etc/systemd/system/mirako-web.service >/dev/null <<'EOF'
[Unit]
Description=Interface web de configuração do roteador
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
User=root
Group=root
WorkingDirectory=/opt/mirako_web
Environment=PYTHONUNBUFFERED=1
ExecStart=/usr/bin/python3 /opt/mirako_web/web_config.py
Restart=on-failure

[Install]
WantedBy=multi-user.target
EOF


sudo systemctl daemon-reload
sudo systemctl enable --now mirako-web.service


sudo systemctl restart mirako-web






sudo tee /usr/local/bin/mirako-autoboot.sh >/dev/null <<'EOF'
#!/usr/bin/env bash
# mirako-autoboot.sh — aplica o último perfil salvo sem reiniciar em loop
# e sem falhar por pequenos erros. Mantém AP estável no boot.
set -uo pipefail

PROFILE_FILE=/var/lib/mirako/last_profile
DEF=ap
want="$(cat "$PROFILE_FILE" 2>/dev/null || echo "$DEF")"

export WLAN_IF="${WLAN_IF:-wlan0}"
export LAN_IF="${LAN_IF:-end0}"
export PPP_IF="${PPP_IF:-ppp0}"
export PPP_PEER="${PPP_PEER:-3g}"
export PROFILES_SCRIPT="${PROFILES_SCRIPT:-/usr/local/bin/profiles.sh}"

log(){ echo "[autoboot] $*"; }

lan_has_link(){
  [ -r "/sys/class/net/$LAN_IF/carrier" ] && [ "$(cat "/sys/class/net/$LAN_IF/carrier" 2>/dev/null)" = "1" ]
}

ensure_wpa_running(){
  systemctl start "wpa_supplicant@${WLAN_IF}.service" >/dev/null 2>&1 || true
}

wifi_state(){
  command -v wpa_cli >/dev/null 2>&1 || { echo "DOWN"; return; }
  wpa_cli -i "$WLAN_IF" status 2>/dev/null | sed -n 's/^wpa_state=//p'
}

wlan_has_ipv4(){
  ip -4 addr show dev "$WLAN_IF" | grep -q 'inet '
}

try_dhcp_wlan(){
  command -v dhclient >/dev/null 2>&1 || return 0
  dhclient -r "$WLAN_IF" >/dev/null 2>&1 || true
  dhclient "$WLAN_IF"  >/dev/null 2>&1 || true
}

wait_wifi_connected(){
  local timeout="${1:-75}"
  local end=$((SECONDS+timeout))
  local associated=0
  while [ $SECONDS -lt $end ]; do
    st="$(wifi_state)"
    if [ "$st" = "COMPLETED" ]; then
      associated=1
      wlan_has_ipv4 && return 0
      try_dhcp_wlan
      sleep 2
      wlan_has_ipv4 && return 0
    else
      sleep 1
    fi
  done
  [ "$associated" = "1" ]
}

ppp_has_ipv4(){ ip -4 addr show dev "$PPP_IF" 2>/dev/null | grep -q 'inet '; }

ppp_ok(){
  ppp_has_ipv4 && ping -I "$PPP_IF" -c2 -W3 8.8.8.8 >/dev/null 2>&1
}

case "$want" in
  ap)
    log "Aplicando perfil AP"
    "$PROFILES_SCRIPT" ap || true
    exit 0
    ;;

  3g|ppp|ppp3g)
    log "Aplicando perfil 3G/PPP (AP fica ativo mesmo sem IPv4 ainda)"
    "$PROFILES_SCRIPT" 3g || true
    # Não falhar aqui; keepalive cuidará de rediscagem
    exit 0
    ;;

  client-lan|lan-client)
    if lan_has_link; then
      log "Aplicando cliente LAN"
      "$PROFILES_SCRIPT" client-lan || true
    else
      log "Sem link em LAN — fallback AP"
      "$PROFILES_SCRIPT" ap || true
    fi
    exit 0
    ;;

  client-wifi|wifi-client|sta)
    log "Aplicando cliente Wi-Fi com até 10 tentativas; fallback AP"
    ensure_wpa_running
    attempts=0
    while [ $attempts -lt 10 ]; do
      "$PROFILES_SCRIPT" client-wifi || true
      if wait_wifi_connected 30; then
        log "Wi-Fi conectado/associado. Mantendo client-wifi."
        exit 0
      fi
      attempts=$((attempts+1))
      log "Tentativa Wi-Fi ${attempts}/10 falhou; tentando novamente…"
    done
    log "Sem sucesso no Wi-Fi — fallback AP"
    "$PROFILES_SCRIPT" ap || true
    exit 0
    ;;

  *)
    log "Perfil desconhecido '$want' — usando AP"
    "$PROFILES_SCRIPT" ap || true
    exit 0
    ;;
esac

EOF

sudo chmod +x /usr/local/bin/mirako-autoboot.sh





sudo tee /etc/systemd/system/mirako-profile.service >/dev/null <<'UNIT'
[Unit]
Description=Aplicar perfil Mirako na inicialização (auto-seletor)
After=local-fs.target systemd-udev-settle.service network-online.target
Wants=network-online.target

[Service]
Type=oneshot
RemainAfterExit=yes
Environment=PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
Environment=WLAN_IF=wlan0
Environment=LAN_IF=end0
Environment=PPP_IF=ppp0
Environment=PPP_PEER=3g
Environment=PROFILES_SCRIPT=/usr/local/bin/profiles.sh
ExecStartPre=/bin/udevadm settle -t 20
ExecStart=/usr/local/bin/mirako-autoboot.sh

[Install]
WantedBy=multi-user.target


UNIT

sudo systemctl daemon-reload
sudo systemctl enable --now mirako-profile.service
sudo systemctl restart mirako-profile.service












sudo tee /usr/local/bin/mirako-ppp-keepalive.sh >/dev/null <<'EOF'
#!/usr/bin/env bash
set -Eeuo pipefail

# PPP keep‑alive daemon.
# Monitors PPP interface connectivity and re-applies the 3G profile if the
# connection drops. This script is intended to run continuously under
# mirako-ppp-keepalive.service.

PROFILE_FILE=/var/lib/mirako/last_profile
PROFILES_SCRIPT=${PROFILES_SCRIPT:-/usr/local/bin/profiles.sh}
PPP_IF=${PPP_IF:-ppp0}
CHECK_IP=${PPP_CONNECT_CHECK_HOST:-8.8.8.8}
# Toggle auto dial via file. If the file exists, auto dial is enabled.
AUTO_DIAL_FILE=${AUTO_DIAL_FILE:-/var/lib/mirako/auto_dial_enabled}

log(){ echo "[ppp-keepalive] $*"; logger -t mirako-ppp-keepalive "$*"; }

# AP está ativo?
ap_is_up(){ iw dev "$WLAN_IF" info 2>/dev/null | grep -q "type AP"; }

# Rediscagem "suave" do PPP (sem mexer no AP)
redial_ppp(){
  pkill -x pppd 2>/dev/null || true
  rm -f /var/lock/LCK..ttyUSB* 2>/dev/null || true
  (pppd call "$PPP_PEER" >/dev/null 2>&1 &) || true
}



# Determine if PPP interface has an IPv4 address.
ppp_has_ipv4(){ ip -4 addr show dev "$PPP_IF" 2>/dev/null | grep -q 'inet '; }

# Determine if PPP connectivity is OK by pinging a known IP.
ppp_ok(){ ppp_has_ipv4 && ping -I "$PPP_IF" -c2 -W3 "$CHECK_IP" >/dev/null 2>&1; }

# Ensure 3G profile is applied via profiles.sh (activates NAT & AP).
ensure_3g(){
  # Só reaplica o perfil 3G se o AP não estiver de pé.
  if ! ap_is_up; then
    "$PROFILES_SCRIPT" 3g || true
  fi
}


while :; do
  # Skip auto dial unless explicitly enabled
  if [ ! -f "$AUTO_DIAL_FILE" ]; then
    sleep 30
    continue
  fi
  WANT="$(cat "$PROFILE_FILE" 2>/dev/null || echo '')"
  if [[ "$WANT" != "3g" && "$WANT" != "ppp" && "$WANT" != "ppp3g" ]]; then
    log "last_profile='$WANT' não é 3G. Aguardando 15s…"
    sleep 15
    continue
  fi

  # Guarantee 3G profile is active.
  # Garanta que o AP 3G está ativo (sem flapar se já estiver)
  ensure_3g

  # Se PPP ok, apenas monitore
  if ppp_ok; then
    log "PPP ok (conectividade via $PPP_IF). Monitorando…"
    for j in {1..60}; do
      if ! ppp_ok; then
        log "Conectividade PPP perdida — tentando rediscagem…"
        break
      fi
      sleep 5
    done
  else
    # PPP não está OK. Se discagem automática estiver habilitada, rediscamos.
    if [ -f "$AUTO_DIAL_FILE" ]; then
      log "PPP sem conectividade; iniciando rediscagem (sem reiniciar AP)…"
      redial_ppp
      # janela curta para o PPP nascer
      for i in {1..20}; do
        if ppp_has_ipv4; then break; fi
        sleep 1
      done
    else
      log "PPP sem conectividade e discagem automática desabilitada; mantendo AP."
    fi
  fi

  sleep 3

  # Wait briefly for PPP to obtain IPv4.
  for i in {1..20}; do
    if ppp_has_ipv4; then break; fi
    sleep 1
  done

  if ppp_ok; then
    log "PPP ok (conectividade via $PPP_IF). Monitorando…"
    # Monitor in 5s intervals, break if connectivity lost.
    for j in {1..60}; do
      if ! ppp_ok; then
        log "Conectividade perdida — tentando reerguer perfil 3G…"
        break
      fi
      sleep 5
    done
  else
    log "PPP sem conectividade; reerguendo perfil 3G…"
  fi

  # Small delay before next cycle.
  sleep 3
done
EOF
sudo chmod +x /usr/local/bin/mirako-ppp-keepalive.sh







sudo tee /etc/systemd/system/mirako-ppp-keepalive.service >/dev/null <<'UNIT'
[Unit]
Description=Mirako PPP keep-alive (auto-redial 3G + AP)
After=network-online.target mirako-profile.service
Wants=network-online.target

[Service]
Type=simple
Environment=WLAN_IF=wlan0
Environment=LAN_IF=end0
Environment=PPP_IF=ppp0
Environment=PPP_PEER=3g
Environment=PROFILES_SCRIPT=/usr/local/bin/profiles.sh
ExecStart=/usr/local/bin/mirako-ppp-keepalive.sh
Restart=always
RestartSec=5s
# Provide a safe PATH for scripts
Environment=PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

[Install]
WantedBy=multi-user.target
UNIT

sudo systemctl daemon-reload
sudo systemctl enable --now mirako-ppp-keepalive.service









sudo tee /etc/ppp/ip-down.d/99-mirako >/dev/null <<'EOF'
#!/bin/sh
# PPP ip-down hook for Mirako. Handles fallback when PPP drops.
# If the last profile was 3G, do not force AP: allow pppd to redial.
LP="/var/lib/mirako/last_profile"
if [ -r "$LP" ]; then
  LAST="$(cat "$LP" 2>/dev/null)"
else
  LAST=""
fi

if [ "$LAST" = "3g" ] || [ "$LAST" = "ppp" ] || [ "$LAST" = "ppp3g" ]; then
  logger -t mirako "PPP caiu; mantendo perfil 3G para rediscagem automática (persist)."
  exit 0
fi

# For other profiles, fallback to AP.
logger -t mirako "PPP caiu; comutando para perfil AP (fallback)"
exec /usr/local/bin/profiles.sh ap
EOF
sudo chmod +x /etc/ppp/ip-down.d/99-mirako




sudo tee /etc/ppp/ip-up.d/00-mirako-dns >/dev/null <<'SH'
#!/bin/sh
# PPP ip-up hook for Mirako. Applies DNS settings learned via pppd (usepeerdns).
if [ -r /etc/ppp/resolv.conf ]; then
  # If /etc/resolv.conf is a symlink, replace it with a regular file.
  [ -L /etc/resolv.conf ] && rm -f /etc/resolv.conf
  cp -f /etc/ppp/resolv.conf /etc/resolv.conf
fi
exit 0
SH
sudo chmod +x /etc/ppp/ip-up.d/00-mirako-dns



sudo tee /etc/sysctl.d/98-mirako-rpf.conf >/dev/null <<'SYS'
net.ipv4.conf.all.rp_filter=0
net.ipv4.conf.default.rp_filter=0
net.ipv4.conf.ppp0.rp_filter=0
SYS
sudo sysctl --system













sudo journalctl -u mirako-web -f
sudo journalctl -u mirako-profile.service -f
sudo journalctl -f






sudo apt install samba
sudo mkdir -p /home/public
sudo chown nobody:nogroup /home/public    # Debian/Ubuntu; em CentOS pode ser nobody:nobody
sudo chmod 0777 /home/public
sudo chmod -R 0777 /home/public
sudo ufw allow samba




sudo tee /etc/samba/smb.conf >/dev/null <<'EOF'
[global]
   workgroup = WORKGROUP
   server string = MirakoSamba Server
   netbios name = MIRAKOSERVER
   security = user
   map to guest = Bad User
   log file = /var/log/samba/%m.log
   max log size = 50

   # Importante para aparecer na rede
   server role = standalone server
   local master = yes
   preferred master = yes
   os level = 255
   wins support = yes
   name resolve order = bcast host lmhosts wins

[Public]
   comment = Pasta pública - acesso guest
   path = /home/public
   browseable = yes
   guest ok = yes
   read only = no
   writable = yes
   public = yes
   force user = nobody
   create mask = 0777
   directory mask = 0777
   printable = no
EOF

















